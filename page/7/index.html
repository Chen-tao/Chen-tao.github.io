<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Engineer Blogger Creator Runner | ML DM JVM Web | 旅行 电影 歌手 摄影 | 读书的要义是尽量求得客观的认识，不是为了炫耀自己的‘创造力’，或‘发前人所未发’。 优秀程序员的价值，不在于其所掌握的几招屠龙之术，而是在细节中见真著。 如果我们可以一次把事情做对做好，在允许的范围内尽可能追求卓越，为什么不去做呢。 | @HNU">
<meta property="og:type" content="website">
<meta property="og:title" content="Chen-Tao">
<meta property="og:url" content="http://chen-tao.github.io/page/7/index.html">
<meta property="og:site_name" content="Chen-Tao">
<meta property="og:description" content="Engineer Blogger Creator Runner | ML DM JVM Web | 旅行 电影 歌手 摄影 | 读书的要义是尽量求得客观的认识，不是为了炫耀自己的‘创造力’，或‘发前人所未发’。 优秀程序员的价值，不在于其所掌握的几招屠龙之术，而是在细节中见真著。 如果我们可以一次把事情做对做好，在允许的范围内尽可能追求卓越，为什么不去做呢。 | @HNU">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chen-Tao">
<meta name="twitter:description" content="Engineer Blogger Creator Runner | ML DM JVM Web | 旅行 电影 歌手 摄影 | 读书的要义是尽量求得客观的认识，不是为了炫耀自己的‘创造力’，或‘发前人所未发’。 优秀程序员的价值，不在于其所掌握的几招屠龙之术，而是在细节中见真著。 如果我们可以一次把事情做对做好，在允许的范围内尽可能追求卓越，为什么不去做呢。 | @HNU">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chen-tao.github.io/page/7/"/>





  <title> Chen-Tao </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chen-Tao</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">颂其诗，读其书，不知其人，可乎？</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2015/07/14/java-qrcode-demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/14/java-qrcode-demo/" itemprop="url">
                  java生成二维码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-14T00:00:00+08:00">
                2015-07-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用Google开源库zxing生成二维码</p>
<ol>
<li><p>在<code>pom.xml</code>文件中添加以下依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;
    &lt;artifactId&gt;core&lt;/artifactId&gt;
    &lt;version&gt;2.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;
    &lt;artifactId&gt;javase&lt;/artifactId&gt;
    &lt;version&gt;2.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></li>
<li><p>生成二维码，并将logo嵌入</p>
<p> private static byte[] createQRCode(String url) throws Exception {</p>
<pre><code>QRCodeWriter writer = new QRCodeWriter();
HashMap&lt;EncodeHintType, Object&gt; m = new HashMap&lt;EncodeHintType, Object&gt;();
m.put(EncodeHintType.CHARACTER_SET, com.tencent.jungle.quntribe.helper.CommonUtil.UTF8);

// 按最大尺寸生成
BitMatrix bm = writer.encode(url, BarcodeFormat.QR_CODE, 600, 600, m);
MatrixToImageConfig config = new MatrixToImageConfig(BufferedImage.TYPE_INT_RGB, MatrixToImageConfig.WHITE);
BufferedImage image = MatrixToImageWriter.toBufferedImage(bm, config);
Graphics2D m2 = image.createGraphics();
BufferedImage overlay = ImageIO.read(new URL(BULUO_LOGO_IMAGE)/*new File(&quot;D://Penguins.jpg&quot;)*/);
int deltaHeight = image.getHeight() - overlay.getHeight();
int deltaWidth = image.getWidth()  - overlay.getWidth();

m2.drawImage(image, 0, 0, null);
m2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1f));
m2.setColor(Color.WHITE);
m2.drawImage(overlay, (int) Math.round(deltaWidth / 2),
        (int) Math.round(deltaHeight / 2), null);

m2.dispose();

ByteArrayOutputStream buffer = new ByteArrayOutputStream(512);
ImageIO.write(image, &quot;png&quot;, buffer);
return buffer.toByteArray();
</code></pre><p> }<br> ‘<br>这里有几个点需要注意：</p>
</li>
</ol>
<ul>
<li>构造函数要使用可以指定颜色区间的：(否则会导致产生黑白的图片)<br>MatrixToImageConfig config = new MatrixToImageConfig(BufferedImage.TYPE_INT_RGB, MatrixToImageConfig.WHITE);</li>
<li>setComposite设置对应位置关系，要使用<code>AlphaComposite.SRC_OVER</code>，这样，logo才不会被后面的二维码所覆盖<br>  参见：<a href="http://docs.oracle.com/javase/tutorial/2d/advanced/compositing.html" title="Compositing Graphics" target="_blank" rel="external">Compositing Graphics</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2015/07/11/cmake-intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/11/cmake-intro/" itemprop="url">
                  CMake入门实战
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-11T00:00:00+08:00">
                2015-07-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- content -->
<pre><code>&lt;div class=&quot;mypage&quot;&gt;
&lt;h2 id=&quot;什么是-cmake&quot;&gt;什么是 CMake&lt;/h2&gt;
</code></pre><p><blockquote><br><br><p>All problems in computer science can be solved by another level of indirection.</p>


<p><footer><strong>David Wheeler</strong></footer></p></blockquote><br></p><p></p>
<p></p><p>你或许听过好几种 Make 工具，例如 <a href="/wiki/tools-makefile.html">GNU Make</a> ，QT 的 <a href="http://qt-project.org/doc/qt-4.8/qmake-manual.html" target="_blank" rel="external">qmake</a> ，微软的 <a href="http://msdn.microsoft.com/en-us/library/ms930369.aspx" target="_blank" rel="external">MS nmake</a>，BSD Make（<a href="http://www.freebsd.org/doc/en/books/pmake/" target="_blank" rel="external">pmake</a>），<a href="http://makepp.sourceforge.net/" target="_blank" rel="external">Makepp</a>，等等。这些 Make 工具遵循着不同的规范和标准，所执行的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。<a id="more"></a></p><p></p>
<p></p><p>CMake<span class="block margin-div-outer"><span class="block margin-div-inner"><span class="block margin-note"><img src="/images/cmake/cmake100.png" alt=" CMake"><b>图 1</b>  CMake</span></span></span>就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。显然，CMake 是一个比上述几种 make 更高级的编译配置工具。一些使用 CMake 作为项目架构系统的知名开源项目有 <a href="http://www.vtk.org/" target="_blank" rel="external">VTK</a>、<a href="http://www.itk.org/" target="_blank" rel="external">ITK</a>、<a href="http://kde.org/" target="_blank" rel="external">KDE</a>、<a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/modules/core/doc/intro.html" target="_blank" rel="external">OpenCV</a>、<a href="http://www.openscenegraph.org/" target="_blank" rel="external">OSG</a> 等 <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>。</p><p></p>
<p></p><p>在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下：</p><p></p>
<p><ol style="list-style-type: decimal"></ol></p>
<p><li>编写 CMake 配置文件 CMakeLists.txt 。</li></p>
<p><li>执行命令 <code>cmake PATH</code> 或者 <code>ccmake PATH</code> 生成 Makefile <span class="margin-note-marker"><sup>1</sup></span> <span class="block margin-div-outer"><span class="block margin-div-inner"><span class="block margin-note"><span class="margin-note-marker">1</span><code>ccmake</code> 和 <code>cmake</code> 的区别在于前者提供了一个交互式的界面。 </span></span></span> 。其中， <code>PATH</code> 是 CMakeLists.txt 所在的目录。</li></p>
<p><li>使用 <code>make</code> 命令进行编译。</li><br></p>
<p></p><p>本文将从实例入手，一步步讲解 CMake 的常见用法，文中所有的实例代码可以在<a href="https://gitcafe.com/wzpan/cmake-demo" target="_blank" rel="external">这里</a>找到。如果你读完仍觉得意犹未尽，可以继续学习我在文章末尾提供的其他资源。</p><p></p>
<p></p><h2 id="入门案例单个源文件">入门案例：单个源文件</h2><p></p>
<p></p><p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p>本节对应的源代码所在目录：<a href="https://gitcafe.com/wzpan/cmake-demo/tree/master/Demo1" target="_blank" rel="external">Demo1</a>。</p><br></div></p><p></p>
<p></p><p>对于简单的项目，只需要写几行代码就可以了。例如，假设现在我们的项目中只有一个源文件 main.cc ，该程序的用途是计算一个数的指数幂。</p><p></p>
<p></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#include <stdio.h></stdio.h></div><div class="line">#include <stdlib.h></stdlib.h></div><div class="line"></div><div class="line">/<em>*</em></div><div class="line">  power - Calculate the power of number.</div><div class="line"> <em> @param base: Base value.</em></div><div class="line">  @param exponent: Exponent value.</div><div class="line"> <em></em></div><div class="line">  @return base raised to the power exponent.</div><div class="line"> <em>/</em></div><div class="line">double power(double base, int exponent)</div><div class="line">{</div><div class="line">    int result = base;</div><div class="line">    int i;</div><div class="line">    </div><div class="line">    for(i = 1; i &lt; exponent; ++i){</div><div class="line">        result = result  base;</div><div class="line">    }</div><div class="line"></div><div class="line">    return result;</div><div class="line">}</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">{</div><div class="line">    if (argc &lt; 3){</div><div class="line">        printf(“Usage: %s base exponent \n”, argv[0]);</div><div class="line">        return 1;</div><div class="line">    }</div><div class="line">    double base = atof(argv[1]);</div><div class="line">    int exponent = atoi(argv[2]);</div><div class="line">    double result = power(base, exponent);</div><div class="line">    printf(“%g ^ %d is %g\n”, base, exponent, result);</div><div class="line">    return 0;</div><div class="line">}</div></pre></td></tr></table></figure></p><p></p>
<p></p><h4 id="编写-cmakelists.txt">编写 CMakeLists.txt</h4><p></p>
<p></p><p>首先编写 CMakeLists.txt 文件，并保存在与 main.cc 源文件同个目录下：</p><p></p>
<p></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># CMake 最低版本号要求</div><div class="line">cmake_minimum_required (VERSION 2.8)</div><div class="line"></div><div class="line"># 项目信息</div><div class="line">project (Demo1)</div><div class="line"></div><div class="line"># 指定生成目标</div><div class="line">add_executable(Demo main.cc)</div></pre></td></tr></table></figure></p><p></p>
<p></p><p>CMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 <code>#</code> 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。</p><p></p>
<p></p><p>对于上面的 CMakeLists.txt 文件，依次出现了几个命令：</p><p></p>
<p><ol style="list-style-type: decimal"></ol></p>
<p><li><code>cmake_minimum_required</code>：指定运行此配置文件所需的 CMake 的最低版本；</li></p>
<p><li><code>project</code>：参数是 <code>main</code>，该命令表示项目的名称是 main 。</li></p>
<p><li><code>add_executable</code>： 将名为 main.cc 的源文件编译成一个名称为 Demo 的可执行文件。</li><br></p>
<p></p><h4 id="编译项目">编译项目</h4><p></p>
<p></p><p>之后，在当前目录执行 <code>cmake .</code> ，得到 Makefile 后再使用 <code>make</code> 命令编译得到 Demo1 可执行文件。</p><p></p>
<p></p><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">[ehome@xman Demo1]$ cmake .</div><div class="line">– The C compiler identification is GNU <span class="number">4.8</span>.<span class="number">2</span></div><div class="line">– The CXX compiler identification is GNU <span class="number">4.8</span>.<span class="number">2</span></div><div class="line">– Check <span class="keyword">for</span> working C compiler: /usr/sbin/cc</div><div class="line">– Check <span class="keyword">for</span> working C compiler: /usr/sbin/cc – works</div><div class="line">– Detecting C compiler ABI info</div><div class="line">– Detecting C compiler ABI info - <span class="keyword">done</span></div><div class="line">– Check <span class="keyword">for</span> working CXX compiler: /usr/sbin/c++</div><div class="line">– Check <span class="keyword">for</span> working CXX compiler: /usr/sbin/c++ – works</div><div class="line">– Detecting CXX compiler ABI info</div><div class="line">– Detecting CXX compiler ABI info - <span class="keyword">done</span></div><div class="line">– Configuring <span class="keyword">done</span></div><div class="line">– Generating <span class="keyword">done</span></div><div class="line">– Build files have been written to: /home/ehome/Documents/programming/C/power/Demo1</div><div class="line">[ehome@xman Demo1]$ make</div><div class="line">Scanning dependencies of target Demo</div><div class="line">[<span class="number">100</span>%] Building C object CMakeFiles/Demo.dir/main.cc.o</div><div class="line">Linking C executable Demo</div><div class="line">[<span class="number">100</span>%] Built target Demo</div><div class="line">[ehome@xman Demo1]$ ./Demo <span class="number">5</span> <span class="number">4</span></div><div class="line"><span class="number">5</span> ^ <span class="number">4</span> is <span class="number">625</span></div><div class="line">[ehome@xman Demo1]$ ./Demo <span class="number">7</span> <span class="number">3</span></div><div class="line"><span class="number">7</span> ^ <span class="number">3</span> is <span class="number">343</span></div><div class="line">[ehome@xman Demo1]$ ./Demo <span class="number">2</span> <span class="number">10</span></div><div class="line"><span class="number">2</span> ^ <span class="number">10</span> is <span class="number">1024</span></div></pre></td></tr></table></figure></p><p></p>
<p></p><h2 id="多个源文件">多个源文件</h2><p></p>
<p></p><h3 id="同一目录多个源文件">同一目录，多个源文件</h3><p></p>
<p></p><p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p>本小节对应的源代码所在目录：<a href="https://gitcafe.com/wzpan/cmake-demo/tree/master/Demo2" target="_blank" rel="external">Demo2</a>。</p><br></div></p><p></p>
<p></p><p>上面的例子只有单个源文件。现在假如把 <code>power</code> 函数单独写进一个名为 <code>MathFunctions.c</code> 的源文件里，使得这个工程变成如下的形式：</p><p></p>
<p></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">./Demo2</div><div class="line">    |</div><div class="line">    +— main.cc</div><div class="line">    |</div><div class="line">    +— MathFunctions.cc</div><div class="line">    |</div><div class="line">    +— MathFunctions.h</div></pre></td></tr></table></figure></p><p></p>
<p></p><p>这个时候，CMakeLists.txt 可以改成如下的形式：</p><p></p>
<p></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># CMake 最低版本号要求</div><div class="line">cmake_minimum_required (VERSION 2.8)</div><div class="line"></div><div class="line"># 项目信息</div><div class="line">project (Demo2)</div><div class="line"></div><div class="line"># 指定生成目标</div><div class="line">add_executable(Demo main.cc MathFunctions.cc)</div></pre></td></tr></table></figure></p><p></p>
<p></p><p>唯一的改动只是在 <code>add_executable</code> 命令中增加了一个 <code>MathFunctions.cc</code> 源文件。这样写当然没什么问题，但是如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。更省事的方法是使用 <code>aux_source_directory</code> 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：</p><p></p>
<p></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aux_source_directory(<dir> <variable>)</variable></dir></div></pre></td></tr></table></figure></p><p></p>
<p></p><p>因此，可以修改 CMakeLists.txt 如下：</p><p></p>
<p></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># CMake 最低版本号要求</div><div class="line">cmake_minimum_required (VERSION 2.8)</div><div class="line"></div><div class="line"># 项目信息</div><div class="line">project (Demo2)</div><div class="line"></div><div class="line"># 查找当前目录下的所有源文件</div><div class="line"># 并将名称保存到 DIR_SRCS 变量</div><div class="line">aux_source_directory(. DIR_SRCS)</div><div class="line"></div><div class="line"># 指定生成目标</div><div class="line">add_executable(Demo ${DIR_SRCS})</div></pre></td></tr></table></figure></p><p></p>
<p></p><p>这样，CMake 会将当前目录所有源文件的文件名赋值给变量 <code>DIR_SRCS</code> ，再指示变量 <code>DIR_SRCS</code> 中的源文件需要编译成一个名称为 Demo 的可执行文件。</p><p></p>
<p></p><h3 id="多个目录多个源文件">多个目录，多个源文件</h3><p></p>
<p></p><p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p>本小节对应的源代码所在目录：<a href="https://gitcafe.com/wzpan/cmake-demo/tree/master/Demo3" target="_blank" rel="external">Demo3</a>。</p><br></div></p><p></p>
<p></p><p>现在进一步将 MathFunctions.h 和 MathFunctions.cc 文件移动到 math 目录下。</p><p></p>
<p></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">./Demo3</div><div class="line">    |</div><div class="line">    +— main.cc</div><div class="line">    |</div><div class="line">    +— math/</div><div class="line">          |</div><div class="line">          +— MathFunctions.cc</div><div class="line">          |</div><div class="line">          +— MathFunctions.h</div></pre></td></tr></table></figure></p><p></p>
<p></p><p>对于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。</p><p></p>
<p></p><p>根目录中的 CMakeLists.txt ：</p><p></p>
<p></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># CMake 最低版本号要求</div><div class="line">cmake_minimum_required (VERSION 2.8)</div><div class="line"></div><div class="line"># 项目信息</div><div class="line">project (Demo3)</div><div class="line"></div><div class="line"># 查找当前目录下的所有源文件</div><div class="line"># 并将名称保存到 DIR_SRCS 变量</div><div class="line">aux_source_directory(. DIR_SRCS)</div><div class="line"></div><div class="line"># 添加 math 子目录</div><div class="line">add_subdirectory(math)</div><div class="line"></div><div class="line"># 指定生成目标 </div><div class="line">add_executable(Demo main.cc)</div><div class="line"></div><div class="line"># 添加链接库</div><div class="line">target_link_libraries(Demo MathFunctions)</div></pre></td></tr></table></figure></p><p></p>
<p></p><p>该文件添加了下面的内容: 第3行，使用命令 <code>add_subdirectory</code> 指明本项目包含一个子目录 math，这样 math 目录下的 CMakeLists.txt 文件和源代码也会被处理 。第6行，使用命令 <code>target_link_libraries</code> 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。</p><p></p>
<p></p><p>子目录中的 CMakeLists.txt：</p><p></p>
<p></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 查找当前目录下的所有源文件</div><div class="line"># 并将名称保存到 DIR_LIB_SRCS 变量</div><div class="line">aux_source_directory(. DIR_LIB_SRCS)</div><div class="line"></div><div class="line"># 生成链接库</div><div class="line">add_library (MathFunctions ${DIR_LIB_SRCS})</div></pre></td></tr></table></figure></p><p></p>
<p></p><p>在该文件中使用命令 <code>add_library</code> 将 src 目录中的源文件编译为静态链接库。</p><p></p>
<p></p><h2 id="自定义编译选项">自定义编译选项</h2><p></p>
<p></p><p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p>本节对应的源代码所在目录：<a href="https://gitcafe.com/wzpan/cmake-demo/tree/master/Demo4" target="_blank" rel="external">Demo4</a>。</p><br></div></p><p></p>
<p></p><p>CMake 允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。</p><p></p>
<p></p><p>例如，可以将 MathFunctions 库设为一个可选的库，如果该选项为 <code>ON</code> ，就使用该库定义的数学函数来进行运算。否则就调用标准库中的数学函数库。</p><p></p>
<p></p><h4 id="修改-cmakelists-文件">修改 CMakeLists 文件</h4><p></p>
<p></p><p>我们要做的第一步是在顶层的 CMakeLists.txt 文件中添加该选项：</p><p></p>
<p></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"># CMake 最低版本号要求</div><div class="line">cmake_minimum_required (VERSION 2.8)</div><div class="line"></div><div class="line"># 项目信息</div><div class="line">project (Demo4)</div><div class="line"></div><div class="line"># 加入一个配置头文件，用于处理 CMake 对源码的设置</div><div class="line">configure_file (</div><div class="line">  “${PROJECT_SOURCE_DIR}/config.h.in”</div><div class="line">  “${PROJECT_BINARY_DIR}/config.h”</div><div class="line">  )</div><div class="line"></div><div class="line"># 是否使用自己的 MathFunctions 库</div><div class="line">option (USE_MYMATH</div><div class="line">       “Use provided math implementation” ON)</div><div class="line"></div><div class="line"># 是否加入 MathFunctions 库</div><div class="line">if (USE_MYMATH)</div><div class="line">  include_directories (“${PROJECT_SOURCE_DIR}/math”)</div><div class="line">  add_subdirectory (math)  </div><div class="line">  set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)</div><div class="line">endif (USE_MYMATH)</div><div class="line"></div><div class="line"># 查找当前目录下的所有源文件</div><div class="line"># 并将名称保存到 DIR_SRCS 变量</div><div class="line">aux_source_directory(. DIR_SRCS)</div><div class="line"></div><div class="line"># 指定生成目标</div><div class="line">add_executable(Demo ${DIR_SRCS})</div><div class="line">target_link_libraries (Demo  ${EXTRA_LIBS})</div></pre></td></tr></table></figure></p><p></p>
<p></p><p>其中：</p><p></p>
<p><ol style="list-style-type: decimal"></ol></p>
<p><li>第7行的 <code>configure_file</code> 命令用于加入一个配置头文件 config.h ，这个文件由 CMake 从 config.h.in 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。</li></p>
<p><li>第13行的 <code>option</code> 命令添加了一个 <code>USE_MYMATH</code> 选项，并且默认值为 <code>ON</code> 。</li></p>
<p><li>第17行根据 <code>USE_MYMATH</code> 变量的值来决定是否使用我们自己编写的 MathFunctions 库。</li><br></p>
<p></p><h4 id="修改-main.cc-文件">修改 main.cc 文件</h4><p></p>
<p></p><p>之后修改 main.cc 文件，让其根据 <code>USE_MYMATH</code> 的预定义值来决定是否调用标准库还是 MathFunctions 库：</p><p></p>
<p></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#include <stdio.h></stdio.h></div><div class="line">#include <stdlib.h></stdlib.h></div><div class="line">#include “config.h”</div><div class="line"></div><div class="line">#ifdef USE_MYMATH</div><div class="line">  #include “math/MathFunctions.h”</div><div class="line">#else</div><div class="line">  #include <math.h></math.h></div><div class="line">#endif</div><div class="line"></div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">{</div><div class="line">    if (argc &lt; 3){</div><div class="line">        printf(“Usage: %s base exponent \n”, argv[0]);</div><div class="line">        return 1;</div><div class="line">    }</div><div class="line">    double base = atof(argv[1]);</div><div class="line">    int exponent = atoi(argv[2]);</div><div class="line">    </div><div class="line">#ifdef USE_MYMATH</div><div class="line">    printf(“Now we use our own Math library. \n”);</div><div class="line">    double result = power(base, exponent);</div><div class="line">#else</div><div class="line">    printf(“Now we use the standard library. \n”);</div><div class="line">    double result = pow(base, exponent);</div><div class="line">#endif</div><div class="line">    printf(“%g ^ %d is %g\n”, base, exponent, result);</div><div class="line">    return 0;</div><div class="line">}</div></pre></td></tr></table></figure></p><p></p>
<p></p><h4 id="编写-config.h.in-文件">编写 config.h.in 文件</h4><p></p>
<p></p><p>上面的程序值得注意的是第2行，这里引用了一个 config.h 文件，这个文件预定义了 <code>USE_MYMATH</code> 的值。但我们并不直接编写这个文件，为了方便从 CMakeLists.txt 中导入配置，我们编写一个 config.h.in 文件，内容如下：</p><p></p>
<p></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#cmakedefine USE_MYMATH</div></pre></td></tr></table></figure></p><p></p>
<p></p><p>这样 CMake 会自动根据 CMakeLists 配置文件中的设置自动生成 config.h 文件。</p><p></p>
<p></p><h4 id="编译项目-1">编译项目</h4><p></p>
<p></p><p>现在编译一下这个项目，为了便于交互式的选择该变量的值，可以使用 <code>ccmake</code> 命令 <span class="margin-note-marker"><sup>2</sup></span> <span class="block margin-div-outer"><span class="block margin-div-inner"><span class="block margin-note"><span class="margin-note-marker">2</span>也可以使用 <code>cmake -i</code> 命令，该命令会提供一个会话式的交互式配置界面。 </span></span></span> ：</p><p></p>
<div class="figure"><br><img src="/images/cmake/ccmake.png" alt="CMake的交互式配置界面"><p class="caption">CMake的交互式配置界面</p><br></div><br><p>从中可以找到刚刚定义的 <code>USE_MYMATH</code> 选项，按键盘的方向键可以在不同的选项窗口间跳转，按下 <code>enter</code> 键可以修改该选项。修改完成后可以按下 <code>c</code> 选项完成配置，之后再按 <code>g</code> 键确认生成 Makefile 。ccmake 的其他操作可以参考窗口下方给出的指令提示。</p><br><p>我们可以试试分别将 <code>USE_MYMATH</code> 设为 <code>ON</code> 和 <code>OFF</code> 得到的结果：</p><br><h5 id="use_mymath-为-on">USE_MYMATH 为 ON</h5><br><p>运行结果：</p><br><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[ehome@xman Demo4]$ ./Demo</div><div class="line">Now we use our own MathFunctions library. </div><div class="line"> 7 ^ 3 = 343.000000</div><div class="line"> 10 ^ 5 = 100000.000000</div><div class="line"> 2 ^ 10 = 1024.000000</div></pre></td></tr></table></figure></p><br><p>此时 config.h 的内容为：</p><br><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define USE_MYMATH</div></pre></td></tr></table></figure></p><br><h5 id="use_mymath-为-off">USE_MYMATH 为 OFF</h5><br><p>运行结果：</p><br><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[ehome@xman Demo4]$ ./Demo</div><div class="line">Now we use the standard library. </div><div class="line"> 7 ^ 3 = 343.000000</div><div class="line"> 10 ^ 5 = 100000.000000</div><div class="line"> 2 ^ 10 = 1024.000000</div></pre></td></tr></table></figure></p><br><p>此时 config.h 的内容为：</p><br><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/<em> #undef USE_MYMATH </em>/</div></pre></td></tr></table></figure></p><br><h2 id="安装和测试">安装和测试</h2><br><p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p>本节对应的源代码所在目录：<a href="https://gitcafe.com/wzpan/cmake-demo/tree/master/Demo5" target="_blank" rel="external">Demo5</a>。</p><br></div></p><br><p>CMake 也可以指定安装规则，以及添加测试。这两个功能分别可以通过在产生 Makefile 后使用 <code>make install</code> 和 <code>make test</code> 来执行。在以前的 GNU Makefile 里，你可能需要为此编写 <code>install</code> 和 <code>test</code> 两个伪目标和相应的规则，但在 CMake 里，这样的工作同样只需要简单的调用几条命令。</p><br><h3 id="定制安装规则">定制安装规则</h3><br><p>首先先在 math/CMakeLists.txt 文件里添加下面两行：</p><br><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 指定 MathFunctions 库的安装路径</div><div class="line">install (TARGETS MathFunctions DESTINATION bin)</div><div class="line">install (FILES MathFunctions.h DESTINATION include)</div></pre></td></tr></table></figure></p><br><p>指明 MathFunctions 库的安装路径。之后同样修改根目录的 CMakeLists 文件，在末尾添加下面几行：</p><br><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 指定安装路径</div><div class="line">install (TARGETS Demo DESTINATION bin)</div><div class="line">install (FILES “${PROJECT_BINARY_DIR}/config.h”</div><div class="line">         DESTINATION include)</div></pre></td></tr></table></figure></p><br><p>通过上面的定制，生成的 Demo 文件和 MathFunctions 函数库 libMathFunctions.o 文件将会被复制到 <code>/usr/local/bin</code> 中，而 MathFunctions.h 和生成的 config.h 文件则会被复制到 <code>/usr/local/include</code> 中。我们可以验证一下<span class="margin-note-marker"><sup>3</sup></span> <span class="block margin-div-outer"><span class="block margin-div-inner"><span class="block margin-note"><span class="margin-note-marker">3</span>顺带一提的是，这里的 <code>/usr/local/</code> 是默认安装到的根目录，可以通过修改 <code>CMAKE_INSTALL_PREFIX</code> 变量的值来指定这些文件应该拷贝到哪个根目录。</span></span></span>：</p><br><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[ehome@xman Demo5]$ <span class="built_in">sudo</span> make install</div><div class="line">[ <span class="number">50</span>%] Built target MathFunctions</div><div class="line">[<span class="number">100</span>%] Built target Demo</div><div class="line">Install the project…</div><div class="line">– Install configuration: <span class="string">“”</span></div><div class="line">– Installing: /usr/local/bin/Demo</div><div class="line">– Installing: /usr/local/include/config.h</div><div class="line">– Installing: /usr/local/bin/libMathFunctions.a</div><div class="line">– Up-to-date: /usr/local/include/MathFunctions.h</div><div class="line">[ehome@xman Demo5]$ ls /usr/local/bin</div><div class="line">Demo  libMathFunctions.a</div><div class="line">[ehome@xman Demo5]$ ls /usr/local/include</div><div class="line">config.h  MathFunctions.h</div></pre></td></tr></table></figure></p><br><h3 id="为工程添加测试">为工程添加测试</h3><br><p>添加测试同样很简单。CMake 提供了一个称为 CTest 的测试工具。我们要做的只是在项目根目录的 CMakeLists 文件中调用一系列的 <code>add_test</code> 命令。</p><br><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"># 启用测试</div><div class="line">enable_testing()</div><div class="line"></div><div class="line"># 测试程序是否成功运行</div><div class="line">add_test (test_run Demo 5 2)</div><div class="line"></div><div class="line"># 测试帮助信息是否可以正常提示</div><div class="line">add_test (test_usage Demo)</div><div class="line">set_tests_properties (test_usage</div><div class="line">  PROPERTIES PASS_REGULAR_EXPRESSION “Usage: .<em> base exponent”)</em></div><div class="line"></div><div class="line"># 测试 5 的平方</div><div class="line">add_test (test_5_2 Demo 5 2)</div><div class="line"></div><div class="line">set_tests_properties (test_5_2</div><div class="line"> PROPERTIES PASS_REGULAR_EXPRESSION “is 25”)</div><div class="line"></div><div class="line"># 测试 10 的 5 次方</div><div class="line">add_test (test_10_5 Demo 10 5)</div><div class="line"></div><div class="line">set_tests_properties (test_10_5</div><div class="line"> PROPERTIES PASS_REGULAR_EXPRESSION “is 100000”)</div><div class="line"></div><div class="line"># 测试 2 的 10 次方</div><div class="line">add_test (test_2_10 Demo 2 10)</div><div class="line"></div><div class="line">set_tests_properties (test_2_10</div><div class="line"> PROPERTIES PASS_REGULAR_EXPRESSION “is 1024”)</div></pre></td></tr></table></figure></p><br><p>上面的代码包含了四个测试。第一个测试 <code>test_run</code> 用来测试程序是否成功运行并返回 0 值。剩下的三个测试分别用来测试 5 的 平方、10 的 5 次方、2 的 10 次方是否都能得到正确的结果。其中 <code>PASS_REGULAR_EXPRESSION</code> 用来测试输出是否包含后面跟着的字符串。</p><br><p>让我们看看测试的结果：</p><br><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[ehome@xman Demo5]$ make test</div><div class="line">Running tests…</div><div class="line">Test project /home/ehome/Documents/programming/C/power/Demo5</div><div class="line">    Start <span class="number">1</span>: test_run</div><div class="line"><span class="number">1</span>/<span class="number">4</span> Test <span class="comment">#1: test_run …………………….   Passed    0.00 sec</span></div><div class="line">    Start <span class="number">2</span>: test_5_2</div><div class="line"><span class="number">2</span>/<span class="number">4</span> Test <span class="comment">#2: test_5_2 …………………….   Passed    0.00 sec</span></div><div class="line">    Start <span class="number">3</span>: test_10_5</div><div class="line"><span class="number">3</span>/<span class="number">4</span> Test <span class="comment">#3: test_10_5 ……………………   Passed    0.00 sec</span></div><div class="line">    Start <span class="number">4</span>: test_2_10</div><div class="line"><span class="number">4</span>/<span class="number">4</span> Test <span class="comment">#4: test_2_10 ……………………   Passed    0.00 sec</span></div><div class="line"></div><div class="line"><span class="number">100</span>% tests passed, <span class="number">0</span> tests failed out of <span class="number">4</span></div><div class="line"></div><div class="line">Total Test time (real) =   <span class="number">0.01</span> sec</div></pre></td></tr></table></figure></p><br><p>如果要测试更多的输入数据，像上面那样一个个写测试用例未免太繁琐。这时可以通过编写宏来实现：</p><br><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义一个宏，用来简化测试工作</span></div><div class="line"><span class="keyword">macro</span> (do_test arg1 arg2 result)</div><div class="line">  <span class="keyword">add<em>test</em></span> (test<span class="envvar">${arg1}</span>_<span class="envvar">${arg2}</span> Demo <span class="envvar">${arg1}</span> <span class="envvar">${arg2}</span>)</div><div class="line">  <span class="keyword">set_tests<em>properties</em></span> (test<span class="envvar">${arg1}</span>_<span class="envvar">${arg2}</span></div><div class="line">    PROPERTIES PASS_REGULAR_EXPRESSION <span class="envvar">${result}</span>)</div><div class="line"><span class="keyword">endmacro</span> (do_test)</div><div class="line"> </div><div class="line"><span class="comment"># 使用该宏进行一系列的数据测试</span></div><div class="line">do_test (<span class="number">5</span> <span class="number">2</span> <span class="string">“is 25”</span>)</div><div class="line">do_test (<span class="number">10</span> <span class="number">5</span> <span class="string">“is 100000”</span>)</div><div class="line">do_test (<span class="number">2</span> <span class="number">10</span> <span class="string">“is 1024”</span>)</div></pre></td></tr></table></figure></p><br><p>关于 CTest 的更详细的用法可以通过 <code>man 1 ctest</code> 参考 CTest 的文档。</p><br><h2 id="支持-gdb">支持 gdb</h2><br><p>让 CMake 支持 gdb 的设置也很容易，只需要指定 <code>Debug</code> 模式下开启 <code>-g</code> 选项：</p><br><p><figure class="highlight CMake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE <span class="string">“Debug”</span>)</div><div class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">“$ENV{CXXFLAGS} -O0 -Wall -g -ggdb”</span>)</div><div class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_RELEASE <span class="string">“$ENV{CXXFLAGS} -O3 -Wall”</span>)</div></pre></td></tr></table></figure></p><br><p>之后可以直接对生成的程序使用 gdb 来调试。</p><br><h2 id="添加环境检查">添加环境检查</h2><br><p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p>本节对应的源代码所在目录：<a href="https://gitcafe.com/wzpan/cmake-demo/tree/master/Demo6" target="_blank" rel="external">Demo6</a>。</p><br></div></p><br><p>有时候可能要对系统环境做点检查，例如要使用一个平台相关的特性的时候。在这个例子中，我们检查系统是否自带 pow 函数。如果带有 pow 函数，就使用它；否则使用我们定义的 power 函数。</p><br><h4 id="添加-checkfunctionexists-宏">添加 CheckFunctionExists 宏</h4><br><p>首先在顶层 CMakeLists 文件中添加 CheckFunctionExists.cmake 宏，并调用 <code>check_function_exists</code> 命令测试链接器是否能够在链接阶段找到 <code>pow</code> 函数。</p><br><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 检查系统是否支持 pow 函数</div><div class="line">include (${CMAKE_ROOT}/Modules/CheckFunctionExists.cmake)</div><div class="line">check_function_exists (pow HAVE_POW)</div></pre></td></tr></table></figure></p><br><p>将上面这段代码放在 <code>configure_file</code> 命令前。</p><br><h4 id="预定义相关宏变量">预定义相关宏变量</h4><br><p>接下来修改 config.h.in 文件，预定义相关的宏变量。</p><br><p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// does the platform provide pow function?</span></div><div class="line"><span class="preprocessor">#cmakedefine HAVE_POW</span></div></pre></td></tr></table></figure></p><br><h4 id="在代码中使用宏和函数">在代码中使用宏和函数</h4><br><p>最后一步是修改 main.cc ，在代码中使用宏和函数：</p><br><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#ifdef HAVE_POW</div><div class="line">    printf(“Now we use the standard library. \n”);</div><div class="line">    double result = pow(base, exponent);</div><div class="line">#else</div><div class="line">    printf(“Now we use our own Math library. \n”);</div><div class="line">    double result = power(base, exponent);</div><div class="line">#endif</div></pre></td></tr></table></figure></p><br><h2 id="添加版本号">添加版本号</h2><br><p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p>本节对应的源代码所在目录：<a href="https://gitcafe.com/wzpan/cmake-demo/tree/master/Demo7" target="_blank" rel="external">Demo7</a>。</p><br></div></p><br><p>给项目添加和维护版本号是一个好习惯，这样有利于用户了解每个版本的维护情况，并及时了解当前所用的版本是否过时，或是否可能出现不兼容的情况。</p><br><p>首先修改顶层 CMakeLists 文件，在 <code>project</code> 命令之后加入如下两行：</p><br><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set (Demo_VERSION_MAJOR 1)</div><div class="line">set (Demo_VERSION_MINOR 0)</div></pre></td></tr></table></figure></p><br><p>分别指定当前的项目的主版本号和副版本号。</p><br><p>之后，为了在代码中获取版本信息，我们可以修改 config.h.in 文件，添加两个预定义变量：</p><br><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// the configured options and settings for Tutorial</div><div class="line">#define Demo_VERSION_MAJOR @Demo_VERSION_MAJOR@</div><div class="line">#define Demo_VERSION_MINOR @Demo_VERSION_MINOR@</div></pre></td></tr></table></figure></p><br><p>这样就可以直接在代码中打印版本信息了：</p><br><p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;math.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> “config.h”</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> “math/MathFunctions.h”</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> argv[])</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>){</div><div class="line">        <span class="comment">// print version info</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">“%s Version %d.%d\n”</span>,</div><div class="line">            argv[<span class="number">0</span>],</div><div class="line">            Demo_VERSION_MAJOR,</div><div class="line">            Demo_VERSION_MINOR);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">“Usage: %s base exponent \n”</span>, argv[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">double</span> base = atof(argv[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">int</span> exponent = atoi(argv[<span class="number">2</span>]);</div><div class="line">    </div><div class="line"><span class="preprocessor">#<span class="keyword">if</span> defined (HAVE_POW)</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">“Now we use the standard library. \n”</span>);</div><div class="line">    <span class="keyword">double</span> result = <span class="built_in">pow</span>(base, exponent);</div><div class="line"><span class="preprocessor">#<span class="keyword">else</span></span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">“Now we use our own Math library. \n”</span>);</div><div class="line">    <span class="keyword">double</span> result = power(base, exponent);</div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></div><div class="line">    </div><div class="line">    <span class="built_in">printf</span>(<span class="string">“%g ^ %d is %g\n”</span>, base, exponent, result);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure></p><br><h2 id="生成安装包">生成安装包</h2><br><p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p>本节对应的源代码所在目录：<a href="https://gitcafe.com/wzpan/cmake-demo/tree/master/Demo8" target="_blank" rel="external">Demo8</a>。</p><br></div></p><br><p>本节将学习如何配置生成各种平台上的安装包，包括二进制安装包和源码安装包。为了完成这个任务，我们需要用到 CPack ，它同样也是由 CMake 提供的一个工具，专门用于打包。</p><br><p>首先在顶层的 CMakeLists.txt 文件尾部添加下面几行：</p><br><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 构建一个 CPack 安装包</div><div class="line">include (InstallRequiredSystemLibraries)</div><div class="line">set (CPACK_RESOURCE_FILE_LICENSE</div><div class="line">  “${CMAKE_CURRENT_SOURCE_DIR}/License.txt”)</div><div class="line">set (CPACK_PACKAGE_VERSION_MAJOR “${Demo_VERSION_MAJOR}”)</div><div class="line">set (CPACK_PACKAGE_VERSION_MINOR “${Demo_VERSION_MINOR}”)</div><div class="line">include (CPack)</div></pre></td></tr></table></figure></p><br><p>上面的代码做了以下几个工作：</p><br><ol style="list-style-type: decimal"><br><li>导入 InstallRequiredSystemLibraries 模块，以便之后导入 CPack 模块；</li><br><li>设置一些 CPack 相关变量，包括版权信息和版本信息，其中版本信息用了上一节定义的版本号；</li><br><li>导入 CPack 模块。</li><br></ol><br><p>接下来的工作是像往常一样构建工程，并执行 <code>cpack</code> 命令。</p><br><ul><br><li>生成二进制安装包：</li><br></ul><br><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cpack -C CPackConfig.cmake</div></pre></td></tr></table></figure></p><br><ul><br><li>生成源码安装包</li><br></ul><br><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cpack -C CPackSourceConfig.cmake</div></pre></td></tr></table></figure></p><br><p>我们可以试一下。在生成项目后，执行 <code>cpack -C CPackConfig.cmake</code> 命令：</p><br><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[ehome@xman Demo8]$ cpack -C CPackSourceConfig.cmake</div><div class="line">CPack: Create package using STGZ</div><div class="line">CPack: Install projects</div><div class="line">CPack: - Run preinstall target <span class="keyword">for</span>: Demo8</div><div class="line">CPack: - Install project: Demo8</div><div class="line">CPack: Create package</div><div class="line">CPack: - package: /home/ehome/Documents/programming/C/power/Demo8/Demo8-<span class="number">1.0</span>.<span class="number">1</span>-Linux.sh generated.</div><div class="line">CPack: Create package using TGZ</div><div class="line">CPack: Install projects</div><div class="line">CPack: - Run preinstall target <span class="keyword">for</span>: Demo8</div><div class="line">CPack: - Install project: Demo8</div><div class="line">CPack: Create package</div><div class="line">CPack: - package: /home/ehome/Documents/programming/C/power/Demo8/Demo8-<span class="number">1.0</span>.<span class="number">1</span>-Linux.tar.gz generated.</div><div class="line">CPack: Create package using TZ</div><div class="line">CPack: Install projects</div><div class="line">CPack: - Run preinstall target <span class="keyword">for</span>: Demo8</div><div class="line">CPack: - Install project: Demo8</div><div class="line">CPack: Create package</div><div class="line">CPack: - package: /home/ehome/Documents/programming/C/power/Demo8/Demo8-<span class="number">1.0</span>.<span class="number">1</span>-Linux.tar.Z generated.</div></pre></td></tr></table></figure></p><br><p>此时会在该目录下创建 3 个不同格式的二进制包文件：</p><br><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[ehome@xman Demo8]$ ls Demo8-*</div><div class="line">Demo8-<span class="number">1.0</span>.<span class="number">1</span>-Linux.sh  Demo8-<span class="number">1.0</span>.<span class="number">1</span>-Linux.tar.gz  Demo8-<span class="number">1.0</span>.<span class="number">1</span>-Linux.tar.Z</div></pre></td></tr></table></figure></p><br><p>这 3 个二进制包文件所包含的内容是完全相同的。我们可以执行其中一个。此时会出现一个由 CPack 自动生成的交互式安装界面：</p><br><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">[ehome@xman Demo8]$ sh Demo8-<span class="number">1.0</span>.<span class="number">1</span>-Linux.sh </div><div class="line">Demo8 Installer Version: <span class="number">1.0</span>.<span class="number">1</span>, Copyright (c) Humanity</div><div class="line">This is a self-extracting archive.</div><div class="line">The archive will be extracted to: /home/ehome/Documents/programming/C/power/Demo8</div><div class="line"></div><div class="line">If you want to stop extracting, please press &lt;ctrl-C&gt;.</div><div class="line">The MIT License (MIT)</div><div class="line"></div><div class="line">Copyright (c) <span class="number">2013</span> Joseph Pan(<a href="http://hahack.com" target="_blank" rel="external">http://hahack.com</a>)</div><div class="line"></div><div class="line">Permission is hereby granted, free of charge, to any person obtaining a copy of</div><div class="line">this software and associated documentation files (the <span class="string">“Software”</span>), to deal <span class="keyword">in</span></div><div class="line">the Software without restriction, including without limitation the rights to</div><div class="line">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of</div><div class="line">the Software, and to permit persons to whom the Software is furnished to <span class="keyword">do</span> so,</div><div class="line">subject to the following conditions:</div><div class="line"></div><div class="line">The above copyright notice and this permission notice shall be included <span class="keyword">in</span> all</div><div class="line">copies or substantial portions of the Software.</div><div class="line"></div><div class="line">THE SOFTWARE IS PROVIDED <span class="string">“AS IS”</span>, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</div><div class="line">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS</div><div class="line">FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR</div><div class="line">COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER</div><div class="line">IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</div><div class="line">CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</div><div class="line"></div><div class="line"></div><div class="line">Do you accept the license? [yN]: </div><div class="line">y</div><div class="line">By default the Demo8 will be installed <span class="keyword">in</span>:</div><div class="line">  <span class="string">“/home/ehome/Documents/programming/C/power/Demo8/Demo8-1.0.1-Linux”</span></div><div class="line">Do you want to include the subdirectory Demo8-<span class="number">1.0</span>.<span class="number">1</span>-Linux?</div><div class="line">Saying no will install <span class="keyword">in</span>: <span class="string">“/home/ehome/Documents/programming/C/power/Demo8”</span> [Yn]: </div><div class="line">y</div><div class="line"></div><div class="line">Using target directory: /home/ehome/Documents/programming/C/power/Demo8/Demo8-<span class="number">1.0</span>.<span class="number">1</span>-Linux</div><div class="line">Extracting, please wait…</div><div class="line"></div><div class="line">Unpacking finished successfully</div></pre></td></tr></table></figure></p><br><p>完成后提示安装到了 Demo8-1.0.1-Linux 子目录中，我们可以进去执行该程序：</p><br><p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[ehome@xman Demo8]$ ./Demo8-<span class="number">1.0</span>.<span class="number">1</span>-Linux/bin/Demo <span class="number">5</span> <span class="number">2</span></div><div class="line">Now we use our own Math library. </div><div class="line"><span class="number">5</span> ^ <span class="number">2</span> is <span class="number">25</span></div></pre></td></tr></table></figure></p><br><p>关于 CPack 的更详细的用法可以通过 <code>man 1 cpack</code> 参考 CPack 的文档。</p><br><h2 id="将其他平台的项目迁移到-cmake">将其他平台的项目迁移到 CMake</h2><br><p>CMake 可以很轻松地构建出在适合各个平台执行的工程环境。而如果当前的工程环境不是 CMake ，而是基于某个特定的平台，是否可以迁移到 CMake 呢？答案是可能的。下面针对几个常用的平台，列出了它们对应的迁移方案。</p><br><h4 id="autotools">autotools</h4><br><ul><br><li><a href="https://projects.kde.org/projects/kde/kdesdk/kde-dev-scripts/repository/revisions/master/changes/cmake-utils/scripts/am2cmake" target="_blank" rel="external">am2cmake</a> 可以将 autotools 系的项目转换到 CMake，这个工具的一个成功案例是 KDE 。</li><br><li><a href="http://emanuelgreisen.dk/stuff/kdevelop_am2cmake.php.tgz" target="_blank" rel="external">Alternative Automake2CMake</a> 可以转换使用 automake 的 KDevelop 工程项目。</li><br><li><a href="http://www.cmake.org/Wiki/GccXmlAutoConfHints" target="_blank" rel="external">Converting autoconf tests</a></li><br></ul><br><h4 id="qmake">qmake</h4><br><ul><br><li><a href="http://www.cmake.org/Wiki/CMake:ConvertFromQmake" target="_blank" rel="external">qmake converter</a> 可以转换使用 QT 的 qmake 的工程。</li><br></ul><br><h4 id="visual-studio">Visual Studio</h4><br><ul><br><li><a href="http://vcproj2cmake.sf.net/" target="_blank" rel="external">vcproj2cmake.rb</a> 可以根据 Visual Studio 的工程文件（后缀名是 <code>.vcproj</code> 或 <code>.vcxproj</code>）生成 CMakeLists.txt 文件。</li><br><li><a href="http://nberserk.blogspot.com/2010/11/converting-vc-projectsvcproj-to.html" target="_blank" rel="external">vcproj2cmake.ps1</a> vcproj2cmake 的 PowerShell 版本。</li><br><li><a href="http://sourceforge.net/projects/folders4cmake/" target="_blank" rel="external">folders4cmake</a> 根据 Visual Studio 项目文件生成相应的 “source_group” 信息，这些信息可以很方便的在 CMake 脚本中使用。支持 Visual Studio 9/10 工程文件。</li><br></ul><br><h4 id="cmakelists.txt-自动推导">CMakeLists.txt 自动推导</h4><br><ul><br><li><a href="http://websvn.kde.org/trunk/KDE/kdesdk/cmake/scripts/" target="_blank" rel="external">gencmake</a> 根据现有文件推导 CMakeLists.txt 文件。</li><br><li><a href="http://www.vanvelzensoftware.com/postnuke/index.php?name=Downloads&amp;req=viewdownload&amp;cid=7" target="_blank" rel="external">CMakeListGenerator</a> 应用一套文件和目录分析创建出完整的 CMakeLists.txt 文件。仅支持 Win32 平台。</li><br></ul><br><h2 id="相关链接">相关链接</h2><br><ol style="list-style-type: decimal"><br><li><a href="http://www.cmake.org" target="_blank" rel="external">官方主页</a></li><br><li><a href="http://www.cmake.org/cmake/help/cmake2.4docs.html" target="_blank" rel="external">官方文档</a></li><br><li><a href="http://www.cmake.org/cmake/help/cmake_tutorial.html" target="_blank" rel="external">官方教程</a></li><br><li><a href="http://www.cmake.org/Wiki/CMake#Basic_CMakeLists.txt_from-scratch-generator" target="_blank" rel="external">Wiki</a></li><br><li><a href="http://www.cmake.org/Wiki/CMake_FAQ" target="_blank" rel="external">FAQ</a></li><br><li><a href="http://www.cmake.org/Bug" target="_blank" rel="external">bug tracker</a></li><br><li>邮件列表：<br><ul><br><li><a href="http://dir.gmane.org/gmane.comp.programming.tools.cmake.user" target="_blank" rel="external">cmake on Gmane</a></li><br><li><a href="http://www.mail-archive.com/cmake@cmake.org/" target="_blank" rel="external">http://www.mail-archive.com/cmake@cmake.org/</a></li><br><li><a href="http://www.mail-archive.com/cmake@cmake.org/" target="_blank" rel="external">http://marc.info/?l=cmake</a></li><br></ul></li><br><li>其他推荐文章<br><ul><br><li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-cmake/" target="_blank" rel="external">在 linux 下使用 CMake 构建应用程序</a></li><br><li><a href="http://www.cppblog.com/skyscribe/archive/2009/12/14/103208.aspx" target="_blank" rel="external">cmake的一些小经验</a></li><br><li><a href="http://www.kitware.com/media/archive/kitware_quarterly0107.pdf" target="_blank" rel="external">Packaging Software with CPack</a></li><br><li><a href="http://www.youtube.com/watch?v=CLvZTyji_Uw" target="_blank" rel="external">视频教程: 《Getting Started with CMake》</a></li><br></ul></li><br></ol><br><h2 id="类似工具">类似工具</h2><br><ul><br><li><a href="http://scons.org/" target="_blank" rel="external">SCons</a>：Eric S. Raymond、Timothee Besset、Zed A. Shaw 等大神力荐的项目架构工具。和 CMake 的最大区别是使用 Python 作为执行脚本。</li><br></ul><br><div class="footnotes"><br><hr><br><ol><br><li id="fn1"><p><a href="http://www.cmake.org/Wiki/CMake_Projects" target="_blank" rel="external">这个页面</a>详细罗列了使用 CMake 的知名项目<a href="#fnref1">↩</a></p></li><br></ol><br></div>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2015/07/03/kernel-pkg-intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/03/kernel-pkg-intro/" itemprop="url">
                  内核收包解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-03T00:00:00+08:00">
                2015-07-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>数据结构</li>
</ul>
<p>每个cpu都配有一个napi queue，用于放待处理的napi结构，napi结构里有对应的网卡、poll函数等重要信息（如果是非napi，每个cpu的这个napi queue里内置了2个东东：一个特殊的napi用于兼容napi处理，其含有一个特殊的poll函数；另外一个是input queue，用于存放收到的包）。</p>
<ul>
<li>硬中断处理</li>
</ul>
<p>当有包来时，收包的该网卡的对应硬中断（multiqueue时一个网卡会对应多个中断）在某个cpu上的处理：</p>
<p>   调用函数将该网卡的该中断对应的napi结构（napi时，每个网卡的每个中断都会有一个对应的napi结构；非napi时，则使用该cpu的napi queue里内置的napi结构，同时会将包收至该napi queue里的input queue，一次硬中断里最多放1000个，否则丢弃）放到该cpu的napi queue里</p>
<p>   然后触发软中断，剩下就是软中断的事了</p>
<ul>
<li>软中断处理</li>
</ul>
<p>该cpu上的软中断的处理：</p>
<p>逐个处理本cpu的napi queue里的各个napi结构体，其实就是调用该结构体里标识的网卡的poll函数进行收包并上送至协议栈（非napi时不需要poll了，直接从上述的input queue里读），处理时遵守三个原则：（第一个违反了则跳过该设备，后两个违反了则跳出本轮软中断，由下一轮软中断继续处理）</p>
<p>1）本轮软中断里该网卡的各个napi的总包数不超过64个</p>
<p>2）本轮软中断里所有收包数不能超过300个</p>
<p>3）本轮软中断里总耗时不能超过2ms</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2015/07/02/go-and-https/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/02/go-and-https/" itemprop="url">
                  Go and HTTPS
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-02T00:00:00+08:00">
                2015-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><b>一、HTTPS简介</b></p><br><p>日常生活中，我们上网用的最多的应用层协议就是HTTP协议了，直至目前全世界的网站中大多数依然只支持HTTP访问。</p><br><p>使用Go创建一个HTTP Server十分Easy，十几行代码就能搞定：</p><br><p><font face="Courier New">//gohttps/1-http/server.go<br><br>    package main</font></p><br><p><font face="Courier New">import (<br><br>    &nbsp;&nbsp;&nbsp; &quot;fmt&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;net/http&quot;<br><br>    )</font></p><br><p><font face="Courier New">func handler(w http.ResponseWriter, r <em>http.Request) {<br><br>    &nbsp;&nbsp;&nbsp; fmt.Fprintf(w,<br><br>    &nbsp;&nbsp;&nbsp;&nbsp; &quot;Hi, This is an example of http service in golang!&quot;)<br><br>    }</em></font></p><br><p><font face="Courier New">func main() {<br><br>    &nbsp;&nbsp;&nbsp; http.HandleFunc(&quot;/&quot;, handler)<br><br>    &nbsp;&nbsp;&nbsp; http.ListenAndServe(&quot;:8080&quot;, nil)<br><br>    }</font></p><br><p>执行这段代码：<br><br>    <font face="Courier New">$ go run server.go</font></p><br><p>打开浏览器，在地址栏输入&quot;<font face="Courier New"><a class="moz-txt-link-freetext" href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a></font>&quot;， 你会看到&ldquo; <font face="Courier New">Hi, This is an example of http service in golang!</font>&quot;输出到浏览器窗口。</p><br><p>不过HTTP毕竟是明文的，在这样一个不安全的世界里，随时存在着窃听（sniffer工具可以简单办到）、篡改甚至是冒充等风险，因此对于一些 对安全比较care的站点或服务，它们需要一种安全的HTTP协议，于是就有了HTTPS。</p><br><p>HTTPS只是我们在浏览器地址栏中看到协议标识，实际上它可以被理解为运行在SSL（Secure Sockets Layer）或TLS(Transport Layer Security)协议所构建的安全层之上的HTTP协议，协议的传输安全性以及内容完整性实际上是由SSL或TLS保证的。</p><br><p>关于HTTPS协议原理的详细说明，没有个百八十页是搞不定的，后续我会在各个实验之前将相关的原理先作一些说明，整体原理这里就不赘述了。有兴 趣的朋友可以参考以下资料：<br><br>    1、《<a href="http://book.douban.com/subject/10746113/" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://book.douban.com']);" target="_blank" rel="external">HTTP权威指南</a>》第十四章<br><br>    2、《<a href="http://book.douban.com/subject/25863515/" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://book.douban.com']);" target="_blank" rel="external">图解HTTP</a>》第七章<br><br>    3、阮一峰老师的两篇博文&ldquo;<a href="http://www.ruanyifeng.com/blog/2014/02 /ssl_tls.html" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://www.ruanyifeng.com']);" target="_blank" rel="external">SSL/TLS协议运行机制的概述</a>&quot;和&quot;<a href="http://http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://www.ruanyifeng.com']);" target="_blank" rel="external">图解SSL/TLS协议</a>&quot;。</p><br><p><b>二、实现一个最简单的HTTPS Web Server</b></p><br><p>Golang的标准库net/http提供了https server的基本实现，我们修改两行代码就能将上面的HTTP Server改为一个HTTPS Web Server:</p><br><p><font face="Courier New">// gohttps/2-https/server.go<br><br>    package main</font></p><br><p><font face="Courier New">import (<br><br>    &nbsp;&nbsp;&nbsp; &quot;fmt&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;net/http&quot;<br><br>    )</font></p><br><p><font face="Courier New">func handler(w http.ResponseWriter, r http.Request) {<br><br>    &nbsp;&nbsp;&nbsp; fmt.Fprintf(w,<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Hi, This is an example of https service in golang!&quot;)<br><br>    }</font></p><br><p><font face="Courier New">func main() {<br><br>    &nbsp;&nbsp;&nbsp; http.HandleFunc(&quot;/&quot;, handler)<br><br>    &nbsp;&nbsp;&nbsp; http.ListenAndServeTLS(&quot;:8081&quot;, &quot;server.crt&quot;,<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;server.key&quot;, nil)<br><br>    }</font></p><br><p><font face="Courier New">我们用http.ListenAndServeTLS替换掉了http.ListenAndServe，就将一个HTTP Server转换为HTTPS Web Server了。不过</font><font face="Courier New">ListenAndServeTLS 新增了两个参数certFile和keyFile，需要我们传入两个文件路径。到这里，我们不得不再学习一点HTTPS协议的原理了。不过为 了让这个例子能先Run起来，我们先执行下面命令，利用openssl生成server.crt和server.key文件，供程序使用，原 理后续详述：</font></p><br><p><font face="Courier New">$openssl genrsa -out server.key 2048</font></p><br><p><font face="Courier New">Generating RSA private key, 2048 bit long modulus<br><br>    &#8230;&#8230;&#8230;&#8230;&#8230;.+++<br><br>    &#8230;&#8230;&#8230;&#8230;&#8230;+++<br><br>    e is 65537 (0&#215;10001)</font></p><br><p><font face="Courier New">$openssl req -new -x509 -key server.key -out server.crt -days 365</font></p><br><p><font face="Courier New">You are about to be asked to enter information that will be incorporated<br><br>    into your certificate request.<br><br>    What you are about to enter is what is called a Distinguished Name or a DN.<br><br>    There are quite a few fields but you can leave some blank<br><br>    For some fields there will be a default value,<br><br>    If you enter &#39;.&#39;, the field will be left blank.<br><br>    &#8212;&#8211;<br><br>    Country Name (2 letter code) [AU]:<br><br>    State or Province Name (full name) [Some-State]:<br><br>    Locality Name (eg, city) []:<br><br>    Organization Name (eg, company) [Internet Widgits Pty Ltd]:<br><br>    Organizational Unit Name (eg, section) []:<br><br>    Common Name (e.g. server FQDN or YOUR name) []:<u><b>localhost</b></u><br><br>    Email Address []:</font></p><br><p><font face="Courier New">执行程序：go run server.go<br><br>    通过浏览器访问：<a href="https://localhost:8081，chrome浏览器会显示如下画面：" target="_blank" rel="external">https://localhost:8081，chrome浏览器会显示如下画面：</a></font></p><br><p><font face="Courier New"><img alt="" src="/wp-content/uploads/gohttps-chrome-unsecure-connection.png" style="height: 148px; width: 300px;"></font></p><br><p><font face="Courier New">忽略继续后，才能看到&quot;</font><font face="Courier New"><font face="Courier&lt;br /&gt;&lt;br /&gt;<br />
        New">Hi, This is an example of https service in golang!&quot;这个结果输出在窗口上。</font></font></p><br><p><font face="Courier New"><font face="Courier&lt;br /&gt;&lt;br /&gt;<br />
        New">也可以使用curl工具验证这个HTTPS server：</font></font></p><br><p><font face="Courier New"><font face="Courier&lt;br /&gt;&lt;br /&gt;<br />
        New">curl -k <a class="moz-txt-link-freetext" href="https://localhost:8081" target="_blank" rel="external">https://localhost:8081</a><br><br>    Hi, This is an example of http service in golang!</font></font></p><br><p><font face="Courier New"><font face="Courier&lt;br /&gt;&lt;br /&gt;<br />
        New">注意如果不加-k，curl会报如下错误：</font></font></p><br><p><font face="Courier New"><font face="Courier&lt;br /&gt;&lt;br /&gt;<br />
        New">$curl <a class="moz-txt-link-freetext" href="https://localhost:8081" target="_blank" rel="external">https://localhost:8081</a><br><br>    curl: (60) SSL certificate problem: Invalid certificate chain<br><br>    More details here: <a class="moz-txt-link-freetext" href="http://curl.haxx.se/docs/sslcerts.html" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://curl.haxx.se']);" target="_blank" rel="external">http://curl.haxx.se/docs/sslcerts.html</a></font></font></p><br><p><font face="Courier New"><font face="Courier&lt;br /&gt;&lt;br /&gt;<br />
        New">curl performs SSL certificate verification by default, using a &quot;bundle&quot;<br><br>    &nbsp;of Certificate Authority (CA) public keys (CA certs). If the default<br><br>    &nbsp;bundle file isn&#39;t adequate, you can specify an alternate file<br><br>    &nbsp;using the &#8211;cacert option.<br><br>    If this HTTPS server uses a certificate signed by a CA represented in<br><br>    &nbsp;the bundle, the certificate verification probably failed due to a<br><br>    &nbsp;problem with the certificate (it might be expired, or the name might<br><br>    &nbsp;not match the domain name in the URL).<br><br>    If you&#39;d like to turn off curl&#39;s verification of the certificate, use<br><br>    &nbsp;the -k (or &#8211;insecure) option.</font></font></p><br><p><font face="Courier New"><b>三、非对称加密和数字证书</b></font></p><br><p><font face="Courier New">前面说过，HTTPS的数据传输是加密的。实际使用中，HTTPS利用的是对称与非对称加密算法结合的方式。</font></p><br><p><font face="Courier New">对称加密，就是通信双方使用一个密钥，该密钥既用于数据加密（发送方），也用于数据解密（接收方）。<br><br>    非对称加密，使用两个密钥。发送方使用公钥（公开密钥）对数据进行加密，数据接收方使用私钥对数据进行解密。</font></p><br><p><font face="Courier New">实际操作中，单纯使用对称加密或单纯使用非对称加密都会存在一些问题，比如对称加密的密钥管理复杂；非对称加密的处理性能低、资源占用高等，因 此HTTPS结合了这两种方式。</font></p><br><p><font face="Courier New">HTTPS服务端在连接建立过程（ssl shaking握手协议）中，会将自身的公钥发送给客户端。客户端拿到公钥后，与服务端协商数据传输通道的对称加密密钥-对话密钥，随后的这个协商过程则 是基于非对称加密的（因为这时客户端已经拿到了公钥，而服务端有私钥）。一旦双方协商出对话密钥，则后续的数据通讯就会一直使用基于该对话密 钥的对称加密算法了。</font></p><br><p><font face="Courier New">上述过程有一个问题，那就是双方握手过程中，如何保障HTTPS服务端发送给客户端的公钥信息没有被篡改呢？实际应用中，HTTPS并非直接 传输公钥信息，而是使用携带公钥信息的数字证书来保证公钥的安全性和完整性。</font></p><br><p><font face="Courier New">数字证书，又称互联网上的&quot;身份证&quot;，用于唯一标识一个组织或一个服务器的，这就好比我们日常生活中使用的&quot;居民身份证&quot;，用于唯一标识一个 人。服务端将数字证书传输给客户端，客户端如何校验这个证书的真伪呢？我们知道</font>居民身份证是由国家统一制作和颁发的，个人向户 口所在地公安机关申请，国家颁发的身份证才具有法律 效力，任何地方这个身份证都是有效和可被接纳的。大悦城的会员卡也是一种身份标识，但你若用大悦城的会员卡去买机票，对不起， 不卖。航空公司可不认大悦城的会员卡，只认居民身份证。网站的证书也是同样的道理。一般来说数字证书从受信的权威证书授权机构 (Certification Authority，证书授权机构)买来的（免费的很少）。一般浏览器在出厂时就内置了诸多知名CA（如Verisign、GoDaddy、美国国防部、 CNNIC等）的数字证书校验方法，只要是这些CA机构颁发的证书，浏览器都能校验。对于CA未知的证书，浏览器则会报错（就像上面那个截图一 样）。主流浏览器都有证书管理功能，但鉴于这些功能比较高级，一般用户是不用去关心的。</p><br><p>初步原理先讲到这，我们再回到上面的例子。</p><br><p><b>四、服务端私钥与证书</b></p><br><p>接上面的例子，我们来说说服务端私钥与证书的生成。</p><br><p>go的<font face="Courier New">http.ListenAndServeTLS需要两个特别参数，一个是服务端的私钥 文件路径，另外一个是服务端的数字证书文件路径。在测试环境，我们没有必要花钱去购买什么证书，利用openssl工具，我们可以自己生成相 关私钥和自签发的数字证书。</font></p><br><p><font face="Courier New">openssl genrsa -out server.key 2048 用于生成服务端私钥文件server.key，后面的参数2048单位是bit，是私钥的长度。<br><br>    openssl生成的私钥中包含了公钥的信息，我们可以根据私钥生成公钥：</font></p><br><p><font face="Courier New">$openssl rsa -in server.key -out server.key.public</font></p><br><p><font face="Courier New">我们也可以根据私钥直接生成自签发的数字证书：</font></p><br><p><font face="Courier New">$openssl req -new -x509 -key server.key -out server.crt -days 365</font></p><br><p><font face="Courier New">server.key和server.crt将作为ListenAndServeTLS的两个输入参数。</font></p><br><p><font face="Courier New">我们编写一个Go程序来尝试与这个HTTPS server建立连接并通信。</font></p><br><p><font face="Courier New">//gohttps/4-https/client1.go<br><br>    package main</font></p><br><p><font face="Courier New">import (<br><br>    &nbsp;&nbsp;&nbsp; &quot;fmt&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;io/ioutil&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;net/http&quot;<br><br>    )</font></p><br><p><font face="Courier New">func main() {<br><br>    &nbsp;&nbsp;&nbsp; resp, err := http.Get(<a class="moz-txt-link-rfc2396E" href="https://localhost:8081" target="_blank" rel="external">&quot;https://localhost:8081&quot;</a>)<br><br>    &nbsp;&nbsp;&nbsp; if err != nil {<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmt.Println(&quot;error:&quot;, err)<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br><br>    &nbsp;&nbsp;&nbsp; }<br><br>    &nbsp;&nbsp;&nbsp; defer resp.Body.Close()<br><br>    &nbsp;&nbsp;&nbsp; body, err := ioutil.ReadAll(resp.Body)<br><br>    &nbsp;&nbsp;&nbsp; fmt.Println(string(body))<br><br>    }</font></p><br><p><font face="Courier New">运行这个client，我们得到如下错误：</font></p><br><p><font face="Courier New">$go run client1.go<br><br>    error: Get <a class="moz-txt-link-freetext" href="https://localhost:8081" target="_blank" rel="external">https://localhost:8081</a>: x509: certificate signed by unknown authority</font></p><br><p><font face="Courier New">此时服务端也给出了错误日志提示：<br><br>    2015/04/30 16:03:31 http: TLS handshake error from 127.0.0.1:62004: remote error: bad certificate</font></p><br><p><font face="Courier New">显然从客户端日志来看，go实现的Client端默认也是要对服务端传过来的数字证书进行校验的，但客户端提示：这个证书是由不知名CA签发 的！</font></p><br><p><font face="Courier New">我们可以修改一下client1.go的代码，让client端略过对证书的校验：</font></p><br><p><font face="Courier New"><font face="Courier New">//gohttps/4-https/client2.go</font><br><br>    package main</font></p><br><p><font face="Courier New">import (<br><br>    &nbsp;&nbsp;&nbsp; &quot;crypto/tls&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;fmt&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;io/ioutil&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;net/http&quot;<br><br>    )</font></p><br><p><font face="Courier New">func main() {<br><br>    &nbsp;&nbsp;&nbsp; tr := &amp;http.Transport{<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>TLSClientConfig:&nbsp;&nbsp;&nbsp; &amp;tls.Config{InsecureSkipVerify: true},</b><br><br>    &nbsp;&nbsp;&nbsp; }<br><br>    &nbsp;&nbsp;&nbsp; client := &amp;http.Client{Transport: tr}<br><br>    &nbsp;&nbsp;&nbsp; resp, err := client.Get(<a class="moz-txt-link-rfc2396E" href="https://localhost:8081" target="_blank" rel="external">&quot;https://localhost:8081&quot;</a>)</font></p><br><p><font face="Courier New">&nbsp;&nbsp;&nbsp; if err != nil {<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmt.Println(&quot;error:&quot;, err)<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br><br>    &nbsp;&nbsp;&nbsp; }<br><br>    &nbsp;&nbsp;&nbsp; defer resp.Body.Close()<br><br>    &nbsp;&nbsp;&nbsp; body, err := ioutil.ReadAll(resp.Body)<br><br>    &nbsp;&nbsp;&nbsp; fmt.Println(string(body))<br><br>    }</font></p><br><p><font face="Courier New">通过设置tls.Config的InsecureSkipVerify为true，client将不再对服务端的证书进行校验。执行后的结果 也证实了这一点：<br><br>    $go run client2.go<br><br>    Hi, This is an example of http service in golang!</font></p><br><p><font face="Courier New"><b>五、对服务端的证书进行校验</b></font></p><br><p><font face="Courier New">多数时候，我们需要对服务端的证书进行校验，而不是像上面client2.go那样忽略这个校验。我大脑中的这个产品需要服务端和客户端双向 校验，我们先来看看如何能让client端实现对Server端证书的校验呢？</font></p><br><p><font face="Courier New">client端校验证书的原理是什么呢？回想前面我们提到的浏览器内置了知名CA的相关信息，用来校验服务端发送过来的数字证书。那么浏览器 存储的到底是CA的什么信息呢？其实是CA自身的数字证书(包含CA自己的公钥)。而且为了保证CA证书的真实性，浏览器是在出厂时就内置了 这些CA证书的，而不是后期通过通信的方式获取的。CA证书就是用来校验由该CA颁发的数字证书的。</font></p><br><p><font face="Courier New">那么如何使用CA证书校验Server证书的呢？这就涉及到数字证书到底是什么了！</font></p><br><p><font face="Courier New">我们可以通过浏览器中的&quot;https/ssl证书管理&quot;来查看证书的内容，一般服务器证书都会包含诸如站点的名称和主机名、公钥、签发机构 (CA)名称和来自签发机构的签名等。我们重点关注这个</font><font face="Courier New"><font face="Courier New">来自签发机构的签名，因为对于证书的校验，就是使用客户端CA证书来验证服务端证书的签名是否这 个CA签的。</font></font></p><br><p><font face="Courier New"><font face="Courier New">通过签名验证我们可以来确认两件事：</font><br><br>    1、服务端传来的数字证书是由某个特定CA签发的（如果是self-signed，也无妨），数字证书中的签名类似于日常生活中的签名，首先 验证这个签名签的是Tony Bai，而不是Tom Bai， Tony Blair等。<br><br>    2、服务端传来的数字证书没有被中途篡改过。这类似于&quot;Tony Bai&quot;有无数种写法，这里验证必须是我自己的那种写法，而不是张三、李四写的&quot;Tony Bai&quot;。</font></p><br><p><font face="Courier New">一旦签名验证通过，我们因为信任这个CA，从而信任这个服务端证书。由此也可以看出，CA机构的最大资本就是其信用度。</font></p><br><p><font face="Courier New">CA在为客户签发数字证书时是这样在证书上签名的：</font></p><br><p><font face="Courier New">数字证书由两部分组成：<br><br>    1、C：证书相关信息（对象名称+过期时间+证书发布者+证书签名算法&#8230;.）<br><br>    2、S：证书的数字签名</font></p><br><p><font face="Courier New">其中的数字签名是通过公式S = F(Digest(C))得到的。</font></p><br><p><font face="Courier New">Digest为摘要函数，也就是 md5、sha-1或sha256等单向散列算法，用于将无限输入值转换为一个有限长度的&ldquo;浓缩&rdquo;输出值。比如我们常用md5值来验证下载的大文件是否完 整。大文件的内容就是一个无限输入。大文件被放在网站上用于下载时，网站会对大文件做一次md5计算，得出一个128bit的值作为大文件的 摘要一同放在网站上。用户在下载文件后，对下载后的文件再进行一次本地的md5计算，用得出的值与网站上的md5值进行比较，如果一致，则大 文件下载完好，否则下载过程大文件内容有损坏或源文件被篡改。</font></p><br><p><font face="Courier New">F为签名函数。CA自己的私钥是唯一标识CA签名的，因此CA用于生成数字证书的签名函数一定要以自己的私钥作为一个输入参数。在RSA加密 系统中，发送端的解密函数就是一个以私钥作 为参数的函数，因此常常被用作签名函数使用。签名算法是与证书一并发送给接收 端的，比如apple的一个服务的证书中关于签名算法的描述是&ldquo;带 RSA 加密的 SHA-256 ( 1.2.840.113549.1.1.11 )&rdquo;。因此CA用私钥解密函数作为F，对C的摘要进行运算得到了客户数字证书的签名，好比大学毕业证上的校长签名，所有毕业证都是校长签发的。</font></p><br><p><font face="Courier New">接收端接收服务端数字证书后，如何验证数字证书上携带的签名是这个CA的签名呢？接收端会运用下面算法对数字证书的签名进行校验：<br><br>    F&#39;(S) ?= Digest(C)</font></p><br><p><font face="Courier New">接收端进行两个计算，并将计算结果进行比对：<br><br>    1、首先通过Digest(C)，接收端计算出证书内容（除签名之外）的摘要。<br><br>    2、数字证书携带的签名是CA通过CA密钥加密摘要后的结果，因此接收端通过一个解密函数F&#39;对S进行&ldquo;解密&rdquo;。RSA系统中，接收端使用 CA公钥对S进行&ldquo;解密&rdquo;，这恰是CA用私钥对S进行&ldquo;加密&rdquo;的逆过程。</font></p><br><p><font face="Courier New">将上述两个运算的结果进行比较，如果一致，说明签名的确属于该CA，该证书有效，否则要么证书不是该CA的，要么就是中途被人篡改了。</font></p><br><p><font face="Courier New">但对于self-signed(自签发)证书来说，接收端并没有你这个self-CA的数字证书，也就是没有CA公钥，也就没有办法对数字证 书的签名进行验证。因此如果要编写一个可以对self-signed证书进行校验的接收端程序的话，首先我们要做的就是建立一个属于自己的 CA，用该CA签发我们的server端证书，并将该CA自身的数字证书随客户端一并发布。</font></p><br><p><font face="Courier New">这让我想起了在《<a href="http://tonybai.com/2015/03/14/selfhost-ngrok-service/" target="_blank" rel="external">搭建自己的ngrok服务</a>》一文中为ngrok服务端、客户端生成证书的那几个步骤，我们来重温并分析一下每一步都在做什么。</font></p><br><p><font face="Courier New">(1)openssl genrsa -out rootCA.key 2048<br><br>    (2)openssl req -x509 -new -nodes -key rootCA.key -subj &quot;/CN=<em>.tunnel.tonybai.com&quot; -days 5000 -out rootCA.pem</em></font></p><br><p><font face="Courier New">(3)openssl genrsa -out device.key 2048<br><br>    (4)openssl req -new -key device.key -subj &quot;/CN=.tunnel.tonybai.com&quot; -out device.csr<br><br>    (5)openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</font></p><br><p><font face="Courier New">(6)cp rootCA.pem assets/client/tls/ngrokroot.crt<br><br>    (7)cp device.crt assets/server/tls/snakeoil.crt<br><br>    (8)cp device.key assets/server/tls/snakeoil.key</font></p><br><p><font face="Courier New">自己搭建ngrok服务，客户端要验证服务端证书，我们需要自己做CA，因此步骤(1)和步骤(2)就是生成CA自己的相关信息。<br><br>    步骤(1) ，生成CA自己的私钥 rootCA.key<br><br>    步骤(2)，根据CA自己的私钥生成自签发的数字证书，该证书里包含CA自己的公钥。</font></p><br><p><font face="Courier New">步骤(3)~(5)是用来生成ngrok服务端的私钥和数字证书（由自CA签发）。<br><br>    步骤(3)，生成ngrok服务端私钥。<br><br>    步骤(4)，生成Certificate Sign Request，CSR，证书签名请求。<br><br>    步骤(5)，自CA用自己的CA私钥对服务端提交的csr进行签名处理，得到服务端的数字证书device.crt。</font></p><br><p><font face="Courier New">步骤(6)，将自CA的数字证书同客户端一并发布，用于客户端对服务端的数字证书进行校验。<br><br>    步骤(7)和步骤(8)，将服务端的数字证书和私钥同服务端一并发布。</font></p><br><p><font face="Courier New">接下来我们来验证一下客户端对服务端数字证书进行验证（gohttps/5-verify-server-cert）！</font></p><br><p><font face="Courier New">首先我们来建立我们自己的CA，需要生成一个CA私钥和一个CA的数字证书:</font></p><br><p><font face="Courier New">$openssl genrsa -out ca.key 2048<br><br>    Generating RSA private key, 2048 bit long modulus<br><br>    &#8230;&#8230;&#8230;.+++<br><br>    &#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;.+++<br><br>    e is 65537 (0&#215;10001)</font></p><br><p><font face="Courier New">$openssl req -x509 -new -nodes -key ca.key -subj &quot;/CN=tonybai.com&quot; -days 5000 -out ca.crt</font></p><br><p><font face="Courier New">接下来，生成server端的私钥，生成数字证书请求，并用我们的ca私钥签发server的数字证书：</font></p><br><p><font face="Courier New">openssl genrsa -out server.key 2048<br><br>    Generating RSA private key, 2048 bit long modulus<br><br>    &#8230;.+++<br><br>    &#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;.+++<br><br>    e is 65537 (0&#215;10001)</font></p><br><p><font face="Courier New">$openssl req -new -key server.key -subj &quot;/CN=localhost&quot; -out server.csr</font></p><br><p><font face="Courier New">$openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 5000<br><br>    Signature ok<br><br>    subject=/CN=localhost<br><br>    Getting CA Private Key</font></p><br><p><font face="Courier New">现在我们的工作目录下有如下一些私钥和证书文件：<br><br>    CA:<br><br>    &nbsp;&nbsp;&nbsp; 私钥文件 ca.key<br><br>    &nbsp;&nbsp;&nbsp; 数字证书 ca.crt</font></p><br><p><font face="Courier New">Server:<br><br>    &nbsp;&nbsp;&nbsp; 私钥文件 server.key<br><br>    &nbsp;&nbsp;&nbsp; 数字证书 server.crt</font></p><br><p><font face="Courier New">接下来，我们就来完成我们的程序。</font></p><br><p><font face="Courier New">Server端的程序几乎没有变化：</font></p><br><p><font face="Courier New">// gohttps/5-verify-server-cert/server.go<br><br>    package main</font></p><br><p><font face="Courier New">import (<br><br>    &nbsp;&nbsp;&nbsp; &quot;fmt&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;net/http&quot;<br><br>    )</font></p><br><p><font face="Courier New">func handler(w http.ResponseWriter, r <em>http.Request) {<br><br>    &nbsp;&nbsp;&nbsp; fmt.Fprintf(w,<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Hi, This is an example of http service in golang!&quot;)<br><br>    }</em></font></p><br><p><font face="Courier New">func main() {<br><br>    &nbsp;&nbsp;&nbsp; http.HandleFunc(&quot;/&quot;, handler)<br><br>    &nbsp;&nbsp;&nbsp; http.ListenAndServeTLS(&quot;:8081&quot;,<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;server.crt&quot;, &quot;server.key&quot;, nil)<br><br>    }</font></p><br><p><font face="Courier New">client端程序变化较大，由于client端需要验证server端的数字证书，因此client端需要预先加载ca.crt，以用于服务端数字证书的校验：</font></p><br><p><font face="Courier New"><font face="Courier New">// gohttps/5-verify-server-cert/client.go</font><br><br>    package main</font></p><br><p><font face="Courier New">import (<br><br>    &nbsp;&nbsp;&nbsp; &quot;crypto/tls&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;crypto/x509&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;fmt&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;io/ioutil&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;net/http&quot;<br><br>    )</font></p><br><p><font face="Courier New">func main() {<br><br>    &nbsp;&nbsp;&nbsp; pool := x509.NewCertPool()<br><br>    &nbsp;&nbsp;&nbsp; caCertPath := &quot;ca.crt&quot;</font></p><br><p><font face="Courier New">&nbsp;&nbsp;&nbsp; caCrt, err := ioutil.ReadFile(caCertPath)<br><br>    &nbsp;&nbsp;&nbsp; if err != nil {<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmt.Println(&quot;ReadFile err:&quot;, err)<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br><br>    &nbsp;&nbsp;&nbsp; }<br><br>    &nbsp;&nbsp;&nbsp; pool.AppendCertsFromPEM(caCrt)</font></p><br><p><font face="Courier New">&nbsp;&nbsp;&nbsp; tr := &amp;http.Transport{<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TLSClientConfig: &amp;tls.Config{RootCAs: pool},<br><br>    &nbsp;&nbsp;&nbsp; }<br><br>    &nbsp;&nbsp;&nbsp; client := &amp;http.Client{Transport: tr}<br><br>    &nbsp;&nbsp;&nbsp; resp, err := client.Get(&quot;<a href="https://localhost:8081&amp;quot" target="_blank" rel="external">https://localhost:8081&amp;quot</a>;)<br><br>    &nbsp;&nbsp;&nbsp; if err != nil {<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmt.Println(&quot;Get error:&quot;, err)<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br><br>    &nbsp;&nbsp;&nbsp; }<br><br>    &nbsp;&nbsp;&nbsp; defer resp.Body.Close()<br><br>    &nbsp;&nbsp;&nbsp; body, err := ioutil.ReadAll(resp.Body)<br><br>    &nbsp;&nbsp;&nbsp; fmt.Println(string(body))<br><br>    }</font></p><br><p><font face="Courier New">运行server和client:</font></p><br><p><font face="Courier New">$go run server.go</font></p><br><p><font face="Courier New">go run client.go<br><br>    Hi, This is an example of http service in golang!</font></p><br><p><font face="Courier New"><font face="Courier New"><b>六、对客户端的证书进行校验(双向证书校验）</b></font></font></p><br><p><font face="Courier New">服务端可以要求对客户端的证书进行校验，以更严格识别客户端的身份，限制客户端的访问。</font></p><br><p><font face="Courier New">要对客户端数字证书进行校验，首先客户端需要先有自己的证书。我们以上面的例子为基础，生成客户端的私钥与证书。</font></p><br><p><font face="Courier New">$openssl genrsa -out client.key 2048<br><br>    Generating RSA private key, 2048 bit long modulus<br><br>    &#8230;&#8230;&#8230;&#8230;&#8230;&#8230;..+++<br><br>    &#8230;&#8230;&#8230;&#8230;&#8230;&#8230;..+++<br><br>    e is 65537 (0&#215;10001)<br><br>    $openssl req -new -key client.key -subj &quot;/CN=tonybai_cn&quot; -out client.csr<br><br>    $openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out client.crt -days 5000<br><br>    Signature ok<br><br>    subject=/CN=tonybai_cn<br><br>    Getting CA Private Key</font></p><br><p><font face="Courier New">接下来我们来改造我们的程序，首先是server端。</font></p><br><p><font face="Courier New">首先server端需要要求校验client端的数字证书，并且加载用于校验数字证书的ca.crt，因此我们需要对server进行更加灵活的控制：</font></p><br><p><font face="Courier New">// gohttps/6-dual-verify-certs/server.go<br><br>    package main</font></p><br><p><font face="Courier New">import (<br><br>    &nbsp;&nbsp;&nbsp; &quot;crypto/tls&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;crypto/x509&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;fmt&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;io/ioutil&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;net/http&quot;<br><br>    )</font></p><br><p><font face="Courier New">type myhandler struct {<br><br>    }</font></p><br><p><font face="Courier New">func (h myhandler) ServeHTTP(w http.ResponseWriter,<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r *http.Request) {<br><br>    &nbsp;&nbsp;&nbsp; fmt.Fprintf(w,<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Hi, This is an example of http service in golang!\n&quot;)<br><br>    }</font></p><br><p><font face="Courier New">func main() {<br><br>    &nbsp;&nbsp;&nbsp; pool := x509.NewCertPool()<br><br>    &nbsp;&nbsp;&nbsp; caCertPath := &quot;ca.crt&quot;</font></p><br><p><font face="Courier New">&nbsp;&nbsp;&nbsp; caCrt, err := ioutil.ReadFile(caCertPath)<br><br>    &nbsp;&nbsp;&nbsp; if err != nil {<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmt.Println(&quot;ReadFile err:&quot;, err)<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br><br>    &nbsp;&nbsp;&nbsp; }<br><br>    &nbsp;&nbsp;&nbsp; pool.AppendCertsFromPEM(caCrt)</font></p><br><p><font face="Courier New">&nbsp;&nbsp;&nbsp; s := &amp;http.Server{<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Addr:&nbsp;&nbsp;&nbsp; &quot;:8081&quot;,<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Handler: &amp;myhandler{},<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TLSConfig: &amp;tls.Config{<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClientCAs:&nbsp; pool,<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClientAuth: <b>tls.RequireAndVerifyClientCert</b>,<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br><br>    &nbsp;&nbsp;&nbsp; }</font></p><br><p><font face="Courier New">&nbsp;&nbsp;&nbsp; err = s.ListenAndServeTLS(&quot;server.crt&quot;, &quot;server.key&quot;)<br><br>    &nbsp;&nbsp;&nbsp; if err != nil {<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmt.Println(&quot;ListenAndServeTLS err:&quot;, err)<br><br>    &nbsp;&nbsp;&nbsp; }<br><br>    }</font></p><br><p><font face="Courier New">可以看出代码通过将tls.Config.ClientAuth赋值为tls.RequireAndVerifyClientCert来实现Server强制校验client端证书。ClientCAs是用来校验客户端证书的ca certificate。</font></p><br><p><font face="Courier New">Client端变化也很大，需要加载client.key和client.crt用于server端连接时的证书校验：</font></p><br><p><font face="Courier New">// </font><font face="Courier New"><font face="Courier New">gohttps/6-dual-verify-certs/client.go</font></font></p><br><p><font face="Courier New">package main<br><br>    import (<br><br>    &nbsp;&nbsp;&nbsp; &quot;crypto/tls&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;crypto/x509&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;fmt&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;io/ioutil&quot;<br><br>    &nbsp;&nbsp;&nbsp; &quot;net/http&quot;<br><br>    )</font></p><br><p><font face="Courier New">func main() {<br><br>    &nbsp;&nbsp;&nbsp; pool := x509.NewCertPool()<br><br>    &nbsp;&nbsp;&nbsp; caCertPath := &quot;ca.crt&quot;</font></p><br><p><font face="Courier New">&nbsp;&nbsp;&nbsp; caCrt, err := ioutil.ReadFile(caCertPath)<br><br>    &nbsp;&nbsp;&nbsp; if err != nil {<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmt.Println(&quot;ReadFile err:&quot;, err)<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br><br>    &nbsp;&nbsp;&nbsp; }<br><br>    &nbsp;&nbsp;&nbsp; pool.AppendCertsFromPEM(caCrt)</font></p><br><p><font face="Courier New">&nbsp;&nbsp;&nbsp; cliCrt, err := tls.LoadX509KeyPair(&quot;client.crt&quot;, &quot;client.key&quot;)<br><br>    &nbsp;&nbsp;&nbsp; if err != nil {<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmt.Println(&quot;Loadx509keypair err:&quot;, err)<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br><br>    &nbsp;&nbsp;&nbsp; }</font></p><br><p><font face="Courier New">&nbsp;&nbsp;&nbsp; tr := &amp;http.Transport{<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TLSClientConfig: &amp;tls.Config{<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RootCAs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pool,<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Certificates: []tls.Certificate{cliCrt},<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br><br>    &nbsp;&nbsp;&nbsp; }<br><br>    &nbsp;&nbsp;&nbsp; client := &amp;http.Client{Transport: tr}<br><br>    &nbsp;&nbsp;&nbsp; resp, err := client.Get(&quot;<a href="https://localhost:8081&amp;quot" target="_blank" rel="external">https://localhost:8081&amp;quot</a>;)<br><br>    &nbsp;&nbsp;&nbsp; if err != nil {<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fmt.Println(&quot;Get error:&quot;, err)<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br><br>    &nbsp;&nbsp;&nbsp; }<br><br>    &nbsp;&nbsp;&nbsp; defer resp.Body.Close()<br><br>    &nbsp;&nbsp;&nbsp; body, err := ioutil.ReadAll(resp.Body)<br><br>    &nbsp;&nbsp;&nbsp; fmt.Println(string(body))<br><br>    }</font></p><br><p><font face="Courier New">好了，让我们来试着运行一下这两个程序，结果如下：</font></p><br><p><font face="Courier New">$go run server.go<br><br>    2015/04/30 22:13:33 http: TLS handshake error from 127.0.0.1:53542:<br><br>    tls: client&#39;s certificate&#39;s extended key usage doesn&#39;t permit it to be<br><br>    used for client authentication</font></p><br><p><font face="Courier New">$go run client.go<br><br>    Get error: Get <a href="https://localhost:8081" target="_blank" rel="external">https://localhost:8081</a>: remote error: handshake failure</font></p><br><p><font face="Courier New">失败了！从server端的错误日志来看，似乎是client端的client.crt文件不满足某些条件。</font></p><br><p><font face="Courier New">根据server端的错误日志，搜索了Golang的源码，发现错误出自crypto/tls/handshake<em>server.go。</em></font></p><br><p><font face="Courier New">k := false<br><br>    for , ku := range certs[0].ExtKeyUsage {<br><br>    &nbsp;&nbsp;&nbsp; if ku == x509.ExtKeyUsageClientAuth {<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ok = true<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break<br><br>    &nbsp;&nbsp;&nbsp; }<br><br>    }<br><br>    if !ok {<br><br>    &nbsp;&nbsp;&nbsp; c.sendAlert(alertHandshakeFailure)<br><br>    &nbsp;&nbsp;&nbsp; return nil, errors.New(&quot;tls: client&#39;s certificate&#39;s extended key usage doesn&#39;t permit it to be used for client authentication&quot;)<br><br>    }</font></p><br><p><font face="Courier New">大致判断是证书中的ExtKeyUsage信息应该包含clientAuth。翻看openssl的相关资料，了解到自CA签名的数字证书中包含的都是一些basic的信息，根本没有ExtKeyUsage的信息。我们可以用命令来查看一下当前client.crt的内容：</font></p><br><p><font face="Courier New">$ openssl x509 -text -in client.crt -noout<br><br>    Certificate:<br><br>    &nbsp;&nbsp;&nbsp; Data:<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Version: 1 (0&#215;0)<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Serial Number:<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d6:e3:f6:fa:ae:65:ed:df<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Signature Algorithm: sha1WithRSAEncryption<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Issuer: CN=tonybai.com<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Validity<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Not Before: Apr 30 14:11:34 2015 GMT<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Not After : Jan&nbsp; 6 14:11:34 2029 GMT<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Subject: CN=tonybai_cn<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Subject Public Key Info:<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Public Key Algorithm: rsaEncryption<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RSA Public Key: (2048 bit)<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Modulus (2048 bit):<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00:e4:12:22:50:75:ae:b2:8a:9e:56:d5:f3:7d:31:<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7b:aa:75:5d:3f:90:05:4e:ff:ed:9a:0a:2a:75:15:<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#8230; &#8230;<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exponent: 65537 (0&#215;10001)<br><br>    &nbsp;&nbsp;&nbsp; Signature Algorithm: sha1WithRSAEncryption<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 76:3b:31:3e:9d:b0:66:ad:c0:03:d4:19:c6:f2:1a:52:91:d6:<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13:31:3a:c5:d5:58:ea:42:1d:b7:33:b8:43:a8:a8:28:91:ac:<br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8230; &#8230;</font></p><br><div class="page" title="Page 87"><br><div class="section"><br><div class="layoutArea"><br><div class="column"><br><p><span style="color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 21px;"><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; line-height: 24px; text-indent: 28px;">而偏偏golang的tls又要校验ExtKeyUsage，如此我们需要重新生成client.crt，并在生成时指定extKeyUsage。经过摸索，可以用如下方法重新生成client.crt：</span></span></p><br><p><span style="color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 21px;"><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; line-height: 24px; text-indent: 28px;">1、创建文件client.ext<br><br>                    内容：<br><br>                    <font face="Courier New">extendedKeyUsage=clientAuth</font></span></span></p><br><p><span style="color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 21px;"><span style="color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; line-height: 24px; text-indent: 28px;">2、重建client.crt</span></span></p><br><p><font face="Courier New">$openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial <b>-extfile client.ext</b> -out client.crt -days 5000<br><br>                    Signature ok<br><br>                    subject=/CN=tonybai_cn<br><br>                    Getting CA Private Key</font></p><br><p>再通过命令查看一下新client.crt：</p><br><p>看到输出的文本中多了这么几行：<br><br>                    <font face="DIN Alternate"><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X509v3 extensions:<br><br>                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X509v3 Extended Key Usage:<br><br>                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TLS Web Client Authentication</font></font></p><br><p>这说明client.crt的extended key usage已经添加成功了。我们再来执行一下server和client：</p><br><p><font face="Courier New">$ go run client.go<br><br>                    Hi, This is an example of http service in golang!</font></p><br><p>client端证书验证成功，也就是说双向证书验证均ok了。</p><br><p><b>七、小结</b></p><br><p>通过上面的例子可以看出，使用golang开发https相关程序十分便利，Golang标准库已经实现了TLS 1.2版本协议。上述所有example代码均放在我的github上的<a href="https://github.com/bigwhite/experiments/tree/master/gohttps" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://github.com']);" target="_blank" rel="external">experiments/gohttps</a>中。</p></div></div></div></div>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2015/07/02/static-http-file-server-in-go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/02/static-http-file-server-in-go/" itemprop="url">
                  Static http file server in Go
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-02T00:00:00+08:00">
                2015-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
             <p><a href="http://golang.org/" target="_blank" rel="external">Go</a> is a great language for building network based applications. It comes<br>with some excellent tools for creating web-apps out of the box.</p>

<p>I often want to create a “simple http server” to serve up the current<br>directory, usually I reach for <code>python -m SimpleHTTPServer</code>, but in the<br>spirit of re-inventing the wheel I decided to see how Go could handle<br>this task.</p>

<p>It turned out to be remarkably simple. Go comes with a static file server<br>as part of the <code>net/http</code> package, in this example I’ve added a couple of flags that<br>allow specifying the port and the root filesystem path for the process.</p>

<div class="highlight"><pre><code class="language-go" data-lang="go"><span class="c1">// httpserver.go</span><br><span class="kn">package</span> <span class="nx">main</span><br><br><span class="kn">import</span> <span class="p">(</span><br>    <span class="s">&quot;flag&quot;</span><br>    <span class="s">&quot;net/http&quot;</span><br><span class="p">)</span><br><br><span class="kd">var</span> <span class="nx">port</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">String</span><span class="p">(</span><span class="s">&quot;port&quot;</span><span class="p">,</span> <span class="s">&quot;8080&quot;</span><span class="p">,</span> <span class="s">&quot;Define what TCP port to bind to&quot;</span><span class="p">)</span><br><span class="kd">var</span> <span class="nx">root</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">String</span><span class="p">(</span><span class="s">&quot;root&quot;</span><span class="p">,</span> <span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="s">&quot;Define the root filesystem path&quot;</span><span class="p">)</span><br><br><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span><br>    <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span><br>    <span class="nb">panic</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&quot;:&quot;</span><span class="o">+<em></em></span><span class="nx">port</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">Dir</span><span class="p">(</span><span class="o"></span><span class="nx">root</span><span class="p">))))</span><br><span class="p">}</span></code></pre></div>

<p>The actual meat of the program is the second line inside the main<br>function. <code>http.ListenAndServe</code> accepts an address to listen on as the first argument,<br>and an object which implements the <code>http.Handler</code> interface as the second,<br>in this case <code>http.FileServer</code>. If<br><code>ListenAndServe</code> returns an error (most likely because another process<br>is using the desired port) then the process will <code>panic</code> and exit.</p>

<p>If you’ve got Go installed then this can be run directly.</p>

<pre><code>$ go run httpserver.go
</code></pre>

<p>Or you can compile it to a standalone binary.</p>

<pre><code>$ go build httpserver.go
$ ./httpserver
</code></pre>

<p>The file server implementation that Go provides even handles serving <code>index.html</code><br>from a directory if no file is specified, and provides a directory<br>listing if there is no <code>index.html</code> present.</p>

<p>For more details check out <a href="http://golang.org/src/pkg/net/http/fs.go?s=12008:12048#L401" target="_blank" rel="external">Go’s implementation of <code>http.FileServer</code></a>.</p>

<p>The code shown in this article is available <a href="https://github.com/chrismytton/httpserver" target="_blank" rel="external">on<br>GitHub</a>.</p>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2015/06/30/postgresql-in-action/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/30/postgresql-in-action/" itemprop="url">
                  postgresql in action
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-30T00:00:00+08:00">
                2015-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自从MySQL被Oracle收购以后，<a href="http://www.postgresql.org/" target="_blank" rel="external">PostgreSQL</a>逐渐成为开源关系型数据库的首选。</p><br><p>本文介绍PostgreSQL的安装和基本用法，供初次使用者上手。以下内容基于Debian操作系统，其他操作系统实在没有精力兼顾，但是大部分内容应该普遍适用。</p>

<p><img src="http://image.beekka.com/blog/201312/bg2013122201.png" alt="postgresql" title=""></p>

<p><strong>一、安装</strong></p>

<p>首先，安装PostgreSQL客户端。</p>

<blockquote><br>  <p>sudo apt-get install postgresql-client</p><br></blockquote>

<p>然后，安装PostgreSQL服务器。</p>

<blockquote><br>  <p>sudo apt-get install postgresql</p><br></blockquote>

<p>正常情况下，安装完成后，PostgreSQL服务器会自动在本机的5432端口开启。</p>

<p>如果还想安装图形管理界面，可以运行下面命令，但是本文不涉及这方面内容。</p>

<blockquote><br>  <p>sudo apt-get install pgadmin3</p><br></blockquote>

<p><strong>二、添加新用户和新数据库</strong></p>

<p>初次安装后，默认生成一个名为postgres的数据库和一个名为postgres的数据库用户。这里需要注意的是，同时还生成了一个名为postgres的Linux系统用户。</p>

<p>下面，我们使用postgres用户，来生成其他用户和新数据库。好几种方法可以达到这个目的，这里介绍两种。</p>

<p><strong>第一种方法，使用PostgreSQL控制台。</strong></p>

<p>首先，新建一个Linux新用户，可以取你想要的名字，这里为dbuser。</p>

<blockquote><br>  <p>sudo adduser dbuser</p><br></blockquote>

<p>然后，切换到postgres用户。</p>

<blockquote><br>  <p>sudo su - postgres</p><br></blockquote>

<p>下一步，使用psql命令登录PostgreSQL控制台。</p>

<blockquote><br>  <p>psql</p><br></blockquote>

<p>这时相当于系统用户postgres以同名数据库用户的身份，登录数据库，这是不用输入密码的。如果一切正常，系统提示符会变为”postgres=#”，表示这时已经进入了数据库控制台。以下的命令都在控制台内完成。</p>

<p>第一件事是使用\password命令，为postgres用户设置一个密码。</p>

<blockquote><br>  <p>\password postgres</p><br></blockquote>

<p>第二件事是创建数据库用户dbuser（刚才创建的是Linux系统用户），并设置密码。</p>

<blockquote><br>  <p>CREATE USER dbuser WITH PASSWORD ‘password’;</p><br></blockquote>

<p>第三件事是创建用户数据库，这里为exampledb，并指定所有者为dbuser。</p>

<blockquote><br>  <p>CREATE DATABASE exampledb OWNER dbuser;</p><br></blockquote>

<p>第四件事是将exampledb数据库的所有权限都赋予dbuser，否则dbuser只能登录控制台，没有任何数据库操作权限。</p>

<blockquote><br>  <p>GRANT ALL PRIVILEGES ON DATABASE exampledb to dbuser;</p><br></blockquote>

<p>最后，使用\q命令退出控制台（也可以直接按ctrl+D）。</p>

<blockquote><br>  <p>\q</p><br></blockquote>

<p><strong>第二种方法，使用shell命令行。</strong></p>

<p>添加新用户和新数据库，除了在PostgreSQL控制台内，还可以在shell命令行下完成。这是因为PostgreSQL提供了命令行程序createuser和createdb。还是以新建用户dbuser和数据库exampledb为例。</p>

<p>首先，创建数据库用户dbuser，并指定其为超级用户。</p>

<blockquote><br>  <p>sudo -u postgres createuser –superuser dbuser</p><br></blockquote>

<p>然后，登录数据库控制台，设置dbuser用户的密码，完成后退出控制台。</p>

<blockquote><br>  <p>sudo -u postgres psql</p><br><br><p>\password dbuser</p><br><br><p>\q</p><br></blockquote>

<p>接着，在shell命令行下，创建数据库exampledb，并指定所有者为dbuser。</p>

<blockquote><br>  <p>sudo -u postgres createdb -O dbuser exampledb</p><br></blockquote>

<p><strong>三、登录数据库</strong></p>

<p>添加新用户和新数据库以后，就要以新用户的名义登录数据库，这时使用的是psql命令。</p>

<blockquote><br>  <p>psql -U dbuser -d exampledb -h 127.0.0.1 -p 5432</p><br></blockquote>

<p>上面命令的参数含义如下：-U指定用户，-d指定数据库，-h指定服务器，-p指定端口。</p>

<p>输入上面命令以后，系统会提示输入dbuser用户的密码。输入正确，就可以登录控制台了。</p>

<p>psql命令存在简写形式。如果当前Linux系统用户，同时也是PostgreSQL用户，则可以省略用户名（-U参数的部分）。举例来说，我的Linux系统用户名为ruanyf，且PostgreSQL数据库存在同名用户，则我以ruanyf身份登录Linux系统后，可以直接使用下面的命令登录数据库，且不需要密码。</p>

<blockquote><br>  <p>psql exampledb</p><br></blockquote>

<p>此时，如果PostgreSQL内部还存在与当前系统用户同名的数据库，则连数据库名都可以省略。比如，假定存在一个叫做ruanyf的数据库，则直接键入psql就可以登录该数据库。</p>

<blockquote><br>  <p>psql</p><br></blockquote>

<p>另外，如果要恢复外部数据，可以使用下面的命令。</p>

<blockquote><br>  <p>psql exampledb &lt; exampledb.sql</p><br></blockquote>

<p><strong>四、控制台命令</strong></p>

<p>除了前面已经用到的\password命令（设置密码）和\q命令（退出）以外，控制台还提供一系列其他命令。</p>

<blockquote><br>  <ul><br><li>\h：查看SQL命令的解释，比如\h select。  </li><br><li>\?：查看psql命令列表。  </li><br><li>\l：列出所有数据库。  </li><br><li>\c [database_name]：连接其他数据库。  </li><br><li>\d：列出当前数据库的所有表格。  </li><br><li>\d [table_name]：列出某一张表格的结构。  </li><br><li>\du：列出所有用户。  </li><br><li>\e：打开文本编辑器。  </li><br><li>\conninfo：列出当前数据库和连接的信息。</li><br></ul><br></blockquote>

<p><strong>五、数据库操作</strong></p>

<p>基本的数据库操作，就是使用一般的SQL语言。</p>

<blockquote><br>  <p># 创建新表 <br><br>CREATE TABLE user_tbl(name VARCHAR(20), signup_date DATE);</p><br><br><p># 插入数据 <br><br>INSERT INTO user_tbl(name, signup_date) VALUES(‘张三’, ‘2013-12-22’);</p><br><br><p># 选择记录 <br><br>SELECT * FROM user_tbl;</p><br><br><p># 更新数据 <br><br>UPDATE user_tbl set name = ‘李四’ WHERE name = ‘张三’;</p><br><br><p># 删除记录 <br><br>DELETE FROM user_tbl WHERE name = ‘李四’ ;</p><br><br><p># 添加栏位 <br><br>ALTER TABLE user_tbl ADD email VARCHAR(40);</p><br><br><p># 更新结构 <br><br>ALTER TABLE user_tbl ALTER COLUMN signup_date SET NOT NULL;</p><br><br><p># 更名栏位 <br><br>ALTER TABLE user_tbl RENAME COLUMN signup_date TO  signup;</p><br><br><p># 删除栏位 <br><br>ALTER TABLE user_tbl DROP COLUMN email;</p><br><br><p># 表格更名 <br><br>ALTER TABLE user_tbl RENAME TO backup_tbl;</p><br><br><p># 删除表格 <br><br>DROP TABLE IF EXISTS backup_tbl;</p><br></blockquote>

<p>（完）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2015/06/29/upgarde-postgresql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/29/upgarde-postgresql/" itemprop="url">
                  upgarde postgresql
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-29T00:00:00+08:00">
                2015-06-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><p></p><p>PostgreSQL发布9.3了， <code>brew upgrade postgresql</code> 升级到9.3， 竟然启动不起来， 查看日志发现原来9.2的数据格式不兼容，需要迁移一下数据， 碰到这个问题的同学可以看一下 :-)</p><p></p>
<p></p><h3>错误日志, 数据不兼容</h3><p></p>
<div class="codehilite"><pre><span class="o">/</span><span class="nt">usr</span><span class="o">/</span><span class="nt">local</span><span class="o">(</span><span class="nt">master</span> <span class="err">✔</span><span class="o">)</span> <span class="nt">tail</span> <span class="nt">-f</span> <span class="o">/</span><span class="nt">usr</span><span class="o">/</span><span class="nt">local</span><span class="o">/</span><span class="nt">var</span><span class="o">/</span><span class="nt">postgres</span><span class="o">/</span><span class="nt">server</span><span class="nc">.log</span><br><span class="nt">FATAL</span><span class="o">:</span>  <span class="nt">database</span> <span class="nt">files</span> <span class="nt">are</span> <span class="nt">incompatible</span> <span class="nt">with</span> <span class="nt">server</span><br><span class="nt">DETAIL</span><span class="o">:</span>  <span class="nt">The</span> <span class="nt">data</span> <span class="nt">directory</span> <span class="nt">was</span> <span class="nt">initialized</span> <span class="nt">by</span> <span class="nt">PostgreSQL</span> <span class="nt">version</span> <span class="nt">9</span><span class="nc">.2</span><span class="o">,</span> <span class="nt">which</span> <span class="nt">is</span> <span class="nt">not</span> <span class="nt">compatible</span> <span class="nt">with</span> <span class="nt">this</span> <span class="nt">version</span> <span class="nt">9</span><span class="nc">.3.1</span><span class="o">.</span><br></pre></div>


<p></p><h3>解决办法</h3><p></p>
<p></p><p>PostgreSQL提供了一个升级迁移脚本 <strong><a href="http://www.postgresql.org/docs/9.3/static/pgupgrade.html" target="_blank" rel="external">pg_upgrade</a></strong>, 用来迁移数据  </p><p></p>
<div class="codehilite"><pre><span class="n">pg_upgrade</span> <span class="o">-</span><span class="n">b</span> <span class="n">oldbindir</span> <span class="o">-</span><span class="n">B</span> <span class="n">newbindir</span> <span class="o">-</span><span class="n">d</span> <span class="n">olddatadir</span> <span class="o">-</span><span class="n">D</span> <span class="n">newdatadir</span> <span class="p">[</span><span class="n">option</span><span class="p">…]</span><br></pre></div>


<p></p><h3>1. 新建一个PostgreSQL9.3的数据目录</h3><p></p>
<div class="codehilite"><pre><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">var</span><span class="p">(</span><span class="n">master</span> <span class="err">✔</span><span class="p">)</span> <span class="n">mv</span> <span class="n">postgres</span> <span class="n">postgres9</span><span class="mf">.2</span><br><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">var</span><span class="p">(</span><span class="n">master</span> <span class="err">✔</span><span class="p">)</span> <span class="n">initdb</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">postgres</span> <span class="o">-</span><span class="n">E</span> <span class="n">utf8</span><br></pre></div>


<p></p><h3>2. 迁移数据到新目录中</h3><p></p>
<div class="codehilite"><pre><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">var</span><span class="p">(</span><span class="n">master</span> <span class="err">✔</span><span class="p">)</span> <span class="n">pg_upgrade</span> \<br><span class="o">-</span><span class="n">b</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">Cellar</span><span class="o">/</span><span class="n">postgresql</span><span class="o">/</span><span class="mf">9.2.4</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span> \<br><span class="o">-</span><span class="n">B</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">Cellar</span><span class="o">/</span><span class="n">postgresql</span><span class="o">/</span><span class="mf">9.3.1</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span> \<br><span class="o">-</span><span class="n">d</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">postgres9</span><span class="mf">.2</span> \<br><span class="o">-</span><span class="n">D</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">postgres</span> \<br><span class="o">-</span><span class="n">v</span><br></pre></div>


<p></p><p>最后迁移完成打印下面的信息就代表迁移成功了</p><p></p>
<div class="codehilite"><pre><span class="p">…</span><br><span class="n">Creating</span> <span class="n">script</span> <span class="n">to</span> <span class="n">analyze</span> <span class="n">new</span> <span class="n">cluster</span>                      <span class="n">ok</span><br><span class="n">Creating</span> <span class="n">script</span> <span class="n">to</span> <span class="n">delete</span> <span class="n">old</span> <span class="n">cluster</span>                       <span class="n">ok</span><br><br><span class="n">Upgrade</span> <span class="n">Complete</span><br><span class="o">—————-</span><br><span class="n">Optimizer</span> <span class="n">statistics</span> <span class="n">are</span> <span class="n">not</span> <span class="n">transferred</span> <span class="n">by</span> <span class="n">pg_upgrade</span> <span class="n">so</span><span class="p">,</span><br><span class="n">once</span> <span class="n">you</span> <span class="n">start</span> <span class="n">the</span> <span class="n">new</span> <span class="n">server</span><span class="p">,</span> <span class="n">consider</span> <span class="n">running</span><span class="o">:</span><br>    <span class="n">analyze_new_cluster</span><span class="p">.</span><span class="n">sh</span><br><br><span class="n">Running</span> <span class="n">this</span> <span class="n">script</span> <span class="n">will</span> <span class="n">delete</span> <span class="n">the</span> <span class="n">old</span> <span class="n">cluster</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">data</span> <span class="n">files</span><span class="o">:</span><br>    <span class="n">delete_old_cluster</span><span class="p">.</span><span class="n">sh</span><br></pre></div>


<p></p><h3>3. 启动PostgreSQL9.3</h3><p></p>
<p></p><p>查看版本和数据</p><p></p>
<div class="codehilite"><pre><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">var</span><span class="p">(</span><span class="n">master</span> <span class="err">✔</span><span class="p">)</span> <span class="n">run_postgresql</span><br><span class="n">server</span> <span class="n">starting</span><br><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">var</span><span class="p">(</span><span class="n">master</span> <span class="err">✔</span><span class="p">)</span> <span class="n">psql</span> <span class="n">postgres</span><br><span class="n">psql</span> <span class="p">(</span><span class="mf">9.3.1</span><span class="p">)</span><br><span class="n">Type</span> <span class="s">&quot;help&quot;</span> <span class="k">for</span> <span class="n">help</span><span class="p">.</span><br><br><span class="n">postgres</span><span class="o">=</span><span class="err">#</span> <span class="err">\</span><span class="n">l</span><br></pre></div>


<p></p><h3>4. 删除老版本和数据</h3><p></p>
<p></p><p>删除数据和刚刚执行<code>pg_upgrade</code>产生的两个脚本</p><p></p>
<div class="codehilite"><pre><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">var</span><span class="p">(</span><span class="n">master</span> <span class="err">✔</span><span class="p">)</span> <span class="n">rm</span> <span class="o">-</span><span class="n">rf</span> <span class="n">analyze_new_cluster</span><span class="p">.</span><span class="n">sh</span> <span class="n">delete_old_cluster</span><span class="p">.</span><span class="n">sh</span> <span class="n">postgres9</span><span class="mf">.2</span><br></pre></div>


<p></p><p>卸载PostgreSQL9.2.4</p><p></p>
<div class="codehilite"><pre><span class="n">brew</span> <span class="n">cleanup</span> <span class="n">postgresql</span><br></pre></div>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2015/06/27/nginx-location-conf-prority/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/27/nginx-location-conf-prority/" itemprop="url">
                  nginx location在配置中的优先级
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-27T00:00:00+08:00">
                2015-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><h3>location表达式类型</h3><p></p>
<p>~     表示执行一个正则匹配，区分大小写<br><br>~<em>    表示执行一个正则匹配，不区分大小写<br><br>^~    表示普通字符匹配。使用前缀匹配。如果匹配成功，则不再匹配其他location。<br><br>=     进行普通字符精确匹配。也就是完全匹配。<br><br>@     &#8220;@&#8221; 定义一个命名的 location，使用在内部定向时，例如 error_page, try_files</em></p><br><h3>location优先级说明</h3><br><p>在nginx的location和配置中location的顺序没有太大关系。正location表达式的类型有关。相同类型的表达式，字符串长的会优先匹配。<br><br>以下是按优先级排列说明：<br><br>第一优先级：等号类型（=）的优先级最高。一旦匹配成功，则不再查找其他匹配项。<br><br>第二优先级：^~类型表达式。一旦匹配成功，则不再查找其他匹配项。<br><br>第三优先级：正则表达式类型（~  ~）的优先级次之。如果有多个location的正则能匹配的话，则使用正则表达式最长的那个。<br><br>第四优先级：常规字符串匹配类型。按前缀匹配。</p><br><h3>location优先级示例</h3><br><p>配置项如下:<br><br>location  = / {<br><br>  # 仅仅匹配请求 /<br><br>  [ configuration A ]<br><br>}<br><br>location  / {<br><br>  # 匹配所有以 / 开头的请求。但是如果有更长的同类型的表达式，则选择更长的表达式。如果有正则表达式可以匹配，则<br><br>  # 优先匹配正则表达式。<br><br>  [ configuration B ]<br><br>}<br><br>location /documents/ {<br><br>    # 匹配所有以 /documents/ 开头的请求。但是如果有更长的同类型的表达式，则选择更长的表达式。<br><br>    #如果有正则表达式可以匹配，则优先匹配正则表达式。<br><br>  [ configuration C ]<br><br>}<br><br>location ^~ /images/ {<br><br>  # 匹配所有以 /images/ 开头的表达式，如果匹配成功，则停止匹配查找。所以，即便有符合的正则表达式location，也<br><br>  # 不会被使用<br><br>  [ configuration D ]<br><br>}<br><br>location ~* .(gif|jpg|jpeg)$ {<br><br>  # 匹配所有以 gif jpg jpeg结尾的请求。但是 以 /images/开头的请求，将使用 Configuration D<br><br>  [ configuration E ]<br><br>}</p><br><p>请求匹配示例<br><br>/ -&gt; configuration A<br><br>/index.html -&gt; configuration B<br><br>/documents/document.html -&gt; configuration C<br><br>/images/1.gif -&gt; configuration D<br><br>/documents/1.jpg -&gt; configuration E</p><br><p>注意，以上的匹配和在配置文件中定义的顺序无关。</p>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2015/06/27/httptcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/27/httptcp/" itemprop="url">
                  HTTP请求的TCP瓶颈分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-27T00:00:00+08:00">
                2015-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><p><img src="http://7xijc0.com1.z0.glb.clouddn.com/TCP-Stack.png" alt="tcp-stack"></p><p></p>
<p></p><p>针对<strong>三次握手、流量控制（接收窗口）、慢启动（cwnd，拥塞窗口）、队首阻塞</strong>等方面看下TCP对HTTP的影响</p><br><a id="more"></a><p></p>
<p><hr></p>
<p></p><p>这篇文章基本是对《Web性能权威指南》第一章和第二章的读书笔记，另外加一些扩展内容,这本书确实赞，推荐</p><p></p>
<p></p><h1 id="高带宽和低延迟">高带宽和低延迟</h1><p>所有网络通信都有决定性影响的两个方面:<strong>延迟和带宽</strong></p><p></p>
<ul><br><li>延迟 分组从信息源发送到目的地所需的时间。</li><br><li>带宽 逻辑或物理通信路径最大的吞吐量</li><br></ul><br><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/HTTP-TCP1.png" alt="viewport-index"></center><br><br><h2 id="延迟的因素">延迟的因素</h2><ul><br><li><strong>传播延迟</strong> 消息从发送端到接收端需要的时间（不超过光速）</li><br><li><strong>传输延迟（带宽/窗口）</strong> 把消息中的所有比特转移到链路中需要的时间,是消息长度和链路速率的函数（10M/s和1M/s的线路，时间不一样）</li><br><li><strong>处理延迟</strong> 处理分组首部、检查位错误及确定分组目标所需的时间（路由器分包）</li><br><li><strong>排队延迟</strong> 到来的分组排队等待处理的时间</li><br></ul><br><h2 id="速度延时">速度延时</h2><p>假定光通过光纤的速度 约为每秒 200 000 000 米,对应的折射率约为 1.5，从纽约到悉尼的一个往返(RTT)也要花 160 ms，分组旅行的距离比这要长得多。这条线路中的 每一跳都会涉及寻路、处理、排队和传输延迟。结果呢,纽约到悉尼的实际 RTT, 大约在 200~300 ms 之间。</p><br><blockquote><br><p>中美骨干网单向数据延时≈60ms，所以中国用户访问美国主机数据传输的延时理论值高于120ms（RTT）</p><br></blockquote><br><h2 id="带宽延时">带宽延时</h2><p>核心数据路径的骨干或光纤连接,每秒能够处理数百太比特信息，比如中美之间的海底光纤。光纤就是一根“光导管”,传送光信号。金属线则用于传送电信号,但信号损失、电磁干扰较大,同时维护成本也较高。</p><br><p>通过<strong>波分复用(WDM,Wavelength-Division Multiplexing)</strong>技术,光纤可以同时传输很多不同波长(信道)的光，2010年初,研究人员已经可以在每个信道中耦合400多种波长的光线,最大容量可达171Gbit/s,而一条光纤的总带宽能够达到70Tbit/s </p><br><h2 id="最后一公里延时-tracerouter">最后一公里延时-tracerouter</h2><p>骨干线路可以有TB的带宽，但是网络边缘的容量就小得多了,而且很大程度上取决于部署技术,比如拔号连接、 DSL、电缆、各种无线技术、光纤到户。<strong><a href="http://www.akamai.io" target="_blank" rel="external">akamai</a>每季度都会发布全球的带宽报告</strong></p><br><p>通过tracerouter工具，可以查看路由拓扑，最后一公里的延迟与提供商、部署方法、网络拓扑,甚至一天中的哪个时段都有很 大关系。作为最终用户,如果你想提高自己上网的速度,那选择延迟最短的ISP是最关键的</p><br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Traceroute</span> sends out three packets per TTL increment. Each column corresponds to the </span><br><span class="line">time is took to get one packet back (round-trip-time).</span><br><span class="line"></span><br><span class="line">traceroute to xx.com (<span class="number">121.41.167.43</span>), <span class="number">30</span> hops max, <span class="number">60</span> byte packets</span><br><span class="line"> <span class="number">1</span>  <span class="number">198.11.175.248</span> (<span class="number">198.11.175.248</span>)  <span class="number">0</span>.<span class="number">879</span> ms  <span class="number">0</span>.<span class="number">898</span> ms  <span class="number">0</span>.<span class="number">950</span> ms</span><br><span class="line"> <span class="number">2</span>  <span class="number">10.107.64.14</span> (<span class="number">10.107.64.14</span>)  <span class="number">0</span>.<span class="number">945</span> ms <span class="number">10.107.64.22</span> (<span class="number">10.107.64.22</span>)  <span class="number">1</span>.<span class="number">033</span> ms <span class="number">10.107.64.18</span> (<span class="number">10.107.64.18</span>)  <span class="number">75</span>.<span class="number">379</span> ms</span><br><span class="line"> <span class="number">3</span>  <span class="number">198.11.128.162</span> (<span class="number">198.11.128.162</span>)  <span class="number">135</span>.<span class="number">636</span> ms <span class="number">198.11.128.154</span> (<span class="number">198.11.128.154</span>)  <span class="number">0</span>.<span class="number">913</span> ms <span class="number">198.11.128.178</span> (<span class="number">198.11.128.178</span>)  <span class="number">5</span>.<span class="number">472</span> ms</span><br><span class="line"> <span class="number">4</span>  <span class="number">218.30.53.93</span> (<span class="number">218.30.53.93</span>)  <span class="number">4</span>.<span class="number">542</span> ms <span class="number">218.30.53.97</span> (<span class="number">218.30.53.97</span>)  <span class="number">2</span>.<span class="number">144</span> ms <span class="number">218.30.53.126</span> (<span class="number">218.30.53.126</span>)  <span class="number">2</span>.<span class="number">334</span> ms</span><br><span class="line"> <span class="number">5</span>  <span class="number">202.97.51.253</span> (<span class="number">202.97.51.253</span>)  <span class="number">160</span>.<span class="number">089</span> ms  <span class="number">160</span>.<span class="number">170</span> ms  <span class="number">160</span>.<span class="number">077</span> ms</span><br><span class="line"> <span class="number">6</span>  <span class="number">202.97.35.105</span> (<span class="number">202.97.35.105</span>)  <span class="number">188</span>.<span class="number">541</span> ms  <span class="number">190</span>.<span class="number">518</span> ms  <span class="number">188</span>.<span class="number">903</span> ms</span><br><span class="line"> <span class="number">7</span>  <span class="number">202.97.33.37</span> (<span class="number">202.97.33.37</span>)  <span class="number">168</span>.<span class="number">075</span> ms  <span class="number">168</span>.<span class="number">109</span> ms  <span class="number">168</span>.<span class="number">016</span> ms</span><br><span class="line"> <span class="number">8</span>  <span class="number">202.97.55.14</span> (<span class="number">202.97.55.14</span>)  <span class="number">192</span>.<span class="number">583</span> ms  <span class="number">192</span>.<span class="number">572</span> ms  <span class="number">192</span>.<span class="number">591</span> ms</span><br><span class="line"> <span class="number">9</span>  <span class="number">220.191.135.106</span> (<span class="number">220.191.135.106</span>)  <span class="number">201</span>.<span class="number">476</span> ms  <span class="number">201</span>.<span class="number">542</span> ms  <span class="number">201</span>.<span class="number">465</span> ms</span><br><span class="line"><span class="number">10</span>  <span class="number">115.236.101.209</span> (<span class="number">115.236.101.209</span>)  <span class="number">211</span>.<span class="number">315</span> ms  <span class="number">211</span>.<span class="number">305</span> ms <em></em></span><br><span class="line"><span class="number">11</span>  <span class="number">42.120.244.194</span> (<span class="number">42.120.244.194</span>)  <span class="number">270</span>.<span class="number">211</span> ms <span class="number">42.120.244.178</span> (<span class="number">42.120.244.178</span>)  <span class="number">163</span>.<span class="number">768</span> ms  <span class="number">163</span>.<span class="number">700</span> ms</span><br><span class="line"><span class="number">12</span>  <span class="number">42.120.244.238</span> (<span class="number">42.120.244.238</span>)  <span class="number">191</span>.<span class="number">543</span> ms <span class="number">42.120.244.246</span> (<span class="number">42.120.244.246</span>)  <span class="number">248</span>.<span class="number">825</span> ms  <span class="number">248</span>.<span class="number">910</span> ms</span><br></pre></td></tr></table></figure><br><h2 id="目标">目标</h2><p><strong>高带宽</strong><br>目前还没有理由认为带宽会停止增长的脚步，就算技术停滞不前,还是可以铺设更多的光缆</p><br><p><strong>低延时</strong></p><br><blockquote><br><p>减少延迟相比带宽困难的多，从很多方面来看,我们的基础设施似乎也已经达到了这个极限。这就显得理解和调优网络协议显得特别重要</p><br></blockquote><br><hr><br><h1 id="TCP三次握手">TCP三次握手</h1><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/http-tcp2.png" alt="viewport-index"></center><br><br><p>客户端可以在发送 ACK分组之后立即发送数据,而服务器必须等接收到ACK分组之后才能发送数据。这个启动通信的过程适用于所有 TCP 连接,因此对所有使用TCP的应用具有非常大的性能影响,<strong>每次传输应用数据之前,都必须经历一次完整的往返</strong></p><br><blockquote><br><p>中美之间一次RTT最低120，假设你发起一个简单的HTTP请求，需要一次握手+一次数据传输 = 240ms，浪费了50%的时间，这也意味着提高TCP应用性能的关键在于想办法重用连接</p><br></blockquote><br><p>扩展：TFO(TCP Fast Open,TCP 快速打 开)机制,致力于减少新建 TCP 连接带来的性能损失</p><br><h1 id="流量控制（窗口rwnd）">流量控制（窗口rwnd）</h1><p>rwnd是端到端的控制机制，预防发送过多的数据,TCP连接的每一方都会通告自己的接收窗口,其中包含能够保存数据的缓冲区空间大小信息。TCP 连接的整个生命周期:每个 ACK 分组都会携带相应的最新rwnd 值,以便两端动态调整数据流速,使之适应发送端和接收端的容量及处理能力</p><br><p>窗口的值原来只有16位，即65535，所以以前rwnd的最大值不能超过64K。现在基本都有了“TCP 窗口缩放”(TCP Window Scaling)，把接收窗口大小由 65 535 字节提高到 1G 字节，在 Linux 中,可以通过如下命 令检查和启用窗口缩放选项:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; sysctl net<span class="class">.ipv4</span><span class="class">.tcp_window_scaling</span></span><br><span class="line">$&gt; sysctl -w net<span class="class">.ipv4</span><span class="class">.tcp_window_scaling</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure></p><br><h2 id="rwnd的设置">rwnd的设置</h2><p>如果我们出于传输性能的考虑，当然这个值设置的越大越好,Linux中通过配置内核参数里接收缓冲的大小，进而可以控制接收窗口的大小：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; sysctl -a | grep mem</span><br><span class="line">net.ipv4.tcp_rmem = <span class="tag">&lt;<span class="title">MIN</span>&gt;</span> <span class="tag">&lt;<span class="title">DEFAULT</span>&gt;</span> <span class="tag">&lt;<span class="title">MAX</span>&gt;</span></span><br></pre></td></tr></table></figure></p><br><p>还有个问题,当大量请求同时到达时，内存会不会爆掉？通常不会，因为Linux本身有一个缓冲大小自动调优的机制，窗口的实际大小会自动在最小值和最大值之间浮动，以期找到性能和资源的平衡点。</p><br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过如下方式可以确认缓冲大小自动调优机制的状态（<span class="number">0</span>：关闭、<span class="number">1</span>：开启）：</span><br><span class="line"><span class="built_in">shell</span>&gt; sysctl -<span class="operator">a</span> | grep tcp_moderate_rcvbuf</span><br></pre></td></tr></table></figure><br><h1 id="慢启动（cwnd，拥塞窗口）">慢启动（cwnd，拥塞窗口）</h1><p>两端流量控制确实可以防止发送端向接收端过多发送数据,但却没有机制预防任何一端向潜在网络过多发送数据。换句话说,发送端和接收端在连接建立之初,谁也不知道可用带宽是多少,因此需要一个估算机制,<strong>然后根据网络中不断变化的条件 而动态改变速度:TCP能传输的最大数据 = MIN（rand,cwnd）</strong></p><br><p>慢启动的算法如下(cwnd全称Congestion Window)：</p><br><ul><br><li>1）连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。</li><br><li>2）每当收到一个ACK，cwnd++; 呈线性上升</li><br><li>3）每当过了一个RTT，cwnd = cwnd2; 呈指数让升</li><br><li>4）还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</li><br></ul><br><blockquote><br><p>最初,cwnd 的值只有1个TCP segment。99 年 4 月,RFC 2581 将其增加到了 4 个 TCP segment。2013 年 4 月,RFC 6928 再次将其提高到 10 个 TCP segment</p><br></blockquote><br><h2 id="慢启动过程">慢启动过程</h2><p>服务器向客户端发送 4 个 TCP segment,然后就必须停下来等待确认。此后,每收到一个 ACK, 慢启动算法就会告诉服务器可以将它的 cwnd 窗口增加 1 个 TCP segment.这个阶段通常被称为<strong>指数增长</strong>阶段,因为客户端和服务器都在向两者之间网络路径的有效带宽迅速靠拢</p><br><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/http-tcp4.png" alt="viewport-index"></center><br><br><p>计算达到指定窗口所需要的时间公式：</p><br><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/HTTP-TCP5.PNG" alt="viewport-index"></center><br><br><ul><br><li>客户端和服务器的接收窗口为 65 535 字节(64 KB);</li><br><li>初始的拥塞窗口:4 个segment(一个segment 一般是1460B);</li><br><li>往返时间是 56 ms(伦敦到纽约)。</li><br></ul><br><p>为了达到64KB限制，我们将需要把拥塞窗口增加到45个segment，这将花费224毫秒。</p><br><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/HTTP-TCP6.PNG" alt="viewport-index"></center><br><br><h2 id="慢启动的影响">慢启动的影响</h2><p>无论带宽多大,每个 TCP 连接都必须经过慢 启动阶段。换句话说,我们不可能一上来就完全利用连接的最大带宽。</p><br><p>慢启动导致客户端与服务器之间经过几百 ms 才能达到接近最大速度的问题,对于大型流式下载服务的影响不显著,因为慢启动的时间可以分摊到整个传输周期内消化掉。</p><br><blockquote><br><p>对于很多 HTTP 连接,特别是一些短暂、突发的连接而言,常常会出现还没 有达到最大窗口请求就被终止的情况。换句话说,很多 Web 应用的性能经常受到服 务器与客户端之间往返时间的制约。因为慢启动限制了可用的吞吐量,而这对于小 文件传输非常不利。</p><br></blockquote><br><h2 id="慢启动对HTTP影响的一次计算">慢启动对HTTP影响的一次计算</h2><p>假设通过HTTP传输一个20K的文件，初始条件：</p><br><ul><br><li>往返时间:56 ms。</li><br><li>客户端到服务器的带宽:5 Mbit/s。</li><br><li>客户端和服务器接收窗口:65 535 字节。</li><br><li>初始的拥塞窗口:4 segment(4×1460 字节 ≈ 5.7 KB)。</li><br><li>服务器生成响应的处理时间:40 ms。</li><br><li>没有分组丢失、每个分组都要确认、GET 请求只占 1 段。</li><br></ul><br><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/HTTP-TCP7.PNG" alt="viewport-index"></center><br><br><ul><br><li>0 ms:客户端发送 SYN 分组开始 TCP 握手。</li><br><li>28 ms:服务器响应 SYN-ACK 并指定其 rwnd 大小。</li><br><li>56 ms:客户端确认 SYN-ACK,指定其 rwnd 大小,并立即发送 HTTP GET 请求。<br>8 84 ms:服务器收到 HTTP 请求。</li><br><li>124 ms:服务器生成 20 KB 的响应,并发送 4 个 TCP 段(初始 cwnd 大小为 4),<br>然后等待 ACK。</li><br><li>152 ms:客户端收到 4 个段,并分别发送 ACK 确认。</li><br><li>180 ms:服务器针对每个 ACK 递增 cwnd,然后发送 8 个 TCP 段。</li><br><li>208 ms:客户端接收 8 个段,并分别发送 ACK 确认。</li><br><li>236 ms:服务器针对每个 ACK 递增 cwnd,然后发送剩余的 TCP 段。</li><br><li>264 ms:客户端收到剩余的 TCP 段,并分别发送 ACK 确认。</li><br></ul><br><p>作为对比，重用连接，再发一次请求</p><br><ul><br><li>0 ms:客户端发送 HTTP 请求。</li><br><li>28 ms:服务器收到 HTTP 请求。</li><br><li>68 ms:服务器生成 20 KB 响应,但 cwnd 已经大于发送文件所需的 15 段了,因<br>此一次性发送所有数据段。</li><br><li>96 ms:客户端收到所有 15 个段,分别发送 ACK 确认。</li><br></ul><br><p><strong>同一个连接、同样的请求,但没有三次握手和慢启动,只花了 96 ms,性能提升幅 度达 275% !</strong></p><br><h2 id="拥塞窗口的合适值">拥塞窗口的合适值</h2><p>Google在这方面做了大量的研究，权衡了效率和稳定性之后，最终给出的建议是10MSS。如果你的Linux版本不太旧的话，那么可以通过如下方法来调整「cwnd」初始值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; ip route | <span class="keyword">while</span> <span class="built_in">read</span> p; <span class="keyword">do</span></span><br><span class="line">           ip route change <span class="variable">$p</span> initcwnd <span class="number">10</span>;</span><br><span class="line">       <span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><br><p>需要提醒的是片面的提升发送端「cwnd」的大小并不一定有效，这是因为前面我们说过网络中实际传输的未经确认的数据大小取决于「rwnd」和「cwnd」中的小值，所以一旦接收方的「rwnd」比较小的话，会阻碍「cwnd」的发挥。</p><br><h1 id="拥塞预防">拥塞预防</h1><p>拥塞预防算法把丢包作为网络拥塞的标志,即路径中某个连接或路由器已经拥堵了, 以至于必须采取删包措施。因此,必须调整窗口大小,以避免造成更多的包丢失, 从而保证网络畅通。</p><br><p>重置拥塞窗口后,拥塞预防机制按照自己的算法来增大窗口以尽量避免丢包。某个 时刻,可能又会有包丢失,于是这个过程再从头开始。<strong>如果你看到过 TCP 连接的吞 吐量跟踪曲线,发现该曲线呈锯齿状,那现在就该明白为什么了</strong>。这是拥塞控制和 预防算法在调整拥塞窗口,进而消除网络中的丢包问题。</p><br><blockquote><br><p>最初,TCP 使用 AIMD(Multiplicative Decrease and Additive Increase,倍减加增) 算法,即发生丢包时,先将拥塞窗口减半,然后每次往返再缓慢地给窗口增加一 个固定的值。不过,很多时候 AIMD 算法太过保守,因此又有了很多新的算法，比如DSACK：可以让协议知道是什么原因丢包，是重传还是丢失</p><br></blockquote><br><h1 id="带宽延迟积">带宽延迟积</h1><p>发送端和接收端之间在途未确认的最大数据量,取决于拥塞窗 口(cwnd)和接收窗口(rwnd)的最小值。接收窗口会随每次 ACK 一起发送,而 拥塞窗口则由发送端根据拥塞控制和预防算法动态调整.</p><br><p><strong>BDP(Bandwidth-delay product,带宽延迟积)</strong><br>数据链路的容量与其端到端延迟的乘积。这个结果就是任意时刻处于在途未确认 状态的最大数据量。无论发送端发送的数据还是接收端接收的数据超过了未确认的最大数据量,都必须停 下来等待另一方 ACK 确认某些分组才能继续 </p><br><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/http-tcp8.png" alt="viewport-index"></center><br><br><blockquote><br><p>那么,流量控制窗口(rwnd)和拥塞控制窗口(cwnd)的值多大合适?实际上,计算过程很简单。首先,假设 cwnd 和 rwnd 的最小值为 16 KB,往返时间为 100 ms: </p><br></blockquote><br><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/http-tcp10.png" alt="viewport-index"></center><br><br><blockquote><br><p>不管发送端和接收端的实际带宽多大,这个 TCP 连接的数据传输速率不会超过 1.31 Mbit/s !想提高吞吐量,要么增大最小窗口值,要么减少往返时间。窗口至少需要 122.1 KB 才能充分利用 10 Mbit/s 带宽!如果没有“窗口 缩放(RFC 1323)”,TCP 接收窗口最大只有 64 KB</p><br></blockquote><br><h1 id="队首阻塞造成的延时">队首阻塞造成的延时</h1><p>每个 TCP 分组都会带着一个唯一的序列号被发出,而 所有分组必须按顺序传送到接收端。如果中途有一个分组没能到达接收 端,那么后续分组必须保存在接收端的 TCP 缓冲区,等待丢失的分组重发并到达接 收端。这一切都发生在 TCP 层,应用程序对 TCP 重发和缓冲区中排队的分组一无所 知,必须等待分组全部到达才能访问数据。在此之前,应用程序只能在通过套接字 读数据时感觉到延迟交付。这种效应称为 <strong>TCP 的队首(HOL,Head of Line)阻塞</strong></p><br><p>队首阻塞造成的延迟<strong>可以让我们的应用程序不用关心分组重排和重组,从而让代码 保持简洁。然而,代码简洁也要付出代价,那就是分组到达时间会存在无法预知的 延迟变化。这个时间变化通常被称为抖动</strong></p><br><p><center><img src="http://7xijc0.com1.z0.glb.clouddn.com/http-tcp11.png" alt="viewport-index"></center><br>事实上,某些场景下,丢包是让 TCP 达到最佳性能的关键。有些应用程序可以容忍丢失一 定数量的包,比如语音和游戏状态通信,就不需要可靠传输或按序交付</p><br><h1 id="针对TCP的优化建议">针对TCP的优化建议</h1><p>每个算法和反馈机制的具体细节可能会继续发展,但核心原理以及 它们的影响是不变的:</p><br><ul><br><li>TCP 三次握手增加了整整一次往返时间;</li><br><li>TCP 慢启动将被应用到每个新连接;</li><br><li>TCP 流量及拥塞控制会影响所有连接的吞吐量;</li><br><li>TCP 的吞吐量由当前拥塞窗口大小控制。</li><br></ul><br><blockquote><br><p>结果,现代高速网络中 TCP 连接的数据传输速度,往往会受到接收端和发送端之 间往返时间的限制。另外,尽管带宽不断增长,但延迟依旧受限于光速,而且已经 限定在了其最大值的一个很小的常数因子之内。大多数情况下,TCP 的瓶颈都是延迟,而非带宽</p><br></blockquote><br><h2 id="服务器配置调优">服务器配置调优</h2><ul><br><li><p>增大TCP的初始拥塞窗口<br>加大起始拥塞窗口可以让 TCP 在第一次往返就传输较多数据,而随后的速度提 升也会很明显。对于突发性的短暂连接,这也是特别关键的一个优化。</p><br></li><br><li><p>慢启动重启<br>在连接空闲时禁用慢启动可以改善瞬时发送数据的长 TCP 连接的性能。</p><br></li><br><li><p>窗口缩放(RFC 1323) 启用窗口缩放可以增大最大接收窗口大小,可以让高延迟的连接达到更好吞 吐量。</p><br></li><br><li><p>TCP快速打开<br>在某些条件下,允许在第一个 SYN 分组中发送应用程序数据。TFO(TCP Fast Open,TCP 快速打开)是一种新的优化选项,需要客户端和服务器共同支持。 为此,首先要搞清楚你的应用程序是否可以利用这个特性。</p><br></li><br></ul><br><p>以上几个设置再加上最新的内核,可以确保最佳性能:每个 TCP 连接都会具有较低 的延迟和较高的吞吐量。</p><br><h2 id="应用程序行为调优">应用程序行为调优</h2><ul><br><li>再快也快不过什么也不用发送,能少发就少发。</li><br><li>我们不能让数据传输得更快,但可以让它们传输的距离更短。</li><br><li><strong>重用 TCP 连接是提升性能的关键</strong></li><br></ul><br><h2 id="性能检查清单">性能检查清单</h2><ul><br><li>把服务器内核升级到最新版本(Linux:3.2+);</li><br><li>确保 cwnd 大小为 10;</li><br><li>禁用空闲后的慢启动;</li><br><li>确保启动窗口缩放;</li><br><li>减少传输冗余数据;</li><br><li>压缩要传输的数据;</li><br><li>把服务器放到离用户近的地方以减少往返时间;</li><br><li>尽最大可能重用已经建立的 TCP 连接</li><br></ul><br><h1 id="参考">参考</h1><ul><br><li><a href="http://www.zrblog.net/5575.html" target="_blank" rel="external">美国机房及中美网络延时状况</a></li><br><li><a href="http://huoding.com/2013/11/21/299" target="_blank" rel="external">浅谈TCP优化（rwnd和cwnd的测量和计算）</a></li><br><li><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="external">TCP 的那些事儿（上）</a></li><br><li><a href="http://blog.buildingautomationmonthly.com/what-is-the-tcpip-stack/" target="_blank" rel="external">What is the TCP/IP Stack</a></li><br></ul>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2015/06/27/git-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/27/git-tips/" itemprop="url">
                  简明 Git 命令速查表（中文版）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-27T00:00:00+08:00">
                2015-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          Git Cheat Sheet
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2015/06/27/git-tips/">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400"
               alt="Chen Tao" />
          <p class="site-author-name" itemprop="name">Chen Tao</p>
           
              <p class="site-description motion-element" itemprop="description">Engineer Blogger Creator Runner | ML DM JVM Web | 旅行 电影 歌手 摄影 | 读书的要义是尽量求得客观的认识，不是为了炫耀自己的‘创造力’，或‘发前人所未发’。 优秀程序员的价值，不在于其所掌握的几招屠龙之术，而是在细节中见真著。 如果我们可以一次把事情做对做好，在允许的范围内尽可能追求卓越，为什么不去做呢。 | @HNU</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">178</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">92</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Chen-tao" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/Chentao11" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/546410275" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/chen-tao-68-95" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-book"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Tao</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
