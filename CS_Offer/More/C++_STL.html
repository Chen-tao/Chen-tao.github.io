<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="C++ STL 标准库C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。 C++ 标准模板库的核心包括以下三个组件：    组件 描述     容器（Containers） 容器是用来管理某一类对象的集合。C++ 提供了各种不同 类型的容器，比如 vector、map 等。   算">
<meta property="og:type" content="website">
<meta property="og:title" content="Chen-Tao">
<meta property="og:url" content="http://chen-tao.github.io/CS_Offer/More/C++_STL.html">
<meta property="og:site_name" content="Chen-Tao">
<meta property="og:description" content="C++ STL 标准库C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。 C++ 标准模板库的核心包括以下三个组件：    组件 描述     容器（Containers） 容器是用来管理某一类对象的集合。C++ 提供了各种不同 类型的容器，比如 vector、map 等。   算">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-08-27T01:38:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chen-Tao">
<meta name="twitter:description" content="C++ STL 标准库C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。 C++ 标准模板库的核心包括以下三个组件：    组件 描述     容器（Containers） 容器是用来管理某一类对象的集合。C++ 提供了各种不同 类型的容器，比如 vector、map 等。   算">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chen-tao.github.io/CS_Offer/More/C++_STL.html"/>





  <title> | Chen-Tao</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chen-Tao</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">颂其诗，读其书，不知其人，可乎？</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

	<h1 class="post-title" itemprop="name headline"></h1>



</header>

      
      
      
      <div class="post-body">
        
        
          <h1 id="C-STL-标准库"><a href="#C-STL-标准库" class="headerlink" title="C++ STL 标准库"></a>C++ STL 标准库</h1><p>C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。</p>
<p>C++ 标准模板库的核心包括以下三个组件：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>容器（Containers）</td>
<td>容器是用来管理某一类对象的集合。C++ 提供了各种不同</td>
<td>类型的容器，比如 vector、map 等。</td>
</tr>
<tr>
<td>算法（Algorithms）</td>
<td>算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td>
</tr>
<tr>
<td>迭代器（Iterators）</td>
<td>迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</td>
</tr>
</tbody>
</table>
<p>STL的一个重要特点是<code>数据结构和算法的分离</code>。尽管这是个简单的概念，但这种分离确实使得STL变得非常通用。例如，由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组。</p>
<p>STL另一个重要特性是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。你在STL中找不到任何明显的类继承关系。</p>
<p>程序要使用 STL 时，应包含（#include）适当的标准头文件。对大部分容器来说，标准头文件的名称和容器名一致，且不需扩展名。比如说，如果你要用vector，只要在程序最开头添加下面这行代码：</p>
<pre><code>#include &lt;vector&gt;
</code></pre><p>容器类型（还有算法、运算符和所有 STL也一样）并不是定义在全局命名空间，而是定义在一个叫“std”的特殊命名空间里。在包含完所有头文件之后，还应该引入std::vector名字空间。</p>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>一个容器就是一些特定类型对象的集合。<code>顺序容器（sequential container）</code>为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。</p>
<p>除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue和priority_queue。<code>适配器</code>是标准库中的一个通用概念，容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。</p>
<p>和顺序容器对应的是<code>关联容器（associative-container）</code>，关联容器中的元素是按关键字来保存和访问的。关联容器支持高效的关键字查找和访问，STL有两个主要的关联容器：map 和 set。</p>
<p><a href="More/C++_STL_Container.md">More：C++_STL_Containe</a></p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>STL 迭代器是访问容器数据的最普通的方式。为迭代器定义如下操作：</p>
<ul>
<li>从迭代器取值，int x = *it；</li>
<li>让迭代器自增和自减 it1++，it2–；</li>
<li>通过‘!=’和‘\&lt;’来比较迭代器大小；</li>
<li>向迭代器添加一个常量值 it += 20；（向前移动了 20 个元素位置）</li>
<li>获取两个迭代器之间的差值，int n = it2 – it1；</li>
</ul>
<p>和指针不同，迭代器提供了许多更强大的功能。它们不仅能操作任何类型的容器，还能执行范围检查并分析容器的使用。当然，迭代器的最大优势就是极大地增加了代码重用性：基于迭代器写的算法在大部分的容器上都能使用，而且，自己写的容器要是提供了迭代器，就能作为参数传给各种各样的标准函数。</p>
<p>STL 算法常常使用两个迭代器，称为’begin’和’end’。尾部迭代器不指向最后一个对象，而是指向第一个无效对象，或是紧跟在最后一个对象后面的对象。每一个 STL 容器都有 begin() 和 end() 两个成员函数，分别返回容器的初始迭代器和尾部迭代器。</p>
<p>基于这些原理，只有容器 c 为空时，<code>c.begin() == c.end()</code>才成立，而<code>c.end() – c.begin()</code>总是会等于 c.size()。（后一句只有在迭代器可以做减法运算时才有效，例如，begin() 和 end() 都返回随机存取迭代器，但不是所有容器都支持。）</p>
<p>每个容器都有 rbegin()/rend() 函数，它们返回反向迭代器（和正常迭代器的指向相反）。反向迭代器用来从后往前地遍历容器。</p>
<pre><code>// vector&lt;int&gt;::reverse_iterator it;
vector&lt;int&gt; v1 = {1,2,3}
for(auto it = v1.rbegin();it!=v1.rend();it++){
    cout &lt;&lt; *it &lt;&lt; &quot;\t&quot;;
}
</code></pre><h1 id="常用库函数"><a href="#常用库函数" class="headerlink" title="常用库函数"></a>常用库函数</h1><h2 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h2><p>memcpy是c和c++使用的内存拷贝函数，从源src所指的内存地址的起始位置开始拷贝<strong>n个字节</strong>到目标dest所指的内存地址的起始位置中，函数返回指向dest的指针。函数原型如下：</p>
<pre><code>// #include &lt;cstring&gt;
// #include &lt;string.h&gt; 
void *memcpy(void *dest, const void *src, size_t n);
</code></pre><p>要注意下面两个问题：</p>
<ol>
<li>src和dest所指的内存区域可能重叠，并不能够确保src所在重叠区域在拷贝之前不被覆盖。而使用 <code>memmove</code> 可以用来处理重叠区域。</li>
<li>如果目标区域dest本身已有数据，执行memcpy后，将覆盖原有数据（最多覆盖n）。</li>
</ol>
<p>strcpy和memcpy主要有以下3方面的区别。</p>
<ol>
<li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li>
<li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</li>
<li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。</li>
</ol>
<p>例子(把一个char组成的字符串循环右移n位，n小于字符串长度)</p>
<pre><code>const int MAX_LEN = 100;

void LoopMove (char *pStr, int steps )
{
    int n = strlen( pStr ) - steps;
    char tmp[MAX_LEN];

    memcpy(tmp, pStr + n, steps );
    memmove(pStr + steps, pStr, n );    // 防治内存区域重叠
    memcpy(pStr, tmp, steps );
}

int main(){
    char temp[] = &quot;abcdefg&quot;;
    LoopMove(temp, 2);
    printf(&quot;%s&quot;, temp);
}
</code></pre><p>［<a href="http://www.nowcoder.com/questionTerminal/32859fcd17ab47468a2899935829f3de" target="_blank" rel="external">memmove 实现方式</a>］</p>
<h2 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h2><p>memset 将s所指向的某一块内存中的前n个<code>字节</code>的内容全部设置为ch指定的ASCII值，第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作，其返回值为指向s的指针。是对较大的结构体或数组进行<code>清零</code>操作（memset(&amp;Address, 0, sizeof(Address))）的一种最快方法.<br>    // #include <cstring><br>    // #include <string.h><br>    void <em>memset(void </em>s, int ch, size_t n);</string.h></cstring></p>
<p><strong>用 memset 对非字符型数组赋非零的初值是不可取的</strong>！如下例子：</p>
<pre><code>int a[5];
// memset(a,1,5*sizeof(int));
memset(a,1,sizeof(a));

for(int i=0;i&lt;5;i++)
    cout&lt;&lt;a[i];
// 1684300916843009168430091684300916843009
</code></pre><p>这是因为memset对a指向的内存的20个字节进行赋值，每个都用数1去填充，转为二进制后，1就是00000001，占一个字节。一个int元素是4字节，合一起是0000 0001,0000 0001,0000 0001,0000 0001，转化成十六进制就是0x01010101，就等于16843009，就完成了对一个int元素的赋值了。</p>
<h1 id="高危库函数"><a href="#高危库函数" class="headerlink" title="高危库函数"></a>高危库函数</h1><p>C 中大多数缓冲区溢出问题可以直接追溯到标准 C 库。最有害的罪魁祸首是不进行自变量检查的、有问题的字符串操作（strcpy、strcat、sprintf 和 gets）。</p>
<p><strong>永远不要使用 gets()</strong></p>
<p>最新的编译器会提醒：warning: this program uses gets(), which is unsafe.  这是因为gets函数从标准输入读入用户输入的一行文本，它在遇到 EOF 字符或换行字符之前，不会停止读入文本。也就是gets() 根本不执行边界检查。因此，使用 gets() 总是有可能使任何缓冲区溢出。作为一个替代方法，可以使用方法 <code>fgets(buf, size, stdin)</code>，它可以做与 gets() 所做的同样的事情，但它接受用来限制读入字符数目的大小参数，因此，提供了一种防止缓冲区溢出的方法。</p>
<pre><code>#define BUFSIZE 10

int main(){
    char buf[BUFSIZE];
    // gets(buf);
    fgets(buf, BUFSIZE, stdin);
}
</code></pre><p>如果有可能，避免使用下面的函数：</p>
<ul>
<li>strcpy，strcat</li>
<li>printf，sprintf, fprintf, …</li>
<li>scanf，sscanf, fscanf, …</li>
</ul>
<p><strong>strcpy()函数</strong></p>
<p>strcpy()函数将源字符串复制到目的缓冲区，但是没有指定要复制字符的具体数目。复制字符的数目直接取决于源字符串中的数目，如果源字符串碰巧来自用户输入，且没有专门限制其大小，则有可能会陷入大的麻烦中！</p>
<p>如果知道目的地缓冲区的大小，可以添加明确的检查。或者使用 <code>strncpy() 函数</code>：</p>
<pre><code>strncpy(dest, src, dst_size-1);
dst[dst_size-1] = &apos;\0&apos;; /* Always do this to be safe! */
</code></pre><p>如果 src 比 dst 大，则该函数不会抛出一个错误；当达到最大尺寸时，它只是停止复制字符，注意上面dst_size-1。</p>
<p>strcat()函数非常类似于 strcpy()，除了它将一个字符串合并到缓冲区末尾。它也有一个类似的、更安全的替代方法 <code>strncat()</code>。如果可能，使用 strncat() 而不要使用 strcat()。</p>
<p>参考：<br><a href="http://blog.jobbole.com/87586/" target="_blank" rel="external">标准模板库（STL）使用入门（上）</a><br><a href="http://www.ibm.com/developerworks/cn/security/buffer-defend/index.html" target="_blank" rel="external">防止缓冲区溢出</a></p>

        
      </div>
      
      
      
    </div>
    
    
    
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400"
               alt="Chen Tao" />
          <p class="site-author-name" itemprop="name">Chen Tao</p>
           
              <p class="site-description motion-element" itemprop="description">Engineer Blogger Creator Runner | ML DM JVM Web | 旅行 电影 歌手 摄影 | 读书的要义是尽量求得客观的认识，不是为了炫耀自己的‘创造力’，或‘发前人所未发’。 优秀程序员的价值，不在于其所掌握的几招屠龙之术，而是在细节中见真著。 如果我们可以一次把事情做对做好，在允许的范围内尽可能追求卓越，为什么不去做呢。 | @HNU</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">180</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">94</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-STL-标准库"><span class="nav-number">1.</span> <span class="nav-text">C++ STL 标准库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#容器"><span class="nav-number">2.</span> <span class="nav-text">容器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#算法"><span class="nav-number">3.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#迭代器"><span class="nav-number">4.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用库函数"><span class="nav-number">5.</span> <span class="nav-text">常用库函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#memcpy"><span class="nav-number">5.1.</span> <span class="nav-text">memcpy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memset"><span class="nav-number">5.2.</span> <span class="nav-text">memset</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#高危库函数"><span class="nav-number">6.</span> <span class="nav-text">高危库函数</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Tao</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  








  






  





  

  

  

  

  

  

</body>
</html>
