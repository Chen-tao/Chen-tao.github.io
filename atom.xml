<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chen-Tao</title>
  
  <subtitle>颂其诗，读其书，不知其人，可乎？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chen-tao.github.io/"/>
  <updated>2017-10-17T08:12:09.042Z</updated>
  <id>http://chen-tao.github.io/</id>
  
  <author>
    <name>Chen Tao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hive CookBook</title>
    <link href="http://chen-tao.github.io/2017/10/17/hive-tips/"/>
    <id>http://chen-tao.github.io/2017/10/17/hive-tips/</id>
    <published>2017-10-16T16:00:00.000Z</published>
    <updated>2017-10-17T08:12:09.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查询配置"><a href="#查询配置" class="headerlink" title="查询配置"></a>查询配置</h2><p>设置任务名称 <code>set mapreduce.job.name=xxx_yourname;</code></p><p>指定任务队列 <code>set mapreduce.job.queuename=offline.data;</code></p><p>任务结果输出header信息 <code>set hive.cli.print.header=true;</code></p><p>设置优先级 <code>set mapreduce.job.priority=HIGH;</code></p><blockquote><p>优先级说明:<br>配置 <code>mapreduce.job.priority</code> 来调整优先级，支持的值：</p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">对应YARN优先级</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">NORMAL(默认)</td><td style="text-align:left">1</td><td style="text-align:left">普通任务</td></tr><tr><td style="text-align:left">HIGH</td><td style="text-align:left">2</td><td style="text-align:left">nearline 任务</td></tr><tr><td style="text-align:left">VERY_HIGH</td><td style="text-align:left">3</td><td style="text-align:left">在线任务</td></tr><tr><td style="text-align:left">CRITICAL</td><td style="text-align:left">6</td><td style="text-align:left">关键任务</td></tr><tr><td style="text-align:left">VERY_CRITICAL</td><td style="text-align:left">9</td><td style="text-align:left">非常关键的任务</td></tr></tbody></table></blockquote><h3 id="reduce阶段内存配置："><a href="#reduce阶段内存配置：" class="headerlink" title="reduce阶段内存配置："></a><strong>reduce阶段内存配置：</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> mapreduce.reduce.java.opts=-Xmx3072m;</div><div class="line"><span class="built_in">set</span> mapreduce.reduce.memory.mb=4096;</div></pre></td></tr></table></figure><h3 id="map阶段内存配置："><a href="#map阶段内存配置：" class="headerlink" title="map阶段内存配置："></a>map阶段内存配置：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> mapreduce.map.java.opts=-Xmx3072m;</div><div class="line"><span class="built_in">set</span> mapreduce.map.memory.mb=4096;</div></pre></td></tr></table></figure><h3 id="map数过多："><a href="#map数过多：" class="headerlink" title="map数过多："></a>map数过多：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> mapred.min.split.size=536870912;</div><div class="line"><span class="built_in">set</span> mapred.max.split.size=536870912;</div></pre></td></tr></table></figure><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><h3 id="使用-Rank-计算分组-TopN-或-Top-Percentile"><a href="#使用-Rank-计算分组-TopN-或-Top-Percentile" class="headerlink" title="使用 Rank() 计算分组 TopN 或 Top Percentile"></a>使用 Rank() 计算分组 TopN 或 Top Percentile</h3><p>文档：<a href="http://www.cloudera.com/content/cloudera/en/documentation/cloudera-impala/latest/topics/impala_analytic_functions.html#rank_unique_1" target="_blank" rel="external">Rank()</a></p><p>Rank() 可以为原始数据的每一行生成新的一列，值为这一行所在分组的排序 rank； 这样就可以根据 rank 值来保留所需要的 Top N 的行，也可以参考所在分组的总行数，保留 Top n% 的行。</p><p>Example: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span></div><div class="line">    *</div><div class="line"><span class="keyword">FROM</span></div><div class="line">    (</div><div class="line">        <span class="keyword">SELECT</span></div><div class="line">            ut,</div><div class="line">            uid,</div><div class="line">            gid,</div><div class="line">            it,</div><div class="line">            <span class="keyword">RANK</span>() <span class="keyword">OVER</span> (</div><div class="line">                <span class="keyword">PARTITION</span> <span class="keyword">BY</span> gid</div><div class="line">                <span class="keyword">ORDER</span> <span class="keyword">BY</span></div><div class="line">                    it</div><div class="line">            ) <span class="keyword">AS</span> gir</div><div class="line">        <span class="keyword">FROM</span></div><div class="line">            is_daily</div><div class="line">        <span class="keyword">WHERE</span></div><div class="line">            <span class="string">`date=`</span> <span class="string">"20170803"</span></div><div class="line">            <span class="keyword">AND</span> <span class="keyword">is</span> = <span class="string">"f"</span></div><div class="line">    ) <span class="keyword">AS</span> tmp_t</div><div class="line"><span class="keyword">WHERE</span></div><div class="line">    gir &lt; <span class="number">10</span></div><div class="line"><span class="keyword">LIMIT</span></div><div class="line">    <span class="number">100</span></div></pre></td></tr></table></figure><h3 id="使用-NDV-实现快速计数"><a href="#使用-NDV-实现快速计数" class="headerlink" title="使用 NDV() 实现快速计数"></a>使用 NDV() 实现快速计数</h3><p>文档： <a href="http://www.cloudera.com/content/cloudera/en/documentation/cloudera-impala/v2-0-x/topics/impala_ndv.html" target="_blank" rel="external">NDV()</a></p><p>相比 count distinct 更快、更节省内存，但存在误差 (HyperLogLog). 在查询很大的 count distinct，且对准确性要求量级正确即可时，e.g. 月活跃用户(MAU)，可以考虑用 NDV 代替 count distinct.</p><p>NDV() 只能对单列做计数，所以如果需要多列组合计数，需要做一个拼接转换。</p><p>Example: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span></div><div class="line">    ndv(</div><div class="line">        <span class="keyword">concat</span>(</div><div class="line">            <span class="keyword">cast</span>(uid <span class="keyword">AS</span> <span class="keyword">STRING</span>),</div><div class="line">            <span class="string">','</span>,</div><div class="line">            <span class="keyword">cast</span>(user_uid <span class="keyword">AS</span> <span class="keyword">STRING</span>)</div><div class="line">        )</div><div class="line">    )</div><div class="line">)</div><div class="line"><span class="keyword">FROM</span></div><div class="line">    default.isd</div><div class="line"><span class="keyword">WHERE</span></div><div class="line">    <span class="string">`date=`</span> <span class="string">"20170803"</span></div><div class="line">    <span class="keyword">AND</span> <span class="keyword">is</span> = <span class="string">"f"</span></div><div class="line"><span class="keyword">SELECT</span></div><div class="line">    <span class="keyword">count</span>(<span class="keyword">distinct</span> uid, user_uid)</div><div class="line"><span class="keyword">FROM</span></div><div class="line">    default.isd</div><div class="line"><span class="keyword">WHERE</span></div><div class="line">    <span class="string">`date=`</span> <span class="string">"20170803"</span></div><div class="line">    <span class="keyword">AND</span> <span class="keyword">is</span> = <span class="string">"f"</span></div></pre></td></tr></table></figure><h3 id="使用lateral-view和explode展开array嵌套结构"><a href="#使用lateral-view和explode展开array嵌套结构" class="headerlink" title="使用lateral view和explode展开array嵌套结构"></a>使用lateral view和explode展开array嵌套结构</h3><p>对字符串split得到array，再把array展开</p><p>示例：it是字符串，取值样例’refresh,push’</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span></div><div class="line">    uid,</div><div class="line">    ut,</div><div class="line">    it</div><div class="line"><span class="keyword">from</span></div><div class="line">    t LATERAL <span class="keyword">VIEW</span> explode(<span class="keyword">split</span>(it, <span class="string">','</span>)) tb <span class="keyword">as</span> it</div><div class="line"><span class="keyword">where</span></div><div class="line">    <span class="string">`date = `</span> <span class="string">'20161229'</span></div><div class="line"><span class="keyword">limit</span></div><div class="line">    <span class="number">100</span></div></pre></td></tr></table></figure><h3 id="使用lateral-view和explode展开map嵌套结构"><a href="#使用lateral-view和explode展开map嵌套结构" class="headerlink" title="使用lateral view和explode展开map嵌套结构"></a>使用lateral view和explode展开map嵌套结构</h3><p>对value值进行过滤，选取符合要求的keys</p><p>示例：lt_lk_keyword是Map，取值样例{123: 0.1234, 234: 0.2345}</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span></div><div class="line">    uid,</div><div class="line">    ut,</div><div class="line">    <span class="keyword">key</span>,</div><div class="line">    <span class="keyword">value</span></div><div class="line"><span class="keyword">from</span></div><div class="line">    x LATERAL <span class="keyword">VIEW</span> explode(lt_lk_keyword) tb <span class="keyword">as</span> <span class="keyword">key</span>,</div><div class="line">    <span class="keyword">value</span></div><div class="line"><span class="keyword">where</span></div><div class="line">    <span class="string">`date = `</span> <span class="string">'20151229'</span></div></pre></td></tr></table></figure><h3 id="使用lateral-view-和-json-tuple-处理json"><a href="#使用lateral-view-和-json-tuple-处理json" class="headerlink" title="使用lateral view 和 json_tuple 处理json"></a>使用lateral view 和 json_tuple 处理json</h3><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span></div><div class="line">    *</div><div class="line"><span class="keyword">FROM</span></div><div class="line">    (</div><div class="line">        <span class="keyword">select</span></div><div class="line">            *</div><div class="line">        <span class="keyword">from</span></div><div class="line">            x LATERAL <span class="keyword">VIEW</span> json_tuple(extra, <span class="string">"gs"</span>, <span class="string">"uid"</span>) t1 <span class="keyword">as</span> uid,</div><div class="line">            gs</div><div class="line">    ) g</div><div class="line">    <span class="keyword">JOIN</span> default.web_article_item_dict <span class="keyword">as</span> i <span class="keyword">on</span> g.date = i.date</div><div class="line">    <span class="keyword">and</span> g.kid = iid</div><div class="line"><span class="keyword">where</span></div><div class="line">    g.date = <span class="string">"20171016"</span></div><div class="line"><span class="keyword">limit</span></div><div class="line">    <span class="number">10</span></div></pre></td></tr></table></figure><h2 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h2><h3 id="保存查询结果到hive表"><a href="#保存查询结果到hive表" class="headerlink" title="保存查询结果到hive表"></a>保存查询结果到hive表</h3><p>直接以查询结果建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test.tb_abc <span class="keyword">AS</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">distinct</span> uit, uid</div><div class="line">  <span class="keyword">FROM</span> default.isd</div><div class="line">  WHEREdate=<span class="string">"20150803"</span></div></pre></td></tr></table></figure><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><h3 id="创建空Parquet分区表"><a href="#创建空Parquet分区表" class="headerlink" title="创建空Parquet分区表"></a>创建空Parquet分区表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> test.tmp_users1(</div><div class="line">    ut tinyint,</div><div class="line">    uid <span class="built_in">bigint</span></div><div class="line">)</div><div class="line">PARTITIONED <span class="keyword">BY</span> (</div><div class="line">   <span class="string">`date string`</span></div><div class="line">)</div><div class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> PARQUET;</div></pre></td></tr></table></figure><h3 id="基于JSON数据创建外部数据表"><a href="#基于JSON数据创建外部数据表" class="headerlink" title="基于JSON数据创建外部数据表"></a>基于JSON数据创建外部数据表</h3><p>文档：<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-CreateTable" target="_blank" rel="external">CreateTable</a></p><p>Example: 创建包含2个字段的临时外部数据表</p><p>HDFS数据：xx.json。目录中可包含多个文件。json文件内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;'ut': 12, 'uid': 8&#125;</div><div class="line"></div><div class="line">&#123;'ut': 14, 'uid': 12345&#125;</div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> test.tmp_users1(</div><div class="line">    ut tinyint,</div><div class="line">    uid <span class="built_in">bigint</span></div><div class="line">)</div><div class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> SERDE <span class="string">'org.openx.data.jsonserde.JsonSerDe'</span> <span class="keyword">WITH</span> SERDEPROPERTIES (<span class="string">'ignore.malformed.json'</span>=<span class="string">'true'</span>)</div><div class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> TEXTFILE</div><div class="line">LOCATION <span class="string">'/locate'</span>;</div></pre></td></tr></table></figure><h3 id="基于CSV数据创建外部数据表（数据在本地）"><a href="#基于CSV数据创建外部数据表（数据在本地）" class="headerlink" title="基于CSV数据创建外部数据表（数据在本地）"></a>基于CSV数据创建外部数据表（数据在本地）</h3><p>不将数据存储在hdfs，直接从本地load进表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 12,674930234</span></div><div class="line"><span class="comment">-- 14,759234924</span></div><div class="line"></div><div class="line"><span class="comment">-- step1: 建表</span></div><div class="line"></div><div class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> csv_load_test(</div><div class="line">    ut <span class="built_in">bigint</span>,</div><div class="line">    uid <span class="built_in">bigint</span></div><div class="line">)</div><div class="line"><span class="keyword">row</span> <span class="keyword">format</span></div><div class="line"><span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span></div><div class="line"><span class="keyword">stored</span> <span class="keyword">as</span> textfile</div><div class="line"></div><div class="line"><span class="comment">-- step2: load数据</span></div><div class="line"></div><div class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'./test.csv'</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> csv_load_test</div></pre></td></tr></table></figure><h3 id="基于CSV数据创建外部数据表（数据在hdfs）"><a href="#基于CSV数据创建外部数据表（数据在hdfs）" class="headerlink" title="基于CSV数据创建外部数据表（数据在hdfs）"></a>基于CSV数据创建外部数据表（数据在hdfs）</h3><p>文档：<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-CreateTable" target="_blank" rel="external">CreateTable</a></p><p>Example: 创建包含2个字段的临时外部数据表</p><p>HDFS数据：/users.csv。目录中可包含多个文件。csv文件内容，以\t分隔：</p><p>将数据表从hive同步到impala, 在impala执行: invalidate metadata test.source_list_focus;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 12,8</span></div><div class="line"><span class="comment">-- 14,12345</span></div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> test.tmp_users2(</div><div class="line">    ut tinyint,</div><div class="line">    uid <span class="built_in">bigint</span></div><div class="line">)</div><div class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span></div><div class="line"><span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span></div><div class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> TEXTFILE</div><div class="line">LOCATION <span class="string">'/locate'</span>;</div></pre></td></tr></table></figure><h3 id="创建包含map和array结构的临时表："><a href="#创建包含map和array结构的临时表：" class="headerlink" title="创建包含map和array结构的临时表："></a>创建包含map和array结构的临时表：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> test.impala_complex_type_json(</div><div class="line">    <span class="string">`uid string,`</span></div><div class="line">    <span class="string">`properties map,`</span></div><div class="line">    ids<span class="string">` array&lt;int`</span>&gt;)</div><div class="line">    <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span></div><div class="line">      <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span></div><div class="line">      collection items <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span></div><div class="line">      <span class="keyword">map</span> <span class="keyword">keys</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">':'</span></div><div class="line">    <span class="keyword">STORED</span> <span class="keyword">AS</span> TEXTFILE;</div><div class="line"></div><div class="line"><span class="comment">-- local file</span></div><div class="line"></div><div class="line">u1 &#123;"name":"xiaoming","age":"18","gender":"male"&#125; [1,2,3]</div><div class="line"></div><div class="line">u2 &#123;"name":"dagou","age":"18","gender":"female"&#125; [4,5,6]</div><div class="line"></div><div class="line"><span class="comment">-- cli - command</span></div><div class="line"></div><div class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'./a'</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> test.impala_complex_type_json</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      some tips for hive to handle data
    
    </summary>
    
      <category term="Hive" scheme="http://chen-tao.github.io/categories/Hive/"/>
    
    
      <category term="Hive" scheme="http://chen-tao.github.io/tags/Hive/"/>
    
      <category term="Hadoop" scheme="http://chen-tao.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Git submodule Note</title>
    <link href="http://chen-tao.github.io/2017/09/24/Git-submodule-Note/"/>
    <id>http://chen-tao.github.io/2017/09/24/Git-submodule-Note/</id>
    <published>2017-09-24T03:29:54.000Z</published>
    <updated>2017-09-24T03:51:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="add-submodule"><a href="#add-submodule" class="headerlink" title="add submodule"></a>add submodule</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git submodule add --force gitr:service_rpc/idl idl</div></pre></td></tr></table></figure><p>If this repo has not previously been used submodule then Git will create a directory in the directory called <em>.gitmodules</em> , which records the URL of the remote repo and the submodule in this project path.</p><p>After executing this command submodule and <em>.gitmodules</em> will automatically staged, this time can commit and push.</p><h3 id="Update-submodule"><a href="#Update-submodule" class="headerlink" title="Update submodule"></a>Update submodule</h3><p>Individual repo update is too much trouble, it is necessary to separate directory under execution <code>git pull</code>to pull the upstream code, but that would be more secure; all at once to update all of submodule can use this <code>foreach</code>command:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git submodule foreach --recursive git pull origin master</div></pre></td></tr></table></figure><h3 id="Remove-submodule"><a href="#Remove-submodule" class="headerlink" title="Remove submodule"></a>Remove submodule</h3><p>I thought there will be like <code>git submodule rm</code>such an instruction, the result is not even, you must manually remove the hard ground one by one, not knowing what not to implement this directive considerations, I hope that future versions can add to it.</p><p>Remove submodule has the following steps to do, first remove the submodule directory from the version control system:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git rm --cached /path/to/files</div><div class="line">rm -rf /path/to/files</div></pre></td></tr></table></figure><p>Again to modify <em>.gitmodules</em> , remove the <em>unwrought</em> submodule, for example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[submodule &quot;.vim/bundle/vim-gitgutter&quot;] </div><div class="line">  path = .vim/bundle/vim-gitgutter </div><div class="line">  url = git://github.com/airblade/vim-gitgutter.git </div><div class="line">-[submodule &quot;.vim/bundle/vim-autoclose&quot;] </div><div class="line">- path = .vim/bundle/vim-autoclose </div><div class="line">- url = git://github.com/Townk/vim-autoclose.git</div></pre></td></tr></table></figure><p>Not yet finished! But also modify the contents of <em>.git / config</em> , with. <em>Gitmodules</em> , the need to remove the submodule deleted, and finally commit.</p><h3 id="clone-when-the-submodule-together-to-catch-down"><a href="#clone-when-the-submodule-together-to-catch-down" class="headerlink" title="clone when the submodule together to catch down"></a>clone when the submodule together to catch down</h3><p>Implementation of <code>git clone</code>Git clone does not automatically come together when submodule must be added <code>--recursive</code>recursive parameter, so you can catch all associated submodule in submodule down together:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone --recursive git@github.com:chinghanho/.dotfiles.git</div></pre></td></tr></table></figure><p>If you have been caught to find submodule is empty, you can use the following instructions to catch, <code>init</code>will be registered in _.git / config` remote repo URL and local path:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git submodule init</div><div class="line">git submodule update --recursive</div></pre></td></tr></table></figure><p>Or merged into one line <code>git submodule update --init --recursive</code>can, if upstream someone to turn over <em>.gitmodules</em> , it seems that local end also using this method update.</p><h2 id="Explanation-of-instructions"><a href="#Explanation-of-instructions" class="headerlink" title="Explanation of instructions"></a>Explanation of instructions</h2><ul><li><code>git submodule init</code>: According to <em>.gitmodules</em> name and URL, these information will be registered to . *Git *<em>/ config</em> , but not <em>.gitmodules</em> not removed submodule, the use of this directive and no way to automatically delete. <em>Git / config</em> related content, you must manually delete ;</li><li><code>git submodule update</code>: According to registered (that is, <em>.git / config</em> ) submodule to update, such as clone lost submodule, which is the last paragraph of the method, so the implementation of this instruction before the best plus <code>--init</code>;</li><li><code>git submodule sync</code>: If the submodule’s remote URL changes, you can correct the URL in <em>.gitmodules</em> , and then execute this command, the submodule’s remote URL will be corrected.</li></ul>]]></content>
    
    <summary type="html">
    
      项目中使用了git的submodule功能，但突然发现，更新项目或者重写clone项目时，submodule并没有一起更新……这里总结和学习一下submodule相关的功能
    
    </summary>
    
      <category term="Git" scheme="http://chen-tao.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://chen-tao.github.io/tags/Git/"/>
    
      <category term="github" scheme="http://chen-tao.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>使用gvm管理多版本golang</title>
    <link href="http://chen-tao.github.io/2017/09/14/Use-gvm-manage-golang-version/"/>
    <id>http://chen-tao.github.io/2017/09/14/Use-gvm-manage-golang-version/</id>
    <published>2017-09-14T05:36:32.000Z</published>
    <updated>2017-09-24T03:46:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Golang发展迅速，代码迭代非常快，想要调试和梳理项目进程就成了一件相对棘手的事情。偶然间发现了gvm - <a href="http://github.com/moovweb/gvm" target="_blank" rel="external">Go Version Manager</a>，算是找到了调试切换版本的福音。</p><h2 id="关于gvm"><a href="#关于gvm" class="headerlink" title="关于gvm"></a>关于gvm</h2><p>GVM，类似于ruby 中的<a href="https://rvm.io/" target="_blank" rel="external">RVM</a>，java 中的<a href="https://github.com/linux-china/jenv" target="_blank" rel="external">jenv</a>（国产），可用于方便管理 Go 的版本，它有如下几个主要特性：</p><ul><li><p>管理 Go 的多个版本，包括安装、卸载和指定使用 Go 的某个版本</p></li><li><p>查看官方所有可用的 Go 版本，同时可以查看本地已安装和默认使用的 Go 版本</p></li><li><p>管理多个 GOPATH，并可编辑 Go 的环境变量</p></li><li><p>可将当前目录关联到 GOPATH</p></li><li><p>可以查看 GOROOT 下的文件差异</p></li></ul><h2 id="Go-版本切换"><a href="#Go-版本切换" class="headerlink" title="Go 版本切换"></a>Go 版本切换</h2><p>二进制文件的管理比较简单，通过链接使用不同版本的程序即可，实际上主要是一些环境变量和标准库的设置问题，环境变量主要是 GOPATH 以及 GOROOT，标准库的话需要在切换 go 版本时也能跟着切换。gvm 实际上就是帮助完成这些配置工作。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>按照官方文档操作即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)</div><div class="line"><span class="comment"># or</span></div><div class="line">zsh &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)</div></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$ gvm</div><div class="line">Usage: gvm [<span class="built_in">command</span>]</div><div class="line"></div><div class="line">Description:</div><div class="line">  GVM is the Go Version Manager</div><div class="line"></div><div class="line">Commands:</div><div class="line">  version    - <span class="built_in">print</span> the gvm version number</div><div class="line">  get        - gets the latest code (<span class="keyword">for</span> debugging)</div><div class="line">  use        - select a go version to use (--default to <span class="built_in">set</span> permanently)</div><div class="line">  diff       - view changes to Go root</div><div class="line">  <span class="built_in">help</span>       - display this usage text</div><div class="line">  implode    - completely remove gvm</div><div class="line">  install    - install go versions</div><div class="line">  uninstall  - uninstall go versions</div><div class="line">  cross      - install go cross compilers</div><div class="line">  linkthis   - link this directory into GOPATH</div><div class="line">  list       - list installed go versions</div><div class="line">  listall    - list available versions</div><div class="line">  <span class="built_in">alias</span>      - manage go version aliases</div><div class="line">  pkgset     - manage go packages sets</div><div class="line">  pkgenv     - edit the environment <span class="keyword">for</span> a package <span class="built_in">set</span></div></pre></td></tr></table></figure><p>Mac下需要这样一把（如果你的环境有问题的话）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xcode-select --install</div><div class="line">brew update</div><div class="line">brew install mercurial</div></pre></td></tr></table></figure><p>一般常规的操作是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 先列一下看支持哪些版本</span></div><div class="line">gvm listall</div><div class="line"></div><div class="line"><span class="comment"># 看下自己环境有哪些版本</span></div><div class="line">gvm list</div><div class="line"></div><div class="line"><span class="comment"># 安装需要的版本，比如go1.8.3，加--default代表每次再进terminal时默认使用这个版本</span></div><div class="line">gvm install go1.8.3 [--default]</div><div class="line"></div><div class="line"><span class="comment"># 然后看下是否成功</span></div><div class="line">go version</div><div class="line">go env</div><div class="line"></div><div class="line"><span class="comment"># 如果不需要gvm的环境变量，则需要到GVM_ROOT/environments下面去删除</span></div><div class="line"><span class="comment"># 注意是清空文件</span></div><div class="line">&gt; <span class="variable">$GVM_ROOT</span>/environments/go1.8.3</div><div class="line"></div><div class="line"><span class="comment"># 如果需要每次打开terminal都生效的话，以下命令加入到bashrc/zshrc，注意要加在GOPATH/GOROOT的setting之前（如果希望环境变量不被修改的话）</span></div><div class="line"><span class="built_in">source</span> /Users/chentao/.gvm/scripts/gvm</div></pre></td></tr></table></figure><h2 id="几点注意"><a href="#几点注意" class="headerlink" title="几点注意"></a>几点注意</h2><ul><li>在 Linux 下安装 GVM，需要安装相关依赖，详情见<a href="https://github.com/moovweb/gvm" target="_blank" rel="external">官网说明</a></li><li>GVM 官方显示没对 Windows 做支持，考虑到 Windows 不是程序员的标配吧（有同学回复用 git-windows客户端，自带bash功能，可以自行尝试安装下）。</li><li>GVM 安装新版本之后，Go 环境变量会重新设置，为了节约磁盘空间和时间，建议把之前版本的 GOPATH 内容移动到新版本对应的 GOPATH 目录下，相关路径可以通过 go env 获取</li><li>在同一版本下，用 gvm pkgset 创建多个 GOPATH，可能会占用你比较大的磁盘空间</li><li>使用 gvm implode 需谨慎</li><li>GVM 是用 shell 编写</li></ul>]]></content>
    
    <summary type="html">
    
      go版本之间的变化较大，尤其从1.4开始，增删了很多包和相关的代码。使用gvm可以模拟各种版本的go环境，进行相关的代码调试
    
    </summary>
    
      <category term="Golang" scheme="http://chen-tao.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://chen-tao.github.io/tags/Golang/"/>
    
      <category term="gvm" scheme="http://chen-tao.github.io/tags/gvm/"/>
    
  </entry>
  
  <entry>
    <title>如何安全删除Github上的commit历史</title>
    <link href="http://chen-tao.github.io/2017/09/14/How-to-delete-github-history/"/>
    <id>http://chen-tao.github.io/2017/09/14/How-to-delete-github-history/</id>
    <published>2017-09-14T03:22:16.000Z</published>
    <updated>2017-09-14T03:29:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Remove the history from </span></div><div class="line">rm -rf .git</div><div class="line"></div><div class="line"><span class="comment"># recreate the repos from the current content only</span></div><div class="line">git init</div><div class="line">git add .</div><div class="line">git commit -m <span class="string">"Initial commit"</span></div><div class="line"></div><div class="line"><span class="comment"># push to the github remote repos ensuring you overwrite history</span></div><div class="line">git remote add origin git@github.com:&lt;YOUR ACCOUNT&gt;/&lt;YOUR REPOS&gt;.git</div><div class="line">git push -u --force origin master</div></pre></td></tr></table></figure><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git checkout --orphan newBranch</div><div class="line">git add -A  <span class="comment"># Add all files and commit them</span></div><div class="line">git commit</div><div class="line">git branch -D master  <span class="comment"># Deletes the master branch</span></div><div class="line">git branch -m master  <span class="comment"># Rename the current branch to master</span></div><div class="line">git push -f origin master  <span class="comment"># Force push master branch to github</span></div><div class="line">git gc --aggressive --prune=all     <span class="comment"># remove the old files</span></div></pre></td></tr></table></figure><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><blockquote><p>Delete Github Repo = = ,that’s a sad but useful way to totally delete<br>Warning : solution 1&amp;2 not delete pull request history (discussion, file changes). If you do this in order to delete sensitive data, you should better delete the github repo (along with all its pull request history etc..) and recreate a new one from scratch.</p></blockquote><h2 id="Finnaly"><a href="#Finnaly" class="headerlink" title="Finnaly"></a>Finnaly</h2><p>说了半天，其实还是直接删除repo最安全…… 前两种我理解，大概是指向删除了，并没做物理删除。 = = SAD</p><p><em>EOF</em></p>]]></content>
    
    <summary type="html">
    
      有时候确实会有这种需求，摆烂的历史，或者，敏感信息的移除
    
    </summary>
    
      <category term="Github" scheme="http://chen-tao.github.io/categories/Github/"/>
    
    
      <category term="git" scheme="http://chen-tao.github.io/tags/git/"/>
    
      <category term="Github" scheme="http://chen-tao.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Golang Workers / Job Queue</title>
    <link href="http://chen-tao.github.io/2017/09/11/Golang-Workers-Job-Queue/"/>
    <id>http://chen-tao.github.io/2017/09/11/Golang-Workers-Job-Queue/</id>
    <published>2017-09-11T12:09:39.000Z</published>
    <updated>2017-09-11T12:15:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>A running example of the code from:</p><ul><li><a href="http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang" target="_blank" rel="external">http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang</a></li><li><a href="http://nesv.github.io/golang/2014/02/25/worker-queues-in-go.html" target="_blank" rel="external">http://nesv.github.io/golang/2014/02/25/worker-queues-in-go.html</a></li></ul><p>This gist creates a working example from blog post, and a alternate example using simple worker pool.</p><p>TLDR: if you want simple and controlled concurrency use a <a href="https://gist.github.com/harlow/49318d54f45d29f1a77cc641faf14054" target="_blank" rel="external">worker pool</a>.</p><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>Small refactorings made to original code:</p><ul><li>Use non-exported private methods</li><li>Remove global variables</li><li>Bring the flags closer to their usage in <code>main()</code> from <a href="https://robots.thoughtbot.com/where-to-define-command-line-flags-in-go" target="_blank" rel="external">where to define flags in program</a>.</li></ul><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>Simplify the worker queue by removing the <code>Dispatcher</code>.</p><ul><li>Creates workers directly and passes job queue to them</li></ul><p><a href="https://gist.github.com/harlow/dbcd639cf8d396a2ab73#file-worker_refactored-go" target="_blank" rel="external">https://gist.github.com/harlow/dbcd639cf8d396a2ab73#file-worker_refactored-go</a></p><h2 id="Run-the-Application"><a href="#Run-the-Application" class="headerlink" title="Run the Application"></a>Run the Application</h2><p>Boot either the <code>worker_original.go</code> or the <code>worker_refactored.go</code> applications. Use flags to adjust the <code>max_workers</code> and <code>max_queue_size</code> to override the default values.</p><pre><code>$ go run worker_original.go -max_workers 5</code></pre><p>cURL the application from another terminal window:</p><pre><code>$ for i in {1..15}; do curl localhost:8080/work -d name=job$i -d delay=$(expr $i % 9 + 1)s; done</code></pre><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>The test run with Pprof show performance characteristics remain the same between both examples.</p><h2 id="Code-Time"><a href="#Code-Time" class="headerlink" title="Code Time"></a>Code Time</h2><script src="https://gist.github.com/Chen-tao/69d3dd7202dba1beb8abedf6fe712308.js"></script>]]></content>
    
    <summary type="html">
    
      看 otium/queue 如何用go实现的后台处理任务队列
    
    </summary>
    
      <category term="Golang" scheme="http://chen-tao.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://chen-tao.github.io/tags/Golang/"/>
    
      <category term="MQ" scheme="http://chen-tao.github.io/tags/MQ/"/>
    
      <category term="消息队列" scheme="http://chen-tao.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Golang 如何确定App是否运行在Docker内</title>
    <link href="http://chen-tao.github.io/2017/09/11/Go-check-if-app-running-in-docker/"/>
    <id>http://chen-tao.github.io/2017/09/11/Go-check-if-app-running-in-docker/</id>
    <published>2017-09-11T05:48:47.000Z</published>
    <updated>2017-09-11T06:13:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景</p><p>项目需要隔离部署，如果在docker环境需要使用一些特殊的配置，之前没有太好的判别方法，现在总结一下。</p></blockquote><h2 id="V1-使用-dockerenv判断"><a href="#V1-使用-dockerenv判断" class="headerlink" title="V1 使用/.dockerenv判断"></a>V1 使用<code>/.dockerenv</code>判断</h2><p>如果是Docker容器内，根目录会生成一个可执行的<code>/.dockerenv</code>文件，判断此文件是否存在可以基本断定是否运行内容器内，注意是“基本”，极少数的发行版或者某些定制化较高的系统，可能会不存在此文件。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> DOCKERENV_FILE <span class="keyword">string</span> = <span class="string">"/.dockerenv"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathExist</span><span class="params">(_path <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">_, err := os.Stat(_path)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; os.IsNotExist(err) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> pathExist(DOCKERENV_FILE) &#123;</div><div class="line">logs.Warn(<span class="string">"Running in Docker, not check for now..."</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="V2-使用cgroup信息进行判断"><a href="#V2-使用cgroup信息进行判断" class="headerlink" title="V2 使用cgroup信息进行判断"></a>V2 使用<code>cgroup</code>信息进行判断</h2><p>Docker在Xnix下虚拟环境，使用了cgroup，容器内的group信息与物理机会有本质不同，可以根据Docker内特殊化的环境信息进行判断，这也是目前最靠谱的方案。</p><p>正常情况下物理机的cgroup:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> cat /proc/1/cgroup</span></div><div class="line">9:blkio:/</div><div class="line">8:devices:/</div><div class="line">7:freezer:/</div><div class="line">6:cpuset:/</div><div class="line">5:memory:/</div><div class="line">4:cpu,cpuacct:/</div><div class="line">3:perf_event:/</div><div class="line">2:net_cls,net_prio:/</div><div class="line">1:name=systemd:/</div></pre></td></tr></table></figure><p>Docker内的cgroup(例子)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> cat /proc/1/cgroup </span></div><div class="line">10:freezer:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c</div><div class="line">9:memory:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c</div><div class="line">8:cpuset:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c</div><div class="line">7:pids:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c</div><div class="line">6:devices:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c/init.scope</div><div class="line">5:blkio:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c</div><div class="line">4:cpu,cpuacct:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c</div><div class="line">3:perf_event:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c</div><div class="line">2:net_cls,net_prio:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c</div><div class="line">1:name=systemd:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c/init.scope</div></pre></td></tr></table></figure><p>判断响应内容即可，一般情况下，主要看<code>name</code> &amp; <code>devices</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">Need Pkg:</span></div><div class="line"><span class="comment">    cgroup "github.com/containerd/cgroups"</span></div><div class="line"><span class="comment">    units "github.com/docker/go-units"</span></div><div class="line"><span class="comment">specs "github.com/opencontainers/runtime-spec/specs-go"</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    paths, err := parseCgroupFile(<span class="string">"/proc/1/cgroup"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">t.Fatal(err)</div><div class="line">&#125;</div><div class="line">dp := strings.TrimPrefix(paths[<span class="string">"devices"</span>], <span class="string">"/"</span>)</div><div class="line">path := PidPath(os.Getpid())</div><div class="line">p, err := path(<span class="string">"devices"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">t.Fatal(err)</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> p != filepath.Join(<span class="string">"/"</span>, dp) &#123;</div><div class="line">t.Fatalf(<span class="string">"expected self path of %q but received %q"</span>, filepath.Join(<span class="string">"/"</span>, dp), p)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="V3-拓展"><a href="#V3-拓展" class="headerlink" title="V3 拓展"></a>V3 拓展</h2><p>如果需要当前协程的父进程信息，会对我们定位很多关键信息起到很大的帮助</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> processNameFormat = <span class="string">"/proc/%d/comm"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">fmt.Println(os.Getppid())</div><div class="line"></div><div class="line">ppid := os.Getppid()</div><div class="line"></div><div class="line">bs, err := ioutil.ReadFile(fmt.Sprintf(processNameFormat, ppid))</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Println(err.Error())</div><div class="line">&#125;</div><div class="line">    fmt.Println(<span class="keyword">string</span>(bs)) <span class="comment">// bs is ppid info</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>EOF</p></blockquote>]]></content>
    
    <summary type="html">
    
      几种判断Golang App当前运行环境的方法
    
    </summary>
    
      <category term="Golang" scheme="http://chen-tao.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://chen-tao.github.io/tags/Golang/"/>
    
      <category term="Docker" scheme="http://chen-tao.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>WTF hexo</title>
    <link href="http://chen-tao.github.io/2017/08/27/WTF-hexo/"/>
    <id>http://chen-tao.github.io/2017/08/27/WTF-hexo/</id>
    <published>2017-08-27T12:14:51.000Z</published>
    <updated>2017-09-11T05:36:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>真的不知道出了什么问题，突然这个hexo就不好用了，也许是我太久没用了吧 = = </p><p>昨天开始一直报错，找不到某个Trace，另外有一点我不太明白，deploy的时候替我提交了，那为何我本地还有这么多修改。</p><p>问题很多，但是确实很多没到这边来了，我的个人页也莫名其妙丢失了，SAD。</p><p>以上です。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;真的不知道出了什么问题，突然这个hexo就不好用了，也许是我太久没用了吧 = = &lt;/p&gt;
&lt;p&gt;昨天开始一直报错，找不到某个Trace，另外有一点我不太明白，deploy的时候替我提交了，那为何我本地还有这么多修改。&lt;/p&gt;
&lt;p&gt;问题很多，但是确实很多没到这边来了，我的
      
    
    </summary>
    
    
      <category term="感悟" scheme="http://chen-tao.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>告别腾讯-一点总结</title>
    <link href="http://chen-tao.github.io/2017/03/14/about-tencent/"/>
    <id>http://chen-tao.github.io/2017/03/14/about-tencent/</id>
    <published>2017-03-14T07:39:23.000Z</published>
    <updated>2017-09-11T05:36:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>鹅厂工作届满三年，明天即将离开，写一点自己的感受，希望能看到一些东西，也不被一些东西所影响。</p><a id="more"></a><h3 id="Leave"><a href="#Leave" class="headerlink" title="Leave"></a>Leave</h3><p>业内讲<strong>金山银四</strong>，我也到了发痒的年纪了。一方面有家庭上的原因，另一方面，也觉得北京发展的潜力远远大于深圳，机会也多得多，于是，过年期间准备了一下，拿到了今日头条的offer，即将在北京开始新的生活了。</p><h3 id="SNG"><a href="#SNG" class="headerlink" title="SNG"></a>SNG</h3><p>2014年毕业来到腾讯SNG(社交网络事业群)，做泛QQ方向的业务，在SNG内算是比较新的业务，老板也相对重视；但从整个公司的角度看来，SNG的优势都不太大，以至于我们经常自我调侃：CDG&amp;WXG天之骄子，IEG游戏土豪，OMG一门三杰，TEG养老送终，剩下SNG吭哧吭哧的干活儿，却不知道未来在何方。</p><h3 id="Engineering-Culture"><a href="#Engineering-Culture" class="headerlink" title="Engineering Culture"></a>Engineering Culture</h3><p>作为一个后端server研发，其实大多数时候是不会带入到公司大的场景中去的，但腾讯是一家特殊的公司，是一家以<strong>产品为导向</strong>的公司，每个人都<strong>有</strong>或者说<strong>需要有</strong>那么一点产品意识，这样的结果是：一方面产品在进化发展，产品运营开发测试，每个人对业务的理解更透彻了；另一方面，对技术不那么感冒，甚至可以说，<strong>工程师文化，在腾讯销声匿迹了</strong>，也不能说没有，而是被忽略掉了。</p><p>对于大部分员工来说，KPI还是很重要的，而落实到每个人身上，很可能就是如果快速的解决某个问题，达到某个目的，一件事情做完之后，回头看的机会真的不多，业务在前进，人也一样——在业务飞速前进的大背景下，从Demo改到V3V4，是一件很痛苦的事情，甚至在一些团队变成了不切实际的行动。这样的结果是：<strong>对于大多数非核心部门而言，资源是非常有限的，新的老的业务问题都不一定能搞定，自然无法将资源投放在解决工作效率与代码质量的问题上。半年一次的KPI考评，则从另一个更重要的方面去促使员工选择去解决最能体现价值的业务问题。长期的收敛结果，就是基础设施碎片化、野蛮化生长。</strong></p><h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3><p>DevOps在腾讯，大部分部门都是很空白的。</p><p>代码权限严格，网络权限一年比一年收紧，测试环境(SecureCRT 甚至加上 sz/rz)产能底下，很多生产力工具没提供比如Mac无法申请(其实比某些台式机便宜多了)，很多老员工用着落后其他公司一个时代的硬件产品，追赶着行业领先的技术，这种戴着镣铐跳舞的感觉，很多时候实在让人无奈。</p><p>在SNG内部，经过近几年的发展，是有集成化运维这类的东西的，但仍然不够，很多重复的事情，仍然不得不人肉，而且还有一些非常蛋疼的规范限制着你——比如通过内部系统，每人每天每个pkg只能pub一次，你pub过就只能找其他同事帮忙，不然就上了本月的研发黑榜 = =||，本人有幸连续三个月上榜过。</p><p>另外，腾讯里，很多新团队开发的自动化组件，没有人去用，或者用的很少，推行起来也是困难重重，部门之间，业务不同，KPI没有交集，互帮互助都显得异常珍贵，团队之间，尤其是<em>有点历史</em>的团队之间，技术栈是大相径庭的，要他们容和统一，短时间内实在也不太现实，而长期来看，团队技术栈成型后，他们更倾向于Hire那些符合他们技术点要求的人，而不是能力相当的人，如何循环，再去改造就更加困难了；对比阿里巴巴，内部其实没有特别大的决心去推动一些东西，有学长在阿里中间件工作，基本上集团内推行一种新技术是非常容易的，JDK6到7到8，遇到的阻力也无非是一些必经之路上的技术问题，而不是该不该用好不好用的扯皮，这些问题是腾讯需要思考的。</p><p><strong>说了这么多，从我工程师的角度看，腾讯在产品上确实冠绝业界，但在工程技术上，要走的路还很远很曲折。</strong></p><h3 id="Benefit"><a href="#Benefit" class="headerlink" title="Benefit"></a>Benefit</h3><p>讲完技术，讲点福利。腾讯的福利非常之好，包含了衣食住行的方方面面，每年的旅行团建，夜宵，兑换，住房保障计划，无息贷款，覆盖全深圳堪比中型城市公交系统的班车服务，逢年过节的红包，结婚生育的礼金，甚至给下一代的VIPQQ号……<strong>对于职场新人来说，确实是一家非常值得加入的公司；对于职业暮年的人来说，则可能是可以颐养天年的公司；而对于其他员工，我觉得就因人而异了，可能要看具体工作的方向，部门，和个人对工作的理解了。</strong></p><h3 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h3><p>毕业的三年是一个非常重要的职业阶段，在腾讯我成长了非常多，也学会了很多，感谢与我一同工作的同事们，他们对我的协助，对我的指导，我都铭记于心；而我在腾讯文化的熏陶下，也完成了从一个青涩学生到一个工程师的转变，这些，都是我职业道路上毕生的财富。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鹅厂工作届满三年，明天即将离开，写一点自己的感受，希望能看到一些东西，也不被一些东西所影响。&lt;/p&gt;
    
    </summary>
    
    
      <category term="感悟" scheme="http://chen-tao.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>从jekyll到hexo</title>
    <link href="http://chen-tao.github.io/2017/03/09/move-to-hexo/"/>
    <id>http://chen-tao.github.io/2017/03/09/move-to-hexo/</id>
    <published>2017-03-09T09:39:10.000Z</published>
    <updated>2017-09-11T05:36:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前折腾了很多次jekyll，不管是评论，还是文章目录，都很不顺手，<strong>这次花了一天，迁移到了hexo</strong></p><p>开始是nodejs的组件报错，某些文章里有特殊的jekyll使用的字符等等，这个就折腾了半天 = = </p><p>然后是git的rebase出问题，差点崩溃，还好解决了</p><p>官网上关于迁移就是这短短的一句话：</p><p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fdgqabh8i6j31520aot9u.jpg" alt=""></p><p>结果却不是这样 = = </p><p>这边选择了next主题，觉得不错，喜欢的可以看下，后面有时间，也会折腾一下主题(可能有坑 = = )</p><p>新开始！</p>]]></content>
    
    <summary type="html">
    
      刀耕火种结束，顺利进入自动化时代。
    
    </summary>
    
    
      <category term="jekyll" scheme="http://chen-tao.github.io/tags/jekyll/"/>
    
      <category term="hexo" scheme="http://chen-tao.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm Anaysis</title>
    <link href="http://chen-tao.github.io/2017/02/08/algo-pic/"/>
    <id>http://chen-tao.github.io/2017/02/08/algo-pic/</id>
    <published>2017-02-07T16:00:00.000Z</published>
    <updated>2017-09-11T05:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/006tKfTcgy1fcivc207a8j319z0pwq8b.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/006tKfTcgy1fcivc207a8j319z0pwq8b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法" scheme="http://chen-tao.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SOA面向服务架构浅析</title>
    <link href="http://chen-tao.github.io/2017/02/01/soa-and-micro-service/"/>
    <id>http://chen-tao.github.io/2017/02/01/soa-and-micro-service/</id>
    <published>2017-01-31T16:00:00.000Z</published>
    <updated>2017-09-11T05:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SOA定义"><a href="#SOA定义" class="headerlink" title="SOA定义"></a>SOA定义</h2><p>SOA是一个组件模型，它将应用程序的不同功能单元(称为服务)通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种这样的系统中的服务可以以一种统一和通用的方式进行交互。</p><p>这种具有中立的接口定义(没有强制绑定到特定的实现上)的特征称为服务之间的松耦合。<strong>SOA的目的，就是要将复杂的紧耦合的系统进行解耦，划分成面向业务的，细粒度，松耦合，无状态的服务。</strong>松耦合系统的好处有两点，一点是它的灵活性，另一点是，当组成整个应用程序的每个服务的内部结构和实现逐渐地发生改变时，它能够继续存在。而另一方面，紧耦合意味着应用程序的不同组件之间的接口与其功能和结构是紧密相连的，因而当需要对部分或整个应用程序进行某种形式的更改时，它们就显得非常脆弱，变更可能会导致部分乃至整个系统的重构。</p><p>对松耦合的系统的需要来源于业务应用程序需要根据业务的需要变得更加灵活，以适应不断变化的环境，比如经常改变的政策、业务级别、业务重点、合作伙伴关系、行业地位以及其他与业务有关的因素，这些因素甚至会影响业务的性质。我们称能够灵活地适应环境变化的业务为按需(On demand)业务，在按需业务中，一旦需要，就可以对完成或执行任务的方式进行必要的更改。</p><p>SOA是传统的面向对象架构模型的替代模型，面向对象的模型是紧耦合的，已经存在二十多年了。虽然基于 SOA 的系统并不排除使用面向对象的设计来构建单个服务，但是其整体设计却是面向服务的。由于它考虑到了系统内的对象，所以虽然 SOA 是基于对象的，但是作为一个整体，它却不是面向对象的。不同之处在于接口本身。SOA 系统原型的一个典型例子是通用对象请求代理体系结构(Common Object Request Broker Architecture，CORBA)，它已经出现很长时间了，其定义的概念与 SOA 相似。</p><p>然而，现在的 SOA 已经有所不同了，因为它依赖于一些更新的进展，这些进展是以可扩展标记语言(eXtensible Markup Language，XML)为基础的。通过使用基于 XML 的语言(称为 Web 服务描述语言(Web Services Definition Language，WSDL))来描述接口，服务已经转到更动态且更灵活的接口系统中，非以前 CORBA 中的接口描述语言(Interface Definition Language，IDL)可比了。更新的，如protobuf，Thrift等标记语言，则已经在RPC与其他服务协议中占有极为重要的角色。</p><p>Web 服务并不是实现 SOA 的惟一方式。前面刚讲的 CORBA 是另一种方式，这样就有了面向消息的中间件(Message-Oriented Middleware)系统。但是为了建立体系结构模型，您所需要的并不只是服务描述。您需要定义整个应用程序如何在服务之间执行其工作流。您尤其需要找到业务的操作和业务中所使用的软件的操作之间的转换点。因此，SOA 应该能够将业务的商业流程与它们的技术流程联系起来，并且映射这两者之间的关系。例如，给供应商付款的操作是商业流程，而更新您的零件数据库，以包括进新供应的货物却是技术流程。因而，工作流还可以在 SOA 的设计中扮演重要的角色。</p><p>此外，动态业务的工作流不仅可以包括部门之间的操作，甚至还可以包括与不为您控制的外部合作伙伴进行的操作。因此，为了提高效率，您需要定义应该如何得知服务之间的关系的策略，这种策略常常采用服务级协定和操作策略的形式。</p><p>最后，所有这些都必须处于一个信任和可靠的环境之中，以同预期的一样根据约定的条款来执行流程。因此，安全、信任和可靠的消息传递应该在任何 SOA 中都起着重要的作用。</p><h2 id="SOA原则"><a href="#SOA原则" class="headerlink" title="SOA原则"></a>SOA原则</h2><p>FROM <a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84" target="_blank" rel="external">WIKI</a></p><p>以下指导原则是开发，维护和使用SOA的基本原则：</p><ul><li>可重复使用, 粒度, 模组性, 可组合型, 物件化原件, 构件化以及具交互操作性</li><li>符合开放标准(通用的或行业的)</li><li>服务的识别和分类，提供和发布，监控和跟踪。</li></ul><p>下面是一些特定的体系架构原则：</p><ul><li>服务封装</li><li>服务松耦合(Loosely coupled) – 服务之间的关系最小化，只是互相知道。(Decouple Infrastructure)</li><li>服务契约 - 服务按照服务描述文档所定义的服务契约行事。</li><li>服务抽象 - 除了服务契约中所描述的内容，服务将对外部隐藏逻辑。</li><li>服务的重用性 - 将逻辑分布在不同的服务中，以提高服务的重用性。</li><li>服务的可组合性 - 一组服务可以协调工作并组合起来形成一个组合服务。</li><li>服务自治 – 服务对所封装的逻辑具有控制权</li><li>服务无状态 – 服务将一个活动所需保存的资讯最小化。</li><li>服务的可被发现性 – 服务需要对外部提供描述资讯，这样可以通过现有的发现机制发现并访问这些服务。[4]</li></ul><p>除此以外，在定义一个SOA实现时，还需要考虑以下因素：</p><ul><li>生命周期管理</li><li>有效使用系统资源</li><li>服务成熟度和性能</li></ul><h2 id="SOA用途"><a href="#SOA用途" class="headerlink" title="SOA用途"></a>SOA用途</h2><p>对 SOA 的需要来源于需要使业务 IT 系统变得更加灵活，以适应业务中的改变。通过允许强定义的关系和依然灵活的特定实现，IT 系统既可以利用现有系统的功能，又可以准备在以后做一些改变来满足它们之间交互的需要。</p><p>改变和 SOA 系统适应改变的能力是最重要的部分。对于开发人员来说，这样的改变无论是在他们工作的范围之内还是在他们工作的范围之外都有可能发生，这取决于是否有改变需要知道接口是如何定义的以及它们相互之间如何进行交互。与开发人员不同的是，架构师的作用就是引起对 SOA 模型大的改变。这种分工，就是让开发人员集中精力于创建作为服务定义的功能单元，而让架构师和建模人员集中精力于如何将这些单元适当地组织在一起。</p><h2 id="SOA与微服务"><a href="#SOA与微服务" class="headerlink" title="SOA与微服务"></a>SOA与微服务</h2><p>相比于基于业务的SOA，微服务则纯粹基于服务模块，也就是每个服务独立为一个子系统，平行扩容对其他服务透明，强调系统的伸缩性，服务发现，负载均衡，故障转移，高可用。微服务是互联网时代的新产物，它对服务的容错与可用提出了更新的思考，比如多版本，灰度发布，服务降级，分布式跟踪，这些都是SOA在实践中重视不够的地方，。</p><p>SOA在企业领域的应用更为广泛，对服务的可用性保证也很高，而很多现代互联网企业，对实时性的要求，对数据一致性的要求，甚至对大流量下可用性的要求都是弹性的，比如腾讯，很多业务服务的运营核心是：有损服务，动态运营，这时候，微服务的作用就显现出来，在海量请求下，尽量保证大多数用户的服务，尽量快（弱一致性）的实现数据的同步。可以说，SOA与微服务在不同的领域，但做法可以相互借鉴。</p>]]></content>
    
    <summary type="html">
    
      SOA面向服务架构的一点自我分析，同时对比一下SOA与微服务，互相借鉴，有的放失。
    
    </summary>
    
      <category term="感悟" scheme="http://chen-tao.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="server" scheme="http://chen-tao.github.io/tags/server/"/>
    
      <category term="服务" scheme="http://chen-tao.github.io/tags/%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>quick sort快速排序算法总结 </title>
    <link href="http://chen-tao.github.io/2017/01/28/quick-sort/"/>
    <id>http://chen-tao.github.io/2017/01/28/quick-sort/</id>
    <published>2017-01-27T16:00:00.000Z</published>
    <updated>2017-09-11T05:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天总结一下非常有用的快速排序(qsort)算法, 以及由此衍生的一些其他相关算法(Knuth shuffle, quick select, 3-way partition).</p><p>快速排序的算法可以用三句话描述:<br><strong>[Algo]</strong></p><blockquote><ul><li>选择基准项(pivot element, 一般取第一个元素为pivot)</li><li>把数组里所有小于pivot的移动到pivot左边, 大于pivot的移动到右边 ⇒ 此时pivot已经位于最终排序时的正确位置</li><li>对pivot左右两个数组分别递归进行快速排序</li></ul></blockquote><p>由以上描述可见, qsort是一个递归算法, 我们可以把它的函数声明写成: <code>void qsort(int[] a, int lo, int hi)</code>, 表示排序a[lo, hi]之间(闭区间)的所有元素.</p><h2 id="quick-partition"><a href="#quick-partition" class="headerlink" title="quick partition"></a>quick partition</h2><p>由上面描述可以见, qsort最关键的是第二步: 把数组元素以pivot分为两部分. 这个操作就是quick partition.</p><p>函数声明为: <code>int partition(int[] a, int lo, int hi)</code>, 该函数返回pivot(即subarray的第一个元素<code>a[lo]</code>)所在的位置.</p><p>如果允许新建一个临时数组的话, 那么这个就不是什么问题, 但是为了节约空间占用, 现在需要直接修改(in-place)使得a[lo] 到, 而且希望可以用尽量少的交换(<code>swap(int[]a, int i, int j)</code>)操作, 就不是很evident了.</p><p>这个函数的写法是用两个指针i和j分别从两端向中间走, 如果两个指针指向的元素一个小于pivot一个大于pivot那么就进行交换, 当两个指针碰面的时候结束(最后把pivot和指针元素交换). 请看下面这个萌萌的图(图片来自&lt;&lt;啊哈!算法&gt;&gt;):<br><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7ns2lgb3j30f005p3yp.jpg" alt=""></p><p>选取第一个元素(6)为pivot, 然后j向左走直到遇到一个小于pivot(6)的数停止, i向右走直到遇到一个大于pivot的数停止(<em>注意要让j先移动</em>), 此时二者交换:<br><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7nsfvemtj30dm0a83yz.jpg" alt=""></p><p>只要重复这个过程, 直到i&gt;=j为止, 此时只要最后把pivot和j(<em>注意是j而不是i</em>)指向的元素交换即可:<br><img src="https://ww2.sinaimg.cn/large/006tNbRwgy1fc7nsr0uuxj30dp0bidga.jpg" alt=""></p><p>所以pivot的位置就是j, 函数返回j即可.</p><p>java实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;  </div><div class="line">    <span class="keyword">int</span> pivot = a[lo], i=lo, j=hi;  </div><div class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </div><div class="line">        <span class="keyword">for</span>(;j&gt;=lo &amp;&amp; a[j]&gt;=pivot;j--);<span class="comment">// move j to a point where a[j]&lt;pivot  </span></div><div class="line">        <span class="keyword">for</span>(;i&lt;=hi &amp;&amp; a[i]&lt;=pivot;i++);<span class="comment">// move i to a point where a[i]&gt;pivot  </span></div><div class="line">        <span class="keyword">if</span>(i&gt;=j) <span class="keyword">break</span>;<span class="comment">// break if i and j meets  </span></div><div class="line">        swap(a, i++, j--);  </div><div class="line">    &#125;  </div><div class="line">    swap(a, lo, j);<span class="comment">// swap pivot with a[j]  </span></div><div class="line">    <span class="keyword">return</span> j;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里有几点要注意的:</p><ul><li>让j先移动</li><li>最后pivot要和j交换而不是和i交换: 因为最后放在最左边的应该是一个小于pivot的数嘛</li><li>移动的时候别忘了需要加数组下标的边界检查(<code>i&lt;=hi</code>, <code>j&gt;=lo</code>)</li><li>partition()的复杂度是线性的<strong>O(n)</strong></li></ul><h2 id="Knuth-shuffle"><a href="#Knuth-shuffle" class="headerlink" title="Knuth shuffle"></a>Knuth shuffle</h2><p>qsort之所以快, 是因为每次都能够按照pivot分为大致同样长度的两个子数组(所以每次子问题的规模除以二), 所以复杂度为<strong>O(NlogN)</strong>. 最坏情况下, 如果每次两个子数组中可能有一个长度为0, 那么每次子问题的规模只减少了1, 所以复杂度变成了quadratic <strong>O(N2)</strong>.</p><p>为了防止这种最坏情况的出现, 可以在一切开始之前把数组打乱顺序, 所以这一节讨论快速shuffle的算法. 最经典的就是Knuth的shuffle算法了, 算法很简答, 描述为: for(k=1 to n): 每次把第k个元素和前k个元素中的随机一个元素交换.</p><p>代码只有两行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;  </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> K=<span class="number">0</span>; K&lt;a.length; K++)  </div><div class="line">        swap(K, Random.nextInt(K+<span class="number">1</span>));  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>关于算法的正确性, 其实只要证明”元素i在shuffle后最终位于位置i”的概率为1/N即可, 不难证明.</p><h2 id="quick-sort"><a href="#quick-sort" class="headerlink" title="quick sort"></a>quick sort</h2><p>好了 有了以上两个辅助函数就可以写qsort函数了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;<span class="comment">//recursive helper function  </span></div><div class="line">    <span class="keyword">if</span>(lo&gt;=hi) <span class="keyword">return</span>;  </div><div class="line">    <span class="keyword">int</span> p = partition(a, lo, hi);  </div><div class="line">    qsort(a, lo, p-<span class="number">1</span>);  </div><div class="line">    qsort(a, hi, p+<span class="number">1</span>);  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;  </div><div class="line">    shuffle(a);  </div><div class="line">    qsort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其实qsort的主体就是那个partition函数, 单独把partition列出来是因为它不止可以用在排序, 还可以用来做quick select, 见quick select节.</p><h2 id="quick-select"><a href="#quick-select" class="headerlink" title="quick select"></a>quick select</h2><p><em>对于一个没有排序的数组, 如何快速找到它的中值(median)?</em><br>以上这个问题的答案就在<code>partition()</code>函数.</p><p>之前说过, <code>partition()</code>函数的返回值表示pivot在排序好的数组中的位置(rank), 这个消息非常有用: 中值只不过是rank等于长度除以2的元素而已.</p><p>为了寻找rank等于k的元素, 我们用partition函数可以每次把问题规模缩小: 如果partition()=pk那么右边subarray不用考虑, 如果数组事先shuffle过了的话, 问题规模每次缩小一半.</p><p>定义一个函数, 寻找rank等于k的元素, 代码类似于二分查找:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int findKth(int[] a, int k)&#123;  </div><div class="line">    shuffle(a);  </div><div class="line">    int lo=0, hi=a.length-1;  </div><div class="line">    while(lo&lt;hi)&#123;  </div><div class="line">    int p = partition(a, lo, hi);  </div><div class="line">    if(p==k) return a[k];  </div><div class="line">    else if(p&lt;k) lo=p+1;  </div><div class="line">    else hi=p-1;  </div><div class="line">    &#125;  </div><div class="line">    return a[k];  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该算法内层循环为O(hi-lo), 每次问题规模减少一半, 所以复杂度为N+N/2+N/4+…+1 = 2N, 复杂度为线性时间!</p><h2 id="3-way-qsort"><a href="#3-way-qsort" class="headerlink" title="3-way qsort"></a>3-way qsort</h2><p>qsort之前有个bug: 在数组里很多重复元素的时候, 效率会下降为O(N2). 原因是qsort没有好好处理重复元素的问题.</p><p>于是Dijkstra提出了一个<strong>3-way partition</strong>的算法: 把数组分为三部分: 左边<code>[lo, lt)</code>严格小于pivot, 中间<code>[lt, gt]</code>等于pivot, 右边<code>(gt, hi]</code>严格大于pivot.</p><p>算法初始化<code>lt=lo, gt=hi, i=lo</code>, 用指针i向右扫描, [i,gt]为未处理到的部分.<br>算法很subtle, invariant是这样的:</p><blockquote><ul><li>a[lo,lt-1] &lt; pivot</li><li>a[lt, i-1] = pivot</li><li>a[i,gt] = unseen</li><li>a[gt+1, hi] &gt; pivot</li></ul></blockquote><p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fc7nt1aur7j309k03gq2v.jpg" alt=""><br>这个图很有助于写代码:<br><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7nta4jkzj308704s0sr.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort3way</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;  </div><div class="line">    <span class="keyword">if</span>(hi&lt;=lo) <span class="keyword">return</span>;  </div><div class="line">    <span class="keyword">int</span> lt=lo, i=lo, gt=hi, pivot=a[lo];  </div><div class="line">    <span class="keyword">while</span> (i&lt;=gt)&#123;<span class="comment">// [i,gt] is unseen elements  </span></div><div class="line">        <span class="keyword">if</span>(a[i]==pivot) <span class="comment">//a[lt,i-1] are elements == pivot  </span></div><div class="line">            i++;  </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;pivot) <span class="comment">// a[gt+1, hi] are elements &gt; pivot  </span></div><div class="line">            swap(a, gt--, i);  </div><div class="line">        <span class="keyword">else</span> <span class="comment">// a[lo, lt-1] are elements &lt; pivot  </span></div><div class="line">            swap(a, lt++, i++);  </div><div class="line">    &#125;  </div><div class="line">    qsort3way(a, lo, lt-<span class="number">1</span>);  </div><div class="line">    qsort3way(a, gt+<span class="number">1</span>, hi);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>说它很subtle, 除了因为没有那个图我写不出来以外, 还有就是, 在把i和lt交换时, i可以increment (因为我们知道<code>a[lt]==pivot</code>), 但是i和gt交换时, i<strong>不能</strong>increment: 因为a[gt]不知道多大, 所以i位置要继续检查.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天总结一下非常有用的快速排序(qsort)算法, 以及由此衍生的一些其他相关算法(Knuth shuffle, quick select, 3-way partition).&lt;/p&gt;
&lt;p&gt;快速排序的算法可以用三句话描述:&lt;br&gt;&lt;strong&gt;[Algo]&lt;/stron
      
    
    </summary>
    
      <category term="算法" scheme="http://chen-tao.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://chen-tao.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="快速排序" scheme="http://chen-tao.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
      <category term="sort" scheme="http://chen-tao.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>递归，回溯，DFS，BFS的理解和模板</title>
    <link href="http://chen-tao.github.io/2017/01/27/al-template/"/>
    <id>http://chen-tao.github.io/2017/01/27/al-template/</id>
    <published>2017-01-26T16:00:00.000Z</published>
    <updated>2017-09-11T05:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 里面很大一部分题目都是属于这个范围，例如Path Sum用的就是递归+DFS，Path Sum2用的是递归+DFS+回溯</p><p>这里参考了一些网上写得很不错的文章，总结一下理解与模板</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归：就是出现这种情况的代码： （或者说是用到了栈）</p><p>解答树角度：在dfs遍历一棵解答树      </p><p>优点：结构简洁</p><p>缺点：效率低，可能栈溢出</p><p>递归的一般结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">     <span class="keyword">if</span>(符合边界条件)</div><div class="line">    &#123;</div><div class="line">       <span class="comment">///////</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">     <span class="comment">//某种形式的调用</span></div><div class="line">     f();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>回溯：递归的一种，或者说是通过递归这种代码结构来实现回溯这个目的。回溯法可以被认为是一个有过剪枝的DFS过程。</p><p>解答树角度：带回溯的dfs遍历一棵解答树</p><p>回溯的一般结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> 当前状态)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">      <span class="keyword">if</span>(当前状态为边界状态)</div><div class="line">      &#123;</div><div class="line">        记录或输出</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//横向遍历解答树所有子节点</span></div><div class="line">     &#123;</div><div class="line">           <span class="comment">//扩展出一个子状态。</span></div><div class="line">           修改了全局变量</div><div class="line">           <span class="keyword">if</span>(子状态满足约束条件)</div><div class="line">            &#123;</div><div class="line">              dfs(子状态)</div><div class="line">           &#125;</div><div class="line">            恢复全局变量<span class="comment">//回溯部分</span></div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="BFS-amp-DFS"><a href="#BFS-amp-DFS" class="headerlink" title="BFS&amp;DFS"></a>BFS&amp;DFS</h2><p>常用的搜索方式。</p><ol><li>枚举。枚举运算量很大，需要预先确定枚举的定义域。</li><li>广度优先搜索（BFS ）——通常可以用于计算图的连通性、单源最短路径、计算最小操作次数等。</li><li>深度优先搜索（DFS）——经典题：火力中心布局。</li></ol><p>BFS的占用的是队列的空间</p><p>DFS 占用的是栈的空间（因为递归）</p><p>BFS和DFS的空间复杂度恰好相反</p><p>对链状图，BFS最好（队列中最多只有1个元素），DFS最差（所有节点都在根节点的递归内）</p><p>对起点与其他所有点相邻的图，DFS最好（递归深度为1），BFS最差（队列中放满了所有与起点相邻的图）。</p><h3 id="BFS模版"><a href="#BFS模版" class="headerlink" title="BFS模版"></a>BFS模版</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">queue</span>&lt;type&gt; q;</div><div class="line">q.push(初始状态);</div><div class="line"><span class="keyword">while</span> (!q.empty())</div><div class="line">&#123;</div><div class="line">  type t = q.front() ;</div><div class="line">  q.pop();</div><div class="line">  遍历 t 的各个Next状态  next</div><div class="line">  &#123; </div><div class="line">    <span class="keyword">if</span> (next is legal)</div><div class="line">      q.push(next); 计数或维护等; </div><div class="line">  &#125; </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是BFS的状态数一多，需要的空间就会较大。因此就需要状态压缩，BUPT OJ上的1180就是一个典型的例子，但是状态压缩以及解压的时候，又会涉及效率，反正1180将80M的状态压缩到40K以后就超时了……</p><h3 id="DFS模板"><a href="#DFS模板" class="headerlink" title="DFS模板"></a>DFS模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">DFS（顶点） </div><div class="line">&#123;</div><div class="line">　　处理当前顶点，记录为已访问</div><div class="line">　　遍历与当前顶点相邻的所有未访问顶点</div><div class="line">　　&#123;</div><div class="line">　　　　　　标记更改;</div><div class="line">　　　　　　DFS( 下一子状态);</div><div class="line">　　　　　　恢复更改;</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>回溯法：DFS适用于 显式图，但是对于一些隐式关系，我们需要使用回溯法，通过定义或找到各个状态、边界条件、搜索范围、约束条件和最优解结果进行建模求解。</p><p>边界条件：达到某状态时，需要检查并确定是继续搜索还是回到上一状态的条件（例如当前已使用时间比当前最优解要长，此时就不需要再进行搜索）</p><p>搜索范围：当前从当前状态开始进行搜索的所有下一级状态。 </p><p>搜索范围：</p><p>另外一定要注意，假如参与递归的参数不是通过传参形式的方式进入递归的话，那么一定要做好数据恢复。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Trace（当前状态） </div><div class="line">&#123;</div><div class="line">    if 当前状态是结束状态</div><div class="line">    &#123;</div><div class="line">         if 是最佳解： 记录。</div><div class="line">         退出</div><div class="line">    &#125;</div><div class="line">    遍历当前状态的各个邻接状态</div><div class="line">    &#123;</div><div class="line">        if 当前状态满足约束条件 且 满足最优性要求 ： Trace（子状态） </div><div class="line">    &#125; </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LeetCode 里面很大一部分题目都是属于这个范围，例如Path Sum用的就是递归+DFS，Path Sum2用的是递归+DFS+回溯&lt;/p&gt;
&lt;p&gt;这里参考了一些网上写得很不错的文章，总结一下理解与模板&lt;/p&gt;
&lt;h2 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; cl
      
    
    </summary>
    
      <category term="算法" scheme="http://chen-tao.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://chen-tao.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="http://chen-tao.github.io/tags/DFS/"/>
    
      <category term="递归" scheme="http://chen-tao.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="回溯" scheme="http://chen-tao.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
      <category term="BFS" scheme="http://chen-tao.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>DFS深度优先搜索算法总结</title>
    <link href="http://chen-tao.github.io/2017/01/26/about-dfs/"/>
    <id>http://chen-tao.github.io/2017/01/26/about-dfs/</id>
    <published>2017-01-25T16:00:00.000Z</published>
    <updated>2017-09-11T05:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><ul><li><a href="#recursive-dfs">Recursive DFS</a></li><li><a href="#non-recursive-dfs">Non-Recursive DFS</a><ul><li><a href="#for-tree-dfs-with-depth">(for Tree) DFS with depth</a></li><li><a href="#dfs-for-binary-tree--preorder-traversal">DFS for binary tree–PreOrder traversal</a></li></ul></li><li><a href="#cycle-detection">Cycle Detection</a></li><li><a href="#topology-sort">Topology Sort</a></li><li><a href="#leetcode-dfs">LeetCode DFS</a><ul><li><a href="#subsets">Subsets</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><p>总结复习一下DFS算法。</p><p>深度优先算法是N种算法的基础，是算法学习中的重中之重。</p><p>可以解决的问题类型也很多：递归，回溯，隐图式搜索，甚至是暴力类型算法的万金油。</p><h2 id="DFS-intro"><a href="#DFS-intro" class="headerlink" title="DFS intro"></a>DFS intro</h2><p>图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。</p><p>它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>显然，深度优先搜索是一个递归的过程。</p><h2 id="Understand-DFS"><a href="#Understand-DFS" class="headerlink" title="Understand DFS"></a>Understand DFS</h2><h3 id="无向图-undirected-graph"><a href="#无向图-undirected-graph" class="headerlink" title="无向图(undirected graph)"></a>无向图(undirected graph)</h3><p><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7glkmecsj30bl08fq3b.jpg" alt=""></p><p>对于上图的遍历，步骤如下：</p><p><img src="https://ww1.sinaimg.cn/large/006tNbRwgy1fc7gowbrw3j30c409hmxs.jpg" alt=""></p><p><strong>第1步</strong>：访问A。 </p><p><strong>第2步</strong>：访问(A的邻接点)C。 </p><pre><code>在第1步访问A之后，接下来应该访问的是A的邻接点，即&quot;C,D,F&quot;中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在&quot;D和F&quot;的前面，因此，先访问C。 </code></pre><p><strong>第3步</strong>：访问(C的邻接点)B。 </p><pre><code>在第2步访问C之后，接下来应该访问C的邻接点，即&quot;B和D&quot;中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。 </code></pre><p><strong>第4步</strong>：访问(C的邻接点)D。 </p><pre><code>在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。 </code></pre><p><strong>第5步</strong>：访问(A的邻接点)F。 </p><pre><code>前面已经访问了A，并且访问完了&quot;A的邻接点B的所有邻接点(包括递归的邻接点在内)&quot;；因此，此时返回到访问A的另一个邻接点F。 </code></pre><p><strong>第6步</strong>：访问(F的邻接点)G。 </p><p><strong>第7步</strong>：访问(G的邻接点)E。</p><p>因此访问顺序是：<strong>A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E</strong></p><h3 id="有向图-directed-graph"><a href="#有向图-directed-graph" class="headerlink" title="有向图(directed graph)"></a>有向图(directed graph)</h3><p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fc7gqb4esdj308f08y74n.jpg" alt=""></p><p><img src="https://ww2.sinaimg.cn/large/006tNbRwgy1fc7gqggvlfj308f0a0gm7.jpg" alt=""></p><p><strong>第1步</strong>：访问A。 </p><p><strong>第2步</strong>：访问B。 </p><pre><code>在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。 </code></pre><p><strong>第3步</strong>：访问C。 </p><pre><code>在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。 </code></pre><p><strong>第4步</strong>：访问E。 </p><pre><code>接下来访问C的出边的另一个顶点，即顶点E。 </code></pre><p><strong>第5步</strong>：访问D。 </p><pre><code>接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。 </code></pre><p><strong>第6步</strong>：访问F。 </p><pre><code>接下应该回溯&quot;访问A的出边的另一个顶点F&quot;。 </code></pre><p><strong>第7步</strong>：访问G。</p><p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G</strong></p><h2 id="DFS-implement"><a href="#DFS-implement" class="headerlink" title="DFS implement"></a>DFS implement</h2><p>由于tree可以看做特殊的graph，这里针对graph来实现</p><p>​<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> calss GraphNode&#123;</div><div class="line">  <span class="keyword">int</span> val;</div><div class="line">  List&lt;GraphNode&gt; neighnors;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>为了防止重复，使用一个HashSet来保存已经遍历过的节点</p><p>​<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HashSet&lt;GraphNode&gt; visited = <span class="keyword">new</span> HashSet&lt;GraphNode&gt;();</div></pre></td></tr></table></figure></p><h3 id="Recursive-DFS"><a href="#Recursive-DFS" class="headerlink" title="Recursive DFS"></a>Recursive DFS</h3><p>每到一个节点，标记已经被访问过，对邻居里没有访问的节点进行DFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(GraphNode nd)</span></span>&#123;</div><div class="line">  <span class="comment">//print nd.val</span></div><div class="line">  visited.add(nd);</div><div class="line">  <span class="keyword">for</span>(GraphNode next : nd.neighbours)&#123;</div><div class="line">    <span class="keyword">if</span>(!visited.contains(next))&#123;</div><div class="line">      DFS(next);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>经典的DFS，回溯算法(backtracking)其实相当于在一个求解域做DFS(剪枝)，另外，拓扑排序也是基于递归DFS进行的一点修改</p><h3 id="Non-Recursive-DFS"><a href="#Non-Recursive-DFS" class="headerlink" title="Non-Recursive DFS"></a>Non-Recursive DFS</h3><p>非递归版本，相比递归版本效率高，且不会导致栈溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(GraphNode start)</span></span>&#123;</div><div class="line">  Stack&lt;GraphNode&gt; s = <span class="keyword">new</span> Stack&lt;GraphNode&gt;();</div><div class="line">  q.push(start);</div><div class="line">  visited.add(start);</div><div class="line">  <span class="keyword">while</span>(!s.empty())&#123;</div><div class="line">    GraphNode cur = s.pop();</div><div class="line">    <span class="comment">//print cur.val</span></div><div class="line">    <span class="keyword">for</span>(GraphNode next : cur.children)&#123;</div><div class="line">      <span class="keyword">if</span>(!visited.contains(next))&#123;</div><div class="line">        s.push(next);</div><div class="line">        visited.add(next);<span class="comment">//mark node as visited when adding to stack.</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="comment">//while end</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="for-Tree-DFS-with-depth"><a href="#for-Tree-DFS-with-depth" class="headerlink" title="(for Tree) DFS with depth"></a>(for Tree) DFS with depth</h3><p>深度在搜索中记录，递归版本加一个depth参数++就可以了，非递归版本用一个和s平行的栈记录深度</p><h3 id="DFS-for-binary-tree–PreOrder-traversal"><a href="#DFS-for-binary-tree–PreOrder-traversal" class="headerlink" title="DFS for binary tree–PreOrder traversal"></a>DFS for binary tree–PreOrder traversal</h3><p>DFS对于二叉树而言，其遍历序列就是其前序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[preorder(node)] = node.val + [preorder(node.left)] + [preorder(node.right)]</div></pre></td></tr></table></figure><h2 id="Cycle-Detection"><a href="#Cycle-Detection" class="headerlink" title="Cycle Detection"></a>Cycle Detection</h2><p>对DFS稍作修改，可以判断一个有向图是否有回路</p><p>在递归版本里，我们队每一个点改为三种标记：</p><ul><li>未访问过(0)</li><li>正在访问其邻居节点(1)</li><li>已经访问完毕该节点以及所有该节点可以到达的节点(2)</li></ul><p>什么时候会出现回路？<strong>就是当前节点v的一个邻居u的状态为1的时候。</strong></p><p>因为该节点状态为1，即还没有把它以后的节点全部遍历，所以当前节点v肯定可以从u到达，而现在又可以从v到达u，所以回路构成。</p><p>为了表示一个节点的三种状态, 我们把visited的定义改一下, 定义为一个hashmap:<br><code>HasheMap visited = new HasheMap();</code></p><p>节点不在visited表示还未访问过, 节点对应为false表示正在访问, 节点对应为true表示已经访问该节点以及所有可以从它到达的节点.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(GraphNode nd)</span></span>&#123;      </div><div class="line">    visited.put(nd, <span class="keyword">false</span>); <span class="comment">// mark as status-1   </span></div><div class="line">    <span class="keyword">for</span>(GraphNode next: nd.neighbors)&#123;   </div><div class="line">        <span class="keyword">if</span>( !visited.contains(next) )   </div><div class="line">            DFS(next);   </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(visited.get(next)==<span class="keyword">false</span>) <span class="comment">// found cycle   </span></div><div class="line">            System.out.println(<span class="string">"Cycle detected!!!"</span>);   </div><div class="line">    &#125;<span class="comment">// now all touchable nodes from nd are visited   </span></div><div class="line">    visited.put(nd, <span class="keyword">true</span>); <span class="comment">// mark as status-2   </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Topology-Sort"><a href="#Topology-Sort" class="headerlink" title="Topology Sort"></a>Topology Sort</h2><p>这一节(以及上一节)参考这个非常棒的视频: <a href="https://class.coursera.org/algo-003/lecture/52" target="_blank" rel="external">https://class.coursera.org/algo-003/lecture/52</a></p><p>拓扑排序是一个dfs的应用, 所谓拓扑排序是指在一个DAG(有向无回路图)里给每个节点定义一个顺序(v1…vn), 使得按照这个顺序遍历的节点, 每一个节点vi都是之前遍历过的的节点(v1 ~ vi-1)所指向的(或没有任何其他节点指向的).</p><p>好像还没说清楚… 拓扑排序的一个应用就是对于各种依赖性(比如学习课程A需要先学习过课程B)组成的图寻找一个节点遍历的顺序使其可行.</p><p><strong>propositions</strong>:</p><blockquote><ul><li>拓扑排序的结果不唯一.</li><li>有回路的图不存在拓扑顺序.</li><li>如果一个节点没有出边, 那么它可以放在拓扑排序的最后面(没有节点以来它).</li><li>如果一个节点没有入边, 那么它可以放在拓扑排序的最后面.</li></ul></blockquote><p>简单修改一下递归的dfs就可以处理拓扑排序: 维护一个计数器<code>K</code>(初始化为n=所有节点数), 每当一个点已经遍历完毕(所有通过这个点可以到达的点都已经被走过)以后, 就把这个点的顺序设为K, 同时减少K.</p><p>就用一个HashMap来为每个节点关联一个序号好了:<br><code>HasheMap order = new HasheMap();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(GraphNode nd)</span></span>&#123;      </div><div class="line">    <span class="keyword">for</span>(GraphNode next: nd.neighbors)&#123;   </div><div class="line">        <span class="keyword">if</span>( !visited.contains(next) )   </div><div class="line">            DFS(next);   </div><div class="line">    &#125;<span class="comment">// all touchable nodes from nd are visited   </span></div><div class="line">    order.put(nd, K--);   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面只是对于一个点进行的, 为了给所有点拓扑排序, 只要从一个没有出边的节点出发进行遍历, 一直运行到所有的节点都已经访问过为止。</p><h2 id="LeetCode-DFS"><a href="#LeetCode-DFS" class="headerlink" title="LeetCode DFS"></a>LeetCode DFS</h2><p>LeetCode上很多题目都是使用DFS或其思想进行处理的</p><p>DFS的框架可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//结果集</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> T ans = <span class="keyword">new</span> T();</div><div class="line"><span class="comment">//中间结果集</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> T path = <span class="keyword">new</span> T();</div><div class="line"><span class="comment">//问题</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">problem</span><span class="params">()</span></span>&#123;</div><div class="line">  ans.clear();<span class="comment">//leetcode的一个特殊点，每次要清空结果集，避免重复</span></div><div class="line">  robot(idx ,...);<span class="comment">//DFS部分，常用idx作为结果递归的标志</span></div><div class="line">  <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"><span class="comment">//DFS</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">robot</span><span class="params">(<span class="keyword">int</span> idx, ...)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(xxx)&#123;<span class="comment">//边界条件，递归出口条件</span></div><div class="line">    <span class="comment">//用当前path内容生成一部分结果集</span></div><div class="line">    <span class="comment">//handle path </span></div><div class="line">    ans.add(tmp);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//递归处理</span></div><div class="line">  path[idx] = <span class="keyword">true</span>;<span class="comment">//递归前假设</span></div><div class="line">  robot(++idx, ...);<span class="comment">//根据不同情况进行处理</span></div><div class="line">  path[idx] = <span class="keyword">false</span>;<span class="comment">//递归后还原</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里举例进行分析：</p><h3 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h3><p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets.</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p>For example,<br>If <strong>nums</strong> = <code>[1,2,3]</code>, a solution is:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [3],</div><div class="line">  [1],</div><div class="line">  [2],</div><div class="line">  [1,2,3],</div><div class="line">  [1,3],</div><div class="line">  [2,3],</div><div class="line">  [1,2],</div><div class="line">  []</div><div class="line">]</div></pre></td></tr></table></figure><script src="https://gist.github.com/Chen-tao/f97f5628bdf96b2ce8ea3b11822d40c5.js"></script><p>原集合每一个数字只有两种状态，要么存在，要么不存在，那么在构造子集时就有选择和不选择两种情况，所以可以构造一棵二叉树，左子树表示选择该层处理的节点，右子树表示不选择，最终的叶节点就是所有子集合，树的结构如下：</p><p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fc7i519tsrj30d6083jru.jpg" alt=""></p><p>DFS几乎可以算是图与树种最重要的算法，这里总结不算全面，但基本涵盖，这里最主要是搜索递归的思想。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#recursive-dfs&quot;&gt;Recursive DFS&lt;/a&gt;&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://chen-tao.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://chen-tao.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="http://chen-tao.github.io/tags/DFS/"/>
    
      <category term="搜索" scheme="http://chen-tao.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="递归" scheme="http://chen-tao.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="回溯" scheme="http://chen-tao.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>BFS广度优先搜索算法总结</title>
    <link href="http://chen-tao.github.io/2017/01/25/about-bfs/"/>
    <id>http://chen-tao.github.io/2017/01/25/about-bfs/</id>
    <published>2017-01-24T16:00:00.000Z</published>
    <updated>2017-09-11T05:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BFS-intro"><a href="#BFS-intro" class="headerlink" title="BFS intro"></a>BFS intro</h2><p>广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。</p><p>它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。</p><h2 id="Understand-BFS"><a href="#Understand-BFS" class="headerlink" title="Understand BFS"></a>Understand BFS</h2><h3 id="无向图-undirected-graph"><a href="#无向图-undirected-graph" class="headerlink" title="无向图(undirected graph)"></a>无向图(undirected graph)</h3><p><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7jidbnayj30eq0e73zi.jpg" alt=""></p><p><strong>第1步</strong>：访问A。 </p><p><strong>第2步</strong>：依次访问C,D,F。 </p><pre><code>在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在&quot;D和F&quot;的前面，因此，先访问C。再访问完C之后，再依次访问D,F。 </code></pre><p><strong>第3步</strong>：依次访问B,G。 </p><pre><code>在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。 </code></pre><p><strong>第4步</strong>：访问E。 </p><pre><code>在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。</code></pre><p>因此访问顺序是：<strong>A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E</strong></p><h3 id="有向图-directed-graph"><a href="#有向图-directed-graph" class="headerlink" title="有向图(directed graph)"></a>有向图(directed graph)</h3><p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fc7jjkk7w8j30fs0cn75e.jpg" alt=""></p><p><strong>第1步</strong>：访问A。 </p><p><strong>第2步</strong>：访问B。 </p><p><strong>第3步</strong>：依次访问C,E,F。 </p><pre><code>在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。 </code></pre><p><strong>第4步</strong>：依次访问D,G。 </p><pre><code>在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。</code></pre><p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G</strong></p><h2 id="BFS-implement"><a href="#BFS-implement" class="headerlink" title="BFS implement"></a>BFS implement</h2><p>对于没有边权重的图来说可以计算最短路径. </p><p>由于树的BFS只是图的BFS的一种特殊情况, 而且比较简单不需要visited标记, 这里只写一下图的BFS好了. </p><p>先定义一个Graph类, 这里在每一个节点保存邻居信息:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphNode</span></span>&#123;   </div><div class="line">    <span class="keyword">int</span> val;   </div><div class="line">    List&lt;GraphNode&gt; neighbors;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="BFS-for-trees-graphs"><a href="#BFS-for-trees-graphs" class="headerlink" title="BFS for trees/graphs"></a>BFS for trees/graphs</h3><p>图的遍历需要注意不走重复节点, 所以需要一个HashSet(名字叫visited)来保存哪些节点已经访问过了. </p><p>需要注意的是, <em>在把一个节点放进队列queue的时刻就要把它放进visited</em>, 而不是在队列里取出来的时刻再放.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(GraphNode start)</span></span>&#123;   </div><div class="line">    LinkedList&lt;GraphNode&gt; q = <span class="keyword">new</span> LinkedList&lt;GraphNode&gt;();   </div><div class="line">    HasheSet&lt;GraphNode&gt; visited = <span class="keyword">new</span> HasheSet&lt;GraphNode&gt;();   </div><div class="line">    q.push(start);   </div><div class="line">    visited.add(start);   </div><div class="line">    <span class="keyword">while</span>(!q.empty())&#123;   </div><div class="line">        GraphNode cur = q.poll();   </div><div class="line">        System.out.println(cur.val);   </div><div class="line">        <span class="keyword">for</span>(GraphNode next: cur.children)&#123;    </div><div class="line">            <span class="keyword">if</span>(!visited.contains(next))&#123;   </div><div class="line">                q.push(next);   </div><div class="line">                visited.add(next); <span class="comment">// mark node as visited when adding to queue!    </span></div><div class="line">            &#125;   </div><div class="line">        &#125;   </div><div class="line">    &#125;<span class="comment">//while   </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="BFS-with-distance"><a href="#BFS-with-distance" class="headerlink" title="BFS with distance"></a>BFS with distance</h3><p>在BFS的同时我们可以记录从start节点到当前node的距离, 方法是把一个距离信息同时入队(封装一个<code>Pair</code>), 或者使用一个与queue<em>平行</em>的队列保存距离信息. </p><p>在上面的代码中, 加入:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//...   </span></div><div class="line">LinkedList&lt;Integer&gt; distq = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();   </div><div class="line">distq.push(<span class="number">0</span>);<span class="comment">// distance from start to start   </span></div><div class="line"><span class="comment">//...   </span></div><div class="line"><span class="comment">// in the while(!q.empty()) loop:    </span></div><div class="line">    <span class="keyword">int</span> d = distq.poll();<span class="comment">//get distance from start to current node   </span></div><div class="line">    <span class="keyword">for</span>(GraphNode next: node.children)&#123;   </div><div class="line">        distq.push(d+<span class="number">1</span>);<span class="comment">// distance from start to next node   </span></div><div class="line">        <span class="comment">//...</span></div></pre></td></tr></table></figure><p>对于Tree的情况来说, 这里的dist其实就是当前节点的深度depth.</p><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p><strong>性质1:</strong><br>每个节点node的distance都是node距离起始点start的最短距离.</p><p><strong>性质2:</strong><br>距离start近的节点(depth浅的节点)一定比距离start远的节点早被访问到.</p><p>这是对一个树BFS的时候节点的访问顺序:<br><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7jvepss7j309f06l3yq.jpg" alt=""></p><h3 id="BFS-“by-layer”"><a href="#BFS-“by-layer”" class="headerlink" title="BFS “by layer”"></a>BFS “by layer”</h3><p>参考上面的性质, 可以一次处理”一层”的节点, “一层”的意思是指所有节点距离start的距离相同. 代码在while循环里不是一次poll一个节点, 而是一次把queue的内容处理完, 然后换新的queue进入下一次while循环. 代码重新写一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(GraphNode start)</span></span>&#123;   </div><div class="line">    ArrayList&lt;GraphNode&gt; q = <span class="keyword">new</span> ArrayList&lt;Tree&gt;();   </div><div class="line">    HasheSet&lt;GraphNode&gt; visited = <span class="keyword">new</span> HasheSet&lt;GraphNode&gt;();   </div><div class="line">    q.push(start);   </div><div class="line">    visited.add(start);   </div><div class="line">    <span class="keyword">while</span>(!q.empty())&#123;   </div><div class="line">        ArrayList&lt;GraphNode&gt; newq = <span class="keyword">new</span> ArrayList&lt;Tree&gt;();<span class="comment">// create a new queue   </span></div><div class="line">        <span class="keyword">for</span>(GraphNode cur: q)&#123;<span class="comment">// deal with all nodes in the queue    </span></div><div class="line">            System.out.print(cur.val+<span class="string">", "</span>);<span class="comment">// all nodes in q are of the same distance/depth   </span></div><div class="line">            <span class="keyword">for</span>(GraphNode next: cur.children)    </div><div class="line">                <span class="keyword">if</span>(!visited.contains(next))   </div><div class="line">                    &#123; newq.push(next);visited.add(next); &#125;   </div><div class="line">        &#125;   </div><div class="line">        System.out.println();   </div><div class="line">        q = newq;<span class="comment">//replace q with newq   </span></div><div class="line">    &#125;<span class="comment">//while   </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上程序每次打印一行, 第i行包括了距start距离为i的所有节点. </p><p>由于这样的话每次不必在队首poll出元素(而是依次处理所有queue的元素), 所以可以改用ArrayList. 此时while循环里的不变量是: 所有q里面的节点距离start的距离都相同.</p><h3 id="complexity"><a href="#complexity" class="headerlink" title="complexity"></a>complexity</h3><p>假设一个图有N个节点和M条边, BFS会走遍所有节点, 时间是O(N), 然后由于每个节点会检查所有的出边, 最终所有的边都会被检查过, 时间是O(M), 所以BFS的时间复杂度是<strong>O(N+M)</strong>.</p><p>队列里面最多可能存放所有节点, 空间复杂度为<strong>O(N)</strong>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BFS-intro&quot;&gt;&lt;a href=&quot;#BFS-intro&quot; class=&quot;headerlink&quot; title=&quot;BFS intro&quot;&gt;&lt;/a&gt;BFS intro&lt;/h2&gt;&lt;p&gt;广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”
      
    
    </summary>
    
      <category term="算法" scheme="http://chen-tao.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://chen-tao.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="http://chen-tao.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>日语授受关系总结</title>
    <link href="http://chen-tao.github.io/2017/01/18/japanese-shou-shou-rela/"/>
    <id>http://chen-tao.github.io/2017/01/18/japanese-shou-shou-rela/</id>
    <published>2017-01-17T16:00:00.000Z</published>
    <updated>2017-09-11T05:36:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./授受关系.png" alt="授受关系"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;./授受关系.png&quot; alt=&quot;授受关系&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="日语" scheme="http://chen-tao.github.io/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>云计算那点事</title>
    <link href="http://chen-tao.github.io/2017/01/12/cloud-things/"/>
    <id>http://chen-tao.github.io/2017/01/12/cloud-things/</id>
    <published>2017-01-11T16:00:00.000Z</published>
    <updated>2017-09-11T05:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<h6 id="FROM-知乎专栏"><a href="#FROM-知乎专栏" class="headerlink" title="FROM 知乎专栏"></a>FROM <a href="https://zhuanlan.zhihu.com/p/22445510?refer=mintshow" target="_blank" rel="external">知乎专栏</a></h6><blockquote><p>来自知乎专栏的一篇文章，信息量真的很大，也有不少很风趣的逸事。</p><p>其实我也浅短的接触过一些云计算：13年金山云起步，有幸参与其中，那时候和斌神被老盘带进公司，他搞SDK(就是直接拿S3的转换)，我在另一侧搞运维和Hadoop生态相关的东西，每周一都会在上地桥东见到雷老板来开会，虎虎生风的，那时候也是小米上升期，真的是恍若隔世。</p><p>如文中所述，金山云确实当时很依赖小米，刚总可能觉得这样的状态他不喜欢，然而雷老板似乎又没给他多大的活动空间(参照下傅盛)，于是，约莫一年刚总出走，金山云又被迅雷吞吃，这一段历史，也算基本告一段落。</p></blockquote><h2 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a><strong>（一）</strong></h2><ol><li>高升科技（000971）的老大于平十年前跟我是同行，在东北做声讯电话业务。后来有人欠他钱，就抄家伙喊帮手去要钱，借钱的没办法说你把我砍了也没钱，我有个机房，要不抵给你吧。老于想想也没办法只好接管了机房，拿下来后就找关系卖IDC，卖着卖着发现，100万的欠款换来的机房，竟然卖了130万，敢情这东西有利润啊。 于是下血本进入IDC市场，9年后公司上市，市值100多亿。 有些做地产的主动找老于要给地，说这地租出去租不了几个钱，还不如给你拿去盖机房赚的更多。</li><li>Openstack是个坑，谁用谁知道，国内一些订制openstack的企业能搞出一些私有云的项目，然而其实做起来都是苦不堪言。想想也是的，rackspace和NASA能搞出什么东西呢？ 主流云计算服务商都不用openstack， 小米运维那边的几个好友也说试了openstack感觉不行。</li><li>360在openstack出来之前内部搞过一套类似的东西，有点作用，后来openstack出来之后就全面拥抱openstack，这下好了完美入坑，360云事业部后来裁掉了，不过老周倒也直爽，尽管自己的兴趣点都在智能硬件和花椒直播上，但也给云那边烧过几个亿，后来拆VIE业绩有些压力就动手砍掉了，360云当时的老大是惠普过来的，业务能力超强，以前把惠普走下坡路的服务器业务从上一年的8个亿做到20多个亿，这人脾气很好，老周说分手就同意分手了，后来跳槽去了乐视云。</li><li>黄允松在IBM就负责云，从18摸出来后，有点担心老东家找麻烦，于是自学python，换了门语言吭哧吭哧写出了青云， 这下你没法告我了吧，你吹得我涨不？ 不过Qingcloud的发展也挺坎坷，一度认为互联网公司会成为云计算的忠实客户，后来发现客户都在深圳，那些金融大土豪才是最喜欢给云计算付费的。于是黄云松搬去深圳住了大半年，把业务撑起来了。</li><li>13年的时候研究过SDN，那时候SDN太火了，饭桌上不提两下openflow都没法在圈子里混了。只有钱伯斯敢站出来说openflow是个垃圾， 于是很自然地，钱伯斯被骂成猪头，大家觉得他廉颇老矣。 后来事实证明钱伯斯是正确的，技术细节就不多说了，说一个小问题：某银行某年采购了15亿的网络设备，第二年有人提议说咱们上SDN，用openflow，然后发现老设备不兼容全部处理掉把，上SDN差不多需要再投入18亿……   后面的结果可想而知。</li><li>UCloud刚成立的时候，冲着季昕华那名头很多投资人都追上去想投资，一问融资金额就犹豫了，再细问一下发现云计算挺烧钱，烧服务器烧带宽，在IDC上的投入简直堪比炒房，那时候阿里云还备受质疑，云计算市场很不明朗， 于是各种认怂了说季总威武霸气，小的我看不懂不敢投祝你幸福之类。 后来DCM和君联杀进后越做越好， 投资人聊到云计算就提自己当年如何看过以及如何错过Ucloud，说得都是绘声绘色栩栩如生。</li><li>CDN市场以前是网宿蓝汛90%，帝联7%，剩下的包括BAT在内抢3%，可惜蓝汛在美国上市，市值惨不忍睹。蓝汛催钱也挺辛苦，经常要拉横幅鼓励员工开催款动员大会。 后来霍涛景楠等人离开蓝汛，出去搞了个白山云，蓝汛昔日的地位不复存在了。</li><li><strong>金山云靠小米渠道去圈游戏客户是真的，你用金山云小米就帮你推，为此还从其他云平台撬过几个耳熟能详的大客户。 雷军玩生态是下血本的，不像某些企业内部要资源还难如上青天。</strong></li><li><strong>阿里云每年双十一的时候全国各地都是通宵值守的，尽管这样也扛不住，各种问题层出不穷， 后来甚至把事务逻辑都拿掉了，于是就造成了超卖，超卖得赔钱啊，每年为超卖要补很多钱。</strong></li><li>再说个阿里云的，阿里云处理的一些问题确实是世界级的，前所未有的，包括被黑客攻击也1是，光DDOS的量级就屡屡破世界纪录。几年前没怎么上SSD的时候和阿里云和AWS一样存在I/O问题，后来好了很多。</li><li>七牛是做网盘起家的，网盘实在不赚钱于是做企业存储把收入做起来了，再到混合云。2014年在GiTC上碰到许式伟，旁边人问他最多的就是七牛和又拍有啥区别，他说了十几遍又拍做CDN，七牛做存储。后来七牛不仅CDN做得风生水起，还基于CDN做直播云。 不过说起直播，很多直播平台的量都是刷的，CDN厂商没怎么赚到钱。</li><li><strong>2013年QCon见到季昕华，问他怎么做安全的，怎么抗DDOS，他说他不抗D，业内黑客基本都认识他，如果要打的话会知会一声， 他会跟客户说有人要打你，建议你去阿里云……  后来UCloud真被打了，我们就在说时代变了，新人黑客都不认识老季了。</strong></li><li>青云的服务是1000倍赔付的，有次广州机房被雷劈了， 我也是受害者，那次被劈据说赔了1000多万。网宿有一次被打也连带七牛服务挂掉，损失未知，后来七牛就不把鸡蛋放在一个笼子里了。</li></ol><p><strong>今日推荐： fit2cloud</strong></p><p>我第一次见到fit2cloud这个产品的时候，就觉得一个技术负责人最需要的就是这个产品。</p><p>试想一下技术实现最头疼的不是把需求给做出来，而是你代码写好后发现你有一刀子东西要去部署，你要面对大量的工具，多种基础设施平台，你缺乏一个好的管理工具。</p><ul><li>「FIT2CLOUD 混合云管理平台」帮助企业统一管理异构和异地基础设施，包括物理机(AIX)、虚拟化平台（vSphere，FusionSphere等）、私有云 （Openstack等）和公有云（亚马逊AWS、阿里云等），以服务目录形式对外统一交付IT资源，实现自服务IT。</li><li>「FIT2CLOUD DevOps协作平台」帮助企业在混合云环境下落地亚马逊AWS DevOps解决方案，实现对应用全生命周期的自动化管理，打通从代码到服务的转化通道，实现云应用的持续部署、交付和自动化运维。</li><li>「FIT2CLOUD 云费用管理平台」帮助企业管控云成本，实现对云费用和资源使用情况的可视化分析，优化和预测。 </li></ul><p>作为一个CMP云平台管理产品，Fit2Cloud目前支持主流公有云（阿里云、AWS、腾讯、青云、UCLOUD等）使用Fit2Cloud，你就不需要再繁琐地分别维护各个基础设施，管理多个独立的系统，对成长期的企业来说大大减少了投入，对技术人员来说也解决了一个刚需——懒。</p><p>Fit2Cloud的团队成员普遍是具有多年经验的Devops，公司拥有10多位AWS认证架构师，其中有两位为专业级认证架构师。同时，公司也是AWS中国区域的“高级技术平台合作伙伴”。</p><h2 id="（二）"><a href="#（二）" class="headerlink" title="（二）"></a><strong>（二）</strong></h2><ol><li><strong>政企云跟ISV类似，区域性很强，东北就是东软，东软到了山东就不好使了，山东是浪潮，北京则是中软和软通。 再到了地级市都有更细分的运营公司，比如山东有个地方叫日照市，那里有家快上市的公司叫展望科技，垄断了日照市政企云业务，展望的董事长在我办公室里用浓重的山普说：只要一天有展望在，日照政企就只认展望。</strong></li><li>两年前我刚创业时参加itech在西湖的一个高尔夫活动，当时见识了著名的华三“铁娘子”——吴敬传女士。 这位前华三CEO在过去10年间做到了百亿的年销售额，把思科打出了中国。除此之外，她还是个高尔夫80杆上下的高手。 华三那时候也是国内率先进军SDN和NFV的企业，势不可挡。 只不过没想到2015年初一场政变， 母公司惠普的CEO（也是一位女性）在她休假的时候解除了她的职务， 当时还有大量人员出走。 后来华三和惠普中国一起成为新华三，被紫光收购，成了一家校办企业的子公司。 惠普中国也怪好玩的，一帮满嘴洋文的港台东南亚高管现在成了校企人士了，那画面不敢直视。  政变期出走的一批老兵出来跟阿里合作做了数梦工厂，专做私有云， 吴敬传卸下兵权后休息了一年半，最后出任数梦工厂的CEO，政变结束。</li><li>安全圈几家竞争公司很容易大打出手，但码头工人组织（docker圈）还是很团结的，有时会聚聚一起合个影啥的，毕竟市场还在成长阶段，谈竞争还早。 Daocloud的喻勇自称为胖子，但是论吨位还是灵雀云的左钥更胜一筹。</li><li>云计算好赚钱吗？我找些参照物吧，citrix是卖虚拟桌面的，单子都是几千万的，销售提成据说有10%…… VMware比citrix公司更有名更大，也是出了名的简单粗暴而暴利。 国外卖VPS的比卖独立服务器的更富得流油。 国内各种复杂原因很不好说， 我记得盛大云一个哥们跟我说：<strong>看ROI无非就是看我怎么虚，给得起钱我自然有更好的性能，一个核虚20个核和一个核虚5个核是不一样的。 厉哥你要追求性能的话，我大不了两个核给你虚成一个核……</strong></li><li>云计算公司加班都很辛苦， 尽管在上海，Daocloud 也要996赶产品。 Qingcloud有这么一句话，在非工作日如果你不在工作的话，你得没有愧疚感才行。所以来炜在小米996的环境下竟然可以折腾出Openfalcon这样的开源产品，让我对他不由地肃然起敬。 <strong>来炜在北京的活动半径不超过西二旗，从百度到小米级别一直不高，后来能成为滴滴五大技术台柱之一完全非人般的努力下的结果。</strong></li><li>季昕华在圈内的评价极高，但他的普通话有一种浓浓的非洲土语的感觉，需要配同声翻译，所幸圈子里的朋友们都比较有耐心，积极主动地跟他交流，在朋友们的支持和他自己的努力下，如今交流越来越顺畅了。这里希望蔡文胜也能早日战胜口音障碍。</li><li>互联网就算大公司很多时候也很苦逼，技术这边压榨硬件性能很常见， 很好，单节点并发再多一点，对，单节点吞吐再高一点。 土豪金融公司就不一样了，那个采购清单华丽啊，有的技术人员做了十几年技术，给客户实施的时候望着那些装备都会流口水。 青藤云安全最大的客户是借贷宝，有6000多个节点。</li><li>极光推送用户超10亿了，最早是做IM的，后来发现没法跟微信竞争就把技术开放出来做长连接，立马to B，单台服务器可以支持400万长连接。极光的创始人是开宾利的，找IDG融资的那一轮自己也投了融资金额的20%。 </li><li>Leancloud原来叫AVOS，创始人里有youtube的创始人陈士骏，明星团队，也得到了李开复的大力推荐。但是那个时候PaaS的概念真心不好讲，江宏博士后来完全独立出来成了Leancloud，SDK做的非常好，用起来很舒服，但叫好不叫座。他们的存储、推送等都是自己做的，这一点也被我吐槽过还因此差点结下了梁子。</li><li><strong>云计算的销售往往都是原来卖IDC的，套用一个蓝汛妹子的话：反正都是出来卖的，卖什么不是卖？ 但是市场一般都是互联网公司背景的。如果你在活动上看到美团云的展台上有美女，不要以为那是他们请来的showgirl，那是他们员工。美团云试用下来感觉还可以，价格不错， 有个做用大数据算命的朋友用了不少美团云的服务，反馈说真心不错。 京东云也有一些特色，不要小看二线云产品，外部用户数量都不少，说明这个大市场还远未成熟。</strong></li><li>秋野是运维界郭德纲，名震天下。从世纪佳缘出来的时候，看到刘惠璞去了聚美，于是就去了乐蜂，一度把乐蜂的技术全部接管了下来，可惜乐蜂这个庙越来越破留不住神仙，后来去了民生电商，也不只限于运维了，管一大片技术业务。 但凡技术大会上只要有秋野出现，必然是全场爆满，我有几次想进去瞅两眼结果都挤不进去。 类似的情况我只见过陈浩（左耳朵耗子，前阿里云的）有过。 运维界撒贝宁是匡萃彪，51到安居客到途牛再到自己创业，以往人们不太意识到运维人员的存在，现在娱乐化了之后这个圈子有活力多了，是好事。</li><li>试用了sumo logic，折腾两天未果，然后果断弃，后来sumo logic就反复给我电话，我到了国内也不被放过，一直无力吐槽。直到有一天红杉的人跟我说他们投了sumo logic，有一种如释重负的感觉，就像捂着肚子转了三圈终于找到一个厕所一样，当天吐槽到红杉的人脸色跟吃了大便一样难看。 不知道现在产品如何，但是当时的我很难想象怎么会有一家公司的产品部署体验如此反人类的，仿佛就是为增加你部署难度而生的。</li><li>戴尔曾经以call center黄埔军校著称，时代不一样了，日子也越来越不好过。上次去崇明岛戴尔大会上听一位金博士用纯正的台湾腔讲硬件，说硬件也就这样了都是上面的软件贵，一台8000美金的服务器，你们猜上面的Oracle多少钱？ 台下有人说有8000吗？ 金博士： 8000？ 一个核就要8000，怎么也得要近5万美金。  台下顿时鸦雀无声，大家垂头丧气地，感觉自己都入错行了。</li><li>云公司的CEO一般以业务能力为先，七牛是个特例，七牛已经快上市了但许式伟还在写代码。《docker源代码分析》的作者，Daocloud初创成员孙宏亮单身，有相亲节目看中了他，三顾茅庐请他上节目，人都没见到就被该厂市场老大霍太太按住了，霍太太的老公不是霍元甲的后代，是瑞典人，姓Hall。</li></ol>]]></content>
    
    <summary type="html">
    
      来自知乎专栏的一篇文章，信息量很大，也有不少很风趣的逸事。很多甚至是我见过错过的人生。
    
    </summary>
    
    
      <category term="感悟" scheme="http://chen-tao.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="云计算" scheme="http://chen-tao.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>关键业务系统jvm参数推荐</title>
    <link href="http://chen-tao.github.io/2017/01/10/jvm-param-rcmd-2016/"/>
    <id>http://chen-tao.github.io/2017/01/10/jvm-param-rcmd-2016/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2017-09-11T05:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言1，资料"><a href="#前言1，资料" class="headerlink" title="前言1，资料"></a>前言1，资料</h3><p>学习开源项目的启动脚本是个不错的主意，比如<a href="http://github.com/apache/cassandra/blob/trunk/conf/jvm.options" target="_blank" rel="external">Cassandra家的</a>， 附送一篇<a href="http://tobert.github.io/pages/als-cassandra-21-tuning-guide.html" target="_blank" rel="external">解释它的文章</a>。</p><p><a href="http://hllvm.group.iteye.com/group/topic/27945" target="_blank" rel="external">JVM调优的”标准参数”的各种陷阱</a> R大的文章，在JDK6时写的，期待更新。</p><p>偶然翻到Linkedin工程师的<a href="http://www.importnew.com/11336.html" target="_blank" rel="external">一篇文章</a>。</p><p>更偶然翻到的<a href="http://www.techpaste.com/2012/02/java-command-line-options-jvm-performance-improvement/" target="_blank" rel="external">一份不错的参数列表</a>。</p><p>并发编程网上的<a href="http://ifeve.com/useful-jvm-flags/" target="_blank" rel="external">JVM实用参数系列</a></p><h3 id="前言2，-XX-PrintFlagsFinal打印参数值"><a href="#前言2，-XX-PrintFlagsFinal打印参数值" class="headerlink" title="前言2， -XX:+PrintFlagsFinal打印参数值"></a>前言2， -XX:+PrintFlagsFinal打印参数值</h3><p>当你在网上兴冲冲找到一个可优化的参数时，先用-XX: +PrintFlagsFinal看看，它可能已经默认打开了，再找到一个，还是默认打开了…</p><p>JDK7与JDK8，甚至JDK7中的不同版本，有些参数值都不一样，所以不要轻信网上任何文章，一切以生产环境同版本的JDK打出来的为准。</p><p>经常以类似下面的语句去查看参数，偷懒不起应用，用-version代替。有些参数设置后会影响其他参数，所以查看时也把它带上。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash">  java -server -Xmx1024m -Xms1024m -XX:+UseConcMarkSweepGC -XX:+PrintFlagsFinal -version| grep ParallelGCThread</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><p> <img src="https://ww4.sinaimg.cn/large/006tNc79gw1fblkzb6tzoj30z2080tao.jpg" alt=""></p><h3 id="前言3，关于默认值"><a href="#前言3，关于默认值" class="headerlink" title="前言3，关于默认值"></a>前言3，关于默认值</h3><p>JDK8会默认打开-XX:+TieredCompilation多层编译，而JDK7则不会。JDK7u40以后的版本会默认打开-XX:+OptimizeStringConcat优化字符串拼接，而之前的则不打开。</p><p>对于这些参数，我的建议是<strong>顺势而为，JDK在那个版本默认打开不打开总有它的理由。安全第一，没有很好的因由，不要随便因为网上某篇文章的推荐(包括你现在在读的这篇)就去设置。</strong></p><h3 id="1-性能篇"><a href="#1-性能篇" class="headerlink" title="1. 性能篇"></a>1. 性能篇</h3><p>先写一些不那么常见的，后面再来老生常谈。</p><h4 id="1-1-取消偏向锁-XX-UseBiasedLocking"><a href="#1-1-取消偏向锁-XX-UseBiasedLocking" class="headerlink" title="1.1 取消偏向锁 -XX:-UseBiasedLocking"></a>1.1 取消偏向锁 -XX:-UseBiasedLocking</h4><p>JDK1.6开始默认打开的偏向锁，会尝试把锁赋给第一个访问它的线程，取消同步块上的synchronized原语。如果始终只有一条线程在访问它，就成功略过同步操作以获得性能提升。</p><p>但一旦有第二条线程访问这把锁，JVM就要撤销偏向锁恢复到未锁定线程的状态，详见 <a href="http://calvin1978.blogcn.com/articles/safepoint.html" target="_blank" rel="external">JVM的Stop The World，安全点，黑暗的地底世界</a>， 可以看到不少RevokeBiasd的纪录，像GC一样，会Stop The World的干活，虽然只是很短很短的停顿，但对于多线程并发的应用，取消掉它反而有性能的提升和延时的极微的缩短，所以Cassandra就取消了它。</p><h4 id="1-2-提高数字缓存-XX-AutoBoxCacheMax-20000"><a href="#1-2-提高数字缓存-XX-AutoBoxCacheMax-20000" class="headerlink" title="1.2 提高数字缓存 -XX:AutoBoxCacheMax=20000"></a>1.2 提高数字缓存 -XX:AutoBoxCacheMax=20000</h4><p><code>Integer i = 3;</code>这语句有着 int自动装箱成Integer的过程，JDK默认只缓存 -128 ~ +127的int 和 long，超出范围的数字就要即时构建新的Integer对象。设为20000后，我们应用的QPS从48,000提升到50,000，足足4%的影响。详见<a href="http://blog.csdn.net/chengzhezhijian/article/details/9628251" target="_blank" rel="external">Java Integer(-128~127)值的==和equals比较产生的思考</a></p><h4 id="1-3-启动时访问并置零内存页面-XX-AlwaysPreTouch"><a href="#1-3-启动时访问并置零内存页面-XX-AlwaysPreTouch" class="headerlink" title="1.3 启动时访问并置零内存页面-XX:+AlwaysPreTouch"></a>1.3 启动时访问并置零内存页面-XX:+AlwaysPreTouch</h4><p>启动时就把参数里说好了的内存全部touch一遍，可能启动时慢上一点，但后面访问时会更流畅，比如页面会连续分配，比如不会在晋升新生代到老生代时才去访问页面使得GC停顿时间加长。不过这选项对大堆才会更有感觉一点。</p><h4 id="1-4-禁止JVM写statistics数据-XX-PerfDisableSharedMem"><a href="#1-4-禁止JVM写statistics数据-XX-PerfDisableSharedMem" class="headerlink" title="1.4 禁止JVM写statistics数据 -XX:+PerfDisableSharedMem"></a>1.4 禁止JVM写statistics数据 -XX:+PerfDisableSharedMem</h4><p>Cassandra家的一个参数，一直没留意，直到发生高IO时的JVM停顿。原来JVM经常会默默的在/tmp/hperf 目录写上一点statistics数据，如果刚好遇到PageCache刷盘，把文件阻塞了，就不能结束这个Stop the World的安全点了。用此参数可以禁止JVM写statistics数据，代价是jps, jstat 用不了，只能用JMX取数据。有时用JMX取新生代老生代使用百分比还真没jstat方便。详见<a href="http://www.evanjones.ca/jvm-mmap-pause.html" target="_blank" rel="external">The Four Month Bug: JVM statistics cause garbage collection pauses</a></p><h4 id="1-5-Djava-security-egd-file-dev-urandom"><a href="#1-5-Djava-security-egd-file-dev-urandom" class="headerlink" title="1.5 -Djava.security.egd=file:/dev/./urandom"></a>1.5 -Djava.security.egd=file:/dev/./urandom</h4><p>此江湖偏方原用于Tomcat显式使用SHA1PRNG算法时，初始因子从/dev/random读取导致堵塞。而使用此设置后，额外效果是默认的SecureRandom算法也变成SHA1了。 SHA1PRNG 比 NativePRNG消耗小一半，synchronized的代码少一半，所以没特殊安全要求的话建议用SHA1。详见 <a href="http://calvin1978.blogcn.com/articles/securerandom.html" target="_blank" rel="external">SecureRandom的江湖偏方与真实效果</a></p><h4 id="1-6-不建议的参数"><a href="#1-6-不建议的参数" class="headerlink" title="1.6 不建议的参数"></a>1.6 不建议的参数</h4><ol><li><strong>-XX:+AggressiveOpts</strong>是一些还没默认打开的优化参数集合, -XX:AutoBoxCacheMax是其中的一项。但如前所述，关键系统里不建议打开。虽然通过-XX:+AggressiveOpts 与 -XX:-AggressiveOpts 的对比，目前才改变了三个参数，但为免以后某个版本的JDK里默默改变更多激进的配置，还是不要了。</li></ol><ol><li>Linkined那种黑科技，先要解锁VMOptions才能配置的就更不用说了，比如</li></ol><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> -XX:+UnlockDiagnosticVMOptions -XX: ParGCCardsPerStrideChunk=32768</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><ol><li>JIT Compile相关的参数，函数调用多少次之后开始编译的阀值，内联函数大小的阀值等等，没有经过严格的性能测试，尽量不去改动这里，JIT和javac的编译环节是官方经过长期实验才确定下来的。</li><li><strong>-XX:+UseFastAccessorMethods</strong>，JDK6的优化，据说在多层编译下还慢了，所以是默认关闭的。</li><li><strong>-server</strong>，在64位linux中，你想设成-client都不行的，所以写了也是白写。</li></ol><h4 id="1-7-可选参数"><a href="#1-7-可选参数" class="headerlink" title="1.7 可选参数"></a>1.7 可选参数</h4><ol><li><strong>-Djava.awt.headless=true</strong>，如果服务器上没有屏幕，键盘，鼠标，又需要用到它们的时候，详见<a href="http://www.oschina.net/translate/using-headless-mode-in-java-se" target="_blank" rel="external">在 Java SE 平台上使用 Headless 模式</a></li><li><strong>-XX:-UseCounterDecay</strong>，禁止JIT调用计数器衰减。默认情况下，每次GC时会对调用计数器进行砍半的操作，导致有些方法一直是个温热，可能永远都达不到C2编译的1万次的阀值。</li><li><strong>-XX:-TieredCompilation</strong>，禁止JDK8默认的多层编译，在某些情况下因为有些方法C1编译后C2不再编译，多层编译反而比C2编译慢，如果发现此情况可进行禁止。</li></ol><h3 id="2-GC篇"><a href="#2-GC篇" class="headerlink" title="2. GC篇"></a>2. GC篇</h3><h4 id="2-1-GC策略"><a href="#2-1-GC策略" class="headerlink" title="2.1 GC策略"></a>2.1 GC策略</h4><p>为了稳健，还是8G以下的堆还是CMS好了，G1的细节实现起来难度太大，从理论提出到现在都做了六七年了。</p><p>CMS真正可设的东西也不多，详见<a href="http://ifeve.com/useful-jvm-flags-part-7-cms-collector/" target="_blank" rel="external">JVM实用参数（七）CMS收集器</a></p><p> 1.基本配置</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><p>因为我们的监控系统会通过JMX监控内存达到90%的状况（留点处理的时间），所以设置让它75%就开始跑了，早点开始也能避免Full GC等意外情况(概念重申，这种主动的CMS GC，和JVM的老生代、永久代、堆外内存完全不能分配内存了而强制Full GC是不同的概念)。为了让这个设置生效，还要设置-XX:+UseCMSInitiatingOccupancyOnly，否则75只被用来做开始的参考值，后面还是JVM自己算。</p><ol><li><strong>-XX:MaxTenuringThreshold=2</strong>，这是GC里改动效果最明显的一个参数了。对象在Survivor区熬过多少次Young GC后晋升到年老代，JDK7里看起来默认是6，跑起来好像变成了15。</li></ol><p>Young GC是最大的应用停顿来源，而新生代里GC后存活对象的多少又直接影响停顿的时间，所以如果清楚Young GC的执行频率和应用里大部分临时对象的最长生命周期，可以把它设的更短一点，让其实不是临时对象的新生代长期对象赶紧晋升到年老代，别呆着。</p><p>用-XX:+PrintTenuringDistribution观察下，如果后面几代都差不多，就可以设小，比如JMeter里是2。</p><ol><li><strong>-XX:+ExplicitGCInvokesConcurrent</strong>， 但不要<strong>-XX:+DisableExplicitGC</strong>， 比如<a href="http://calvin1978.blogcn.com/articles/directbytebuffer.html" target="_blank" rel="external">Netty之堆外内存扫盲篇</a>，可见禁了system.gc() 未必是好事，只要自己的代码里没有调它，也没用什么特别烂的类库，真有人调了总有调的原因。-XX+ExplicitGCInvokesConcurrent 则在full gc时，并不全程停顿，依然只在ygc和两个remark阶段停顿，详见<a href="http://lovestblog.cn/blog/2015/05/07/system-gc/" target="_blank" rel="external">JVM源码分析之SystemGC完全解读</a></li><li><strong>-XX: ParallelRefProcEnabled</strong> , 默认为false，并行的处理Reference对象，如WeakReference，除非在GC log里出现Reference处理时间较长的日志，否则效果不会很明显，但我们总是要JVM尽量的并行，所以设了也就设了。</li></ol><h4 id="2-2-GC里不建议修改的参数"><a href="#2-2-GC里不建议修改的参数" class="headerlink" title="2.2 GC里不建议修改的参数"></a>2.2 GC里不建议修改的参数</h4><ol><li><strong>-XX:+CMSClassUnloadingEnabled</strong>，在CMS中清理永久代中的过期的Class而不等到Full GC，JDK7默认关闭而JDK8打开。看自己情况，比如有没有运行动态语言脚本如Groovy产生大量的临时类。它会增加CMS remark的暂停时间，所以如果新类加载并不频繁，这个参数还是不开的好。</li><li>用了CMS，新生代收集默认就是<strong>-XX:+UseParNewGC</strong>，不用自己设。</li><li>并发收集线程数</li></ol><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> ParallelGCThreads＝8+( Processor - 8 ) ( 5/8 )，</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> ConcGCThreads = (ParallelGCThreads + 3)/4</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><p>比如双CPU，六核，超线程就是24个处理器，小于8个处理器时ParallelGCThreads按处理器数量，大于时按上述公式ParallelGCThreads＝18， ConcGCThreads＝5。除了一些不在乎停顿时间的后台辅助程序会特意把它减少，平时不建议动。</p><ol><li><p><strong>-XX:+CMSScavengeBeforeRemark</strong>，默认为关闭，在CMS remark前，先执行一次minor GC将新生代清掉，这样从老生代的对象引用到的新生代对象的个数就少了，停止全世界的CMS remark阶段就短一些。如果看到GC日志里remark阶段的时间超长，可以打开此项看看有没有效果，否则还是不要打开了，白白多了次YGC。</p></li><li><p><strong>-XX:CMSFullGCsBeforeCompaction</strong>，默认为0，即每次full gc都对老生代进行碎片整理压缩。<strong>Full GC 不同于前面设置的75%老生代时触发的CMS GC，只在System.gc()，老生代达到100%，老生代碎片过大无法分配空间给新晋升的大对象这些特殊情况里发生，所以设为每次都进行碎片整理是合适的</strong>。</p><p>CMS并发GC不是“full GC”。HotSpot VM里对concurrent collection和full collection有明确的区分。所有带有“FullCollection”字样的VM参数都是跟真正的full GC相关，而跟CMS并发GC无关的。 </p><p>CMSFullGCsBeforeCompaction这个参数在HotSpot VM里是这样声明的： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">product(<span class="keyword">bool</span>, UseCMSCompactAtFullCollection, <span class="literal">true</span>,                     </div><div class="line"></div><div class="line"><span class="string">"Use mark sweep compact at full collections"</span>)                  </div><div class="line"></div><div class="line">product(uintx, CMSFullGCsBeforeCompaction, <span class="number">0</span>,                          </div><div class="line"></div><div class="line">        <span class="string">"Number of CMS full collection done before compaction if &gt; 0"</span>)</div></pre></td></tr></table></figure><p>然后这样使用的： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">*should_compact =  </div><div class="line">   UseCMSCompactAtFullCollection &amp;&amp;  </div><div class="line">   ((_full_gcs_since_conc_gc &gt;= CMSFullGCsBeforeCompaction) ||  </div><div class="line">    GCCause::is_user_requested_gc(gch-&gt;gc_cause()) ||  </div><div class="line">    gch-&gt;incremental_collection_will_fail(<span class="literal">true</span> <span class="comment">/* consult_young */</span>));</div></pre></td></tr></table></figure><p>CMS GC要决定是否在full GC时做压缩，会依赖几个条件。其中， </p><p>第一种条件，UseCMSCompactAtFullCollection 与 CMSFullGCsBeforeCompaction 是搭配使用的；前者目前默认就是true了，也就是关键在后者上。 </p><p>第二种条件是用户调用了System.gc()，而且DisableExplicitGC没有开启。 </p><p>第三种条件是young gen报告接下来如果做增量收集会失败；简单来说也就是young gen预计old gen没有足够空间来容纳下次young GC晋升的对象。 </p><p>上述三种条件的任意一种成立都会让CMS决定这次做full GC时要做压缩。 </p><p>（还有另一个参数，CMSCompactWhenClearAllSoftRefs，这个就先不说了，反正你没有配置它，而且默认也是true） </p><p>CMSFullGCsBeforeCompaction 说的是，在上一次CMS并发GC执行过后，到底还要再执行多少次full GC才会做压缩。默认是0，也就是在默认配置下每次CMS GC顶不住了而要转入full GC的时候都会做压缩。 </p><p><strong>把CMSFullGCsBeforeCompaction配置为10，就会让上面说的第一个条件变成每隔10次真正的full GC才做一次压缩（而不是每10次CMS并发GC就做一次压缩，目前VM里没有这样的参数）。这会使full GC更少做压缩，也就更容易使CMS的old gen受碎片化问题的困扰。</strong> </p><p><strong>本来这个参数就是用来配置降低full GC压缩的频率，以期减少某些full GC的暂停时间。CMS回退到full GC时用的算法是mark-sweep-compact，但compaction是可选的，不做的话碎片化会严重些但这次full GC的暂停时间会短些；这是个取舍。</strong></p><p>​</p></li></ol><h4 id="2-3-内存大小的设置"><a href="#2-3-内存大小的设置" class="headerlink" title="2.3 内存大小的设置"></a>2.3 内存大小的设置</h4><p>这些关于大小的参数，给人感觉是最踏实可控的。</p><p>其实JVM除了显式设置的-Xmx堆内存，还有一堆其他占内存的地方(堆外内存，线程栈，永久代，二进制代码cache)，在容量规划的时候要留意。</p><p>关键业务系统的服务器上内存一般都是够的，所以尽管设得宽松点。</p><ol><li><strong>-Xmx, -Xms</strong>, 堆内存大小，2～4G均可，再大了注意GC时间。</li><li><strong>-Xmn or -XX:NewSize and -XX:MaxNewSize or -XX:NewRatio</strong>， JDK默认新生代占堆大小的1/3， 个人喜欢把对半分， 增大新生代的大小，能减少GC的频率（但也会加大每次GC的停顿时间），主要是看老生代里没多少长期对象的话，占2/3太多了。可以用-Xmn 直接赋值(等于-XX:NewSize and -XX:MaxNewSize同值的缩写)，或把NewRatio设为1来对半分(但如果想设置新生代比老生代大就只能用-Xmn)。</li><li><strong>-XX: PermSize=128m -XX:MaxPermSize=512m （JDK7）</strong>现在的应用有Hibernate/Spring这些闹腾的家伙AOP之后类都比较多，可以一开始就把初始值从64M设到128M，并设一个更大的Max值以求保险，之前就遇到反射的类过多把永久代撑爆的案例，不过这时候业务也应该考虑拆分了，过多的代码集中在同个项目中，长期看来不易于维护。</li><li><strong>-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m（JDK8）</strong>，JDK8的永生代几乎可用完机器的所有内存(可怕😱)，同样设一个128M的初始值，512M的最大值保护一下。</li></ol><h4 id="2-4-其他内存大小等可选设置"><a href="#2-4-其他内存大小等可选设置" class="headerlink" title="2.4 其他内存大小等可选设置"></a>2.4 其他内存大小等可选设置</h4><ol><li><strong>-XX:SurvivorRatio</strong> 新生代中每个存活区的大小，默认为8，即1/10的新生代 1/(SurvivorRatio+2)，有人喜欢设小点省点给新生代，但要避免太小使得存活区放不下临时对象而要晋升到老生代，还是从GC Log里看实际情况了。</li></ol><ol><li><strong>-Xss</strong> 在堆之外，线程占用栈内存，默认每条线程为1M（以前是256K）。存放方法调用出参入参的栈，局部变量，标量替换后掉局部变量等，有人喜欢设小点节约内存开更多线程。但反正内存够也就不必要设小，有人喜欢再设大点，特别是有JSON解析之类的递归调用时不能设太小。</li><li><strong>-XX:MaxDirectMemorySize</strong>，堆外内存/直接内存的大小，默认为Heap区总内存减去一个Survivor区的大小，详见<a href="http://calvin1978.blogcn.com/articles/directbytebuffer.html" target="_blank" rel="external">Netty之堆外内存扫盲篇</a>。</li><li><strong>-XX:ReservedCodeCacheSize</strong>， JIT编译后二进制代码的存放区，满了之后就不再编译。JDK7默认不开多层编译48M，开了96M，而JDK8默认开多层编译240M。可以在JMX里看看CodeCache的大小，JDK7下的48M一般够了，也可以把它设大点，反正内存多。</li></ol><h4 id="2-5-GC日志"><a href="#2-5-GC日志" class="headerlink" title="2.5 GC日志"></a>2.5 GC日志</h4><p> 1.基本配置</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash">  -Xloggc:/dev/shm/gc.log -XX:+PrintGCDateStamps -XX:+PrintGCDetails</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>一般的，上面的就足够了，我们生产环境一个离线服务的配置是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationConcurrentTime -XX:+PrintHeapAtGC -Xloggc:/dev/shm/xx_gclog.txt</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><p>详见<a href="http://ifeve.com/useful-jvm-flags-part-8-gc-logging/" target="_blank" rel="external">JVM实用参数（八）GC日志</a>，有人担心写GC日志会影响性能，但测试下来实在没什么影响，还是留一份用来排查好。</p><p>到后来，又发现如果遇上高IO的情况，如果GC的时候，操作系统正在flush pageCache 到磁盘，也可能导致GC log文件被锁住，从而让GC结束不了。所以把它指向了/dev/shm 这种内存中文件系统，避免这种停顿，详见<a href="http://calvin1978.blogcn.com/articles/%E2%80%9Chttp://engineering.linkedin.com/blog/2016/02/eliminating-large-jvm-gc-pauses-caused-by-background-io-traffic%E2%80%9D" target="_blank" rel="external">Eliminating Large JVM GC Pauses Caused by Background IO Traffic</a></p><p>用+PrintGCDateStamps而不是PrintGCTimeStamps，打印可读的日期而不是时间戳。</p><ol><li><strong>-XX:+PrintGCApplicationStoppedTime</strong>，它的名字没起好，它除了打印清晰的GC停顿时间外，还可以打印其他的停顿时间，比如取消偏向锁，class 被agent redefine，code deoptimization等等，有助于发现一些原来没想到的问题，建议也加上。如果真的发现了一些不知什么的停顿，再临时加上<code>&quot;-XX:+PrintSafepointStatistics -XX: PrintSafepointStatisticsCount=1&quot;</code> 找原因。</li><li>GC日志默认会在重启后清空，但有人担心长期运行不重启的应用会把文件弄得很大，有<figure class="highlight plain"><figcaption><span>-XX:NumberOfGCLogFiles</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">### 3. 监控篇</div><div class="line"></div><div class="line">JVM输出的各种日志，如果未指定路径，通常会生成到运行应用的相同目录，为了避免有时候在不同的地方执行启动脚本，一般将日志路径集中设到一个固定的地方。</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">#### 3.1 -XX:+PrintCommandLineFlags</div><div class="line"></div><div class="line">运维有时会对启动参数做一些临时的更改，将每次启动的参数输出到stdout，将来有据可查。</div><div class="line">打印出来的是命令行里设置了的参数以及因为这些参数隐式影响的参数，比如开了CMS后，-XX:+UseParNewGC也被自动打开。</div><div class="line"></div><div class="line">#### 3.2 -XX:-OmitStackTraceInFastThrow</div><div class="line"></div><div class="line">为异常设置StackTrace是个昂贵的操作，所以当应用在相同地方抛出相同的异常N次(两万?)之后，JVM会对某些特定异常如NPE，数组越界等进行优化，不再带上异常栈。此时，你可能会看到日志里一条条Nul Point Exception，而真正输出完整栈的日志早被滚动到不知哪里去了，也就完全不知道这NPE发生在什么地方，欲哭无泪。 所以，将它禁止吧。</div><div class="line"></div><div class="line">#### 3.3 coredump与 -XX:ErrorFile</div><div class="line"></div><div class="line">JVM crash时，hotspot 会生成一个error文件，提供JVM状态信息的细节。如前所述，将其输出到固定目录，避免到时会到处找这文件。文件名中的%p会被自动替换为应用的PID</div><div class="line"></div><div class="line">&gt; ```shell</div><div class="line">&gt;  -XX:ErrorFile=$&#123;MYLOGDIR&#125;/hs_err_%p.log</div><div class="line">&gt;</div></pre></td></tr></table></figure></li></ol><p>&gt;</p><blockquote></blockquote><p>当然，更好的做法是生成coredump，从CoreDump能够转出Heap Dump 和 Thread Dump 还有crash的地方，非常实用。</p><p>在启动脚本里加上 ulimit -c unlimited或其他的设置方式，如果有root权限，设一下输出目录更好</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash">  <span class="built_in">echo</span> <span class="string">"/&#123;MYLOGDIR&#125;/coredump.%p"</span> &gt; /proc/sys/kernel/core_pattern</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><p>什么？你不知道这coredump有什么用？看来你是没遇过JVM Segment Fault的幸福人。</p><h4 id="3-4-XX-HeapDumpOnOutOfMemoryError"><a href="#3-4-XX-HeapDumpOnOutOfMemoryError" class="headerlink" title="3.4 -XX:+HeapDumpOnOutOfMemoryError"></a>3.4 -XX:+HeapDumpOnOutOfMemoryError</h4><p>在Out Of Memory，JVM快死快死掉的时候，输出Heap Dump到指定文件。不然开发很多时候还真不知道怎么重现错误。</p><p>路径只指向目录，JVM会保持文件名的唯一性，叫java_pid${pid}.hprof。如果指向文件，而文件已存在，反而不能写入。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> -XX:+HeapDumpOnOutOfMemoryError </span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> -XX:HeapDumpPath=<span class="variable">$&#123;LOGDIR&#125;</span>/</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><h4 id="3-5-JMX"><a href="#3-5-JMX" class="headerlink" title="3.5 JMX"></a>3.5 JMX</h4><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash">  -Dcom.sun.management.jmxremote.port=<span class="variable">$&#123;MY_JMX_PORT&#125;</span> -Dcom.sun.management.jmxremote </span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> -Dcom.sun.management.jmxremote.authenticate=<span class="literal">false</span> -Dcom.sun.management.jmxremote.ssl=<span class="literal">false</span> </span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> -Djava.rmi.server.hostname=127.0.0.1</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><p>以上设置，只让本地的Zabbix之类监控软件通过JMX监控JVM，不允许远程访问。</p><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><h4 id="4-1-性能相关"><a href="#4-1-性能相关" class="headerlink" title="4.1 性能相关"></a>4.1 性能相关</h4><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:-UseBiasedLocking </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:-UseCounterDecay </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:AutoBoxCacheMax=20000 </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:+PerfDisableSharedMem </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:+AlwaysPreTouch </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -Djava.security.egd=file:/dev/./urandom</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><h4 id="4-2-内存大小相关-JDK7"><a href="#4-2-内存大小相关-JDK7" class="headerlink" title="4.2 内存大小相关(JDK7)"></a>4.2 内存大小相关(JDK7)</h4><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash">  -Xms4096m </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -Xmx4096m </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -Xmn2048m </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:MaxDirectMemorySize=4096m </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX: PermSize=256m </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:MaxPermSize=512m </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:ReservedCodeCacheSize=240M</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><h4 id="4-3-CMS-GC-相关"><a href="#4-3-CMS-GC-相关" class="headerlink" title="4.3 CMS GC 相关"></a>4.3 CMS GC 相关</h4><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:+UseConcMarkSweepGC </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:CMSInitiatingOccupancyFraction=75 </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:+UseCMSInitiatingOccupancyOnly </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:MaxTenuringThreshold=6 </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:+ExplicitGCInvokesConcurrent </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:+ParallelRefProcEnabled</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><h4 id="4-4-GC-日志-相关"><a href="#4-4-GC-日志-相关" class="headerlink" title="4.4 GC 日志 相关"></a>4.4 GC 日志 相关</h4><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash">  -Xloggc:/dev/shm/app-gc.log </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:+PrintGCApplicationStoppedTime </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:+PrintGCDateStamps </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:+PrintGCDetails</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><h4 id="4-5-异常-日志-相关"><a href="#4-5-异常-日志-相关" class="headerlink" title="4.5 异常 日志 相关"></a>4.5 异常 日志 相关</h4><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:-OmitStackTraceInFastThrow </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:ErrorFile=<span class="variable">$&#123;LOGDIR&#125;</span>/hs_err_%p.log </span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:+HeapDumpOnOutOfMemoryError</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">  -XX:HeapDumpPath=<span class="variable">$&#123;LOGDIR&#125;</span>/</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure></blockquote><h4 id="4-6-JMX相关"><a href="#4-6-JMX相关" class="headerlink" title="4.6 JMX相关"></a>4.6 JMX相关</h4><p>见3.5</p><h3 id="最后，上图总结一把："><a href="#最后，上图总结一把：" class="headerlink" title="最后，上图总结一把："></a>最后，上图总结一把：</h3><p><img src="https://ww3.sinaimg.cn/large/006tNc79gw1fblo4zsqbdj317k1he1kx.jpg" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p> <a href="http://calvin1978.blogcn.com/articles/jvmoption-2.html" target="_blank" rel="external">JVM参数推荐</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言1，资料&quot;&gt;&lt;a href=&quot;#前言1，资料&quot; class=&quot;headerlink&quot; title=&quot;前言1，资料&quot;&gt;&lt;/a&gt;前言1，资料&lt;/h3&gt;&lt;p&gt;学习开源项目的启动脚本是个不错的主意，比如&lt;a href=&quot;http://github.com/apache
      
    
    </summary>
    
      <category term="jvm" scheme="http://chen-tao.github.io/categories/jvm/"/>
    
    
      <category term="java" scheme="http://chen-tao.github.io/tags/java/"/>
    
      <category term="jvm" scheme="http://chen-tao.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JIT编译器解读</title>
    <link href="http://chen-tao.github.io/2017/01/09/jit/"/>
    <id>http://chen-tao.github.io/2017/01/09/jit/</id>
    <published>2017-01-08T16:00:00.000Z</published>
    <updated>2017-09-11T05:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么JIT"><a href="#为什么JIT" class="headerlink" title="为什么JIT"></a>为什么JIT</h2><p><strong>JIT 是 just in time 的缩写, 也就是即时编译编译器。</strong>使用即时编译器技术，能够加速程序的执行速度。</p><p>以Java/C#,NET为代表的Coffee Based 语言，是建立在虚拟机之上的。</p><p>这种虚拟机和一般其他语言的运行库有一个很大不同，就是它好像一个有独立体系结构的计算机。 </p><p>Java/C#,NET的程序要运行在这些虚拟机之上，就必须要编译成虚拟机独有的中间语言。Java叫字节码，C#,NET有很多种叫法，姑且简称CIL。这些中间语言身上有很深很深的汇编指令集样式语法痕迹，这也从 另一个侧面说明虚拟机的体系结构多么像一个冯诺依曼计算机。</p><p>虚拟机传统的解释器，就是要在中间语言，和真正的平台体系结构之间的指令做映射。比如把Java的load指令换成native code 的load指令。</p><p> <strong>JIT的出现，是为了补强虚拟机边运行边解释的低性能。它会智能地对热点代码进行优化且重复利用。从策略的角度来讲，就是通过查表或者缓存而不是重复解决子问题而大大缩短解决问题的时间。</strong></p><p><u><em>它的优点是，智能缩短映射的过程。</em></u></p><p><u><em>它的缺点是，过于复杂。</em></u></p><p>首先代码优化的种种策略都是基于各种各样的假定，假定不一定会成真，即使费尽心机做的代码优化，也有可能在现实中无法提高性能。其次，不同平台和体系结构的技术特点千差万别，这个映射过程只能单独定制。比如至今Java平台还不能在IOS上做基本映射（即解释器都不行）。</p><p>以前JIT刚出现的时候，只是一个挂载的外挂一样的东西。现在开始喧宾夺主取代了解释器。这种转变其实是对中间语言解释器作为一个“薄的胶合层”的一个设计上的自我否定，极大地增加了设计的复杂性。目前对于这种强行加速做得比较好的，就是Java系为代表的各种虚拟机，微软的虚拟机，或者谷歌搞出来的V8引擎（这不知道是不是目前为止设计进生产实践中惟一被广泛应用的动态强行加速）。这几件东西其实无一不是大型商业公司的强大支持的产物。现在主流的动态语言大多都是社区在推进，没那么多资源来投入JIT，这是他们没有好的JIT的一个关键因素。</p><p>本身动态语言的应用场景就不是为了追求高性能，更何况现在各种应用场景下的瓶颈大部分都在语言之外，语言的性能考量又是一个比较次要的需求了。但是JIT对于编译层的优化还是显而易见的，甚至可以说汇聚了很多生产环境中的经验，通过JIT的优化，服务的请求质量可以提升一个档次，对于业务帮助也很大，下面我们着重介绍一下java中的JIT与其实现。</p><h2 id="Java中的JIT"><a href="#Java中的JIT" class="headerlink" title="Java中的JIT"></a>Java中的JIT</h2><p><img src="https://ww3.sinaimg.cn/large/006y8lVagw1fbldh80l07j30fh0h576f.jpg" alt=""> </p><pre><code>Java程序最初是仅仅通过解释器解释执行的，即对字节码逐条解释执行，这种方式的执行速度相对会比较慢，尤其当某个方法或代码块运行的特别频繁时，这种方式的执行效率就显得很低。于是后来在虚拟机中引入了JIT编译器（即时编译器），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是JIT编译器。现在主流的商用虚拟机（如Sun HotSpot、IBM J9）中几乎都同时包含解释器和编译器（三大商用虚拟机之一的JRockit是个例外，它内部没有解释器，因此会有启动相应时间长之类的缺点，但它主要是面向服务端的应用，这类应用一般不会重点关注启动时间）。二者各有优势：当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行；当程序运行后，随着时间的推移，编译器逐渐会返回作用，把越来越多的代码编译成本地代码后，可以获取更高的执行效率。解释执行可以节约内存，而编译执行可以提升效率。HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，分别对应JVM的Client与Server模式，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。</code></pre><p>运行过程中会被即时编译器编译的“热点代码”有两类：</p><ul><li>被多次调用的方法。</li><li><p>被多次调用的循环体。</p><p>  两种情况，编译器都是以整个方法作为编译对象，这种编译也是虚拟机中标准的编译方式。要知道一段代码或方法是不是热点代码，是不是需要触发即时编译，需要进行Hot Spot Detection（热点探测）。目前主要的热点 判定方式有以下两种：</p></li><li><p>基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</p></li><li><p>基于计数器的热点探测：采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。</p><p>  在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。</p><p>  方法调用计数器用来统计方法调用的次数，在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数。</p><p>  回边计数器用于统计一个方法中循环体代码执行的次数（准确地说，应该是回边的次数，因为并非所有的循环都是回边），在字节码中遇到控制流向后跳转的指令就称为“回边”。</p><p>  在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阀值，当计数器的值超过了阀值，就会触发JIT编译。触发了JIT编译后，在默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成为止（编译工作在后台线程中进行）。当编译工作完成后，下一次调用该方法或代码时，就会使用已编译的版本。</p><p>  由于方法计数器触发即时编译的过程与回边计数器触发即时编译的过程类似，因此这里仅给出方法调用计数器触发即时编译的流程：</p></li></ul><p><img src="https://ww2.sinaimg.cn/large/006y8lVagw1fbldpe8c6vj30f50gut9l.jpg" alt=""></p><h2 id="jvm使用JIT"><a href="#jvm使用JIT" class="headerlink" title="jvm使用JIT"></a>jvm使用JIT</h2><p><strong>JIT是java性能在同等条件下课超越C系列语言的关键！</strong></p><p><img src="https://ww3.sinaimg.cn/large/006y8lVagw1fbldzegb7sj31380lmae5.jpg" alt=""></p><p><a href="https://wiki.openjdk.java.net/display/HotSpot/PerformanceTacticIndex" target="_blank" rel="external">JIT优化项一览(2009)</a></p><p><img src="https://ww1.sinaimg.cn/large/006y8lVagw1fbldzuain2j31360m40vp.jpg" alt=""></p><p><img src="https://ww3.sinaimg.cn/large/006y8lVagw1fble0dpvrwj31320m0q76.jpg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html" target="_blank" rel="external">hello_JIT</a></p><p><a href="http://blog.csdn.net/ns_code/article/details/18009455" target="_blank" rel="external">javac与JIT编译</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/" target="_blank" rel="external">深入浅出JIT</a></p><p><a href="http://calvin1978.blogcn.com/articles/javatuning.html" target="_blank" rel="external">java性能优化指南</a></p><p><a href="https://github.com/adoptopenjdk/jitwatch" target="_blank" rel="external">jitwatch github</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么JIT&quot;&gt;&lt;a href=&quot;#为什么JIT&quot; class=&quot;headerlink&quot; title=&quot;为什么JIT&quot;&gt;&lt;/a&gt;为什么JIT&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;JIT 是 just in time 的缩写, 也就是即时编译编译器。&lt;/strong&gt;使用
      
    
    </summary>
    
      <category term="jvm" scheme="http://chen-tao.github.io/categories/jvm/"/>
    
    
      <category term="java" scheme="http://chen-tao.github.io/tags/java/"/>
    
      <category term="jvm" scheme="http://chen-tao.github.io/tags/jvm/"/>
    
      <category term="jit" scheme="http://chen-tao.github.io/tags/jit/"/>
    
  </entry>
  
  <entry>
    <title>java单例模式与指令重排</title>
    <link href="http://chen-tao.github.io/2016/12/30/about-java-singleton/"/>
    <id>http://chen-tao.github.io/2016/12/30/about-java-singleton/</id>
    <published>2016-12-29T16:00:00.000Z</published>
    <updated>2017-09-11T05:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 今天看到之前某同学写的单例创建异步httoclient的代码，发现了一个双重校验线程安全的问题，这里顺带回顾一下单例，重点介绍一下单例的2种经典实现–基于volatile的双重校验 和 静态内部类</p></blockquote><h2 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h2><p>当被问到要实现一个单例模式时，很多人的第一反应是写出如下的代码，包括教科书上也是这样教我们的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">         instance = <span class="keyword">new</span> Singleton();</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。</p><h2 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h2><p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">        instance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。</p><h2 id="双重检验锁-重点"><a href="#双重检验锁-重点" class="headerlink" title="双重检验锁(重点)"></a>双重检验锁(重点)</h2><p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 <code>instance == null</code>，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         <span class="comment">//Single Checked</span></div><div class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                 <span class="comment">//Double Checked</span></div><div class="line">                instance = <span class="keyword">new</span> Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance ;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码看起来很完美，很可惜，它是有问题。主要在于<code>instance = new Singleton()</code>这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p><ol><li>给 instance 分配内存</li><li>调用 Singleton 的构造函数来初始化成员变量</li><li>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</li></ol><p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p><p>我们只需要将 instance 变量声明成 volatile 就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance; <span class="comment">//声明成 volatile</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         </div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;       </div><div class="line">                    instance = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p><p>但是特别注意在 jdk 1.5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 jdk 1.5 (JSR-133)中才得以修复，这时候jdk对volatile增强了语义，对volatile对象都会加入读写的内存屏障，以此来保证『可见性』，这时候2-3就变成了代码序而不会被CPU重排，所以在这之后才可以放心使用 volatile。</p><h2 id="饿汉式-static-final-field-正常的初始化"><a href="#饿汉式-static-final-field-正常的初始化" class="headerlink" title="饿汉式 static final field(正常的初始化)"></a>饿汉式 static final field(正常的初始化)</h2><p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="comment">//类加载时就初始化</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p><h2 id="静态内部类-static-nested-class-重点"><a href="#静态内部类-static-nested-class-重点" class="headerlink" title="静态内部类 static nested class(重点)"></a>静态内部类 static nested class(重点)</h2><p>我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE; </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p><h2 id="枚举-Enum"><a href="#枚举-Enum" class="headerlink" title="枚举 Enum"></a>枚举 Enum</h2><p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EasySingleton&#123;</div><div class="line">    INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking。</p><p>传统单例存在的另外一个问题是<strong>一旦你实现了序列化接口，可以反序列化创建该实例，那么它们不再保持单例了</strong>，因为readObject()方法一直返回一个新的对象就像java的构造方法一样，你可以通过使用readResolve()方法来避免此事发生，看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> Single.INSTANCE.getInstance();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样甚至还可以更复杂，如果你的单例类维持了其他对象的状态的话，因此你需要使他们成为transient的对象。但是枚举单例，JVM对序列化有保证，为了保证枚举类型像Java规范中所说的那样，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定。我们可以查看枚举源码来说明这个问题， 所有的Java枚举类型都继承自该抽象类。我们用关键字enum来声明枚举类型，不可以通过显式继承该抽象类的方式来声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;  </div><div class="line">    <span class="comment">// 当前枚举常量名称  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> name;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ordinal;  </div><div class="line">    <span class="comment">// 当前枚举常量次序，从0开始  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">ordinal</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> ordinal;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 专有构造器，我们无法调用。该构造方法用于由响应枚举类型声明的编译器发出的代码。   </span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;  </div><div class="line">    <span class="keyword">this</span>.name = name;  </div><div class="line">    <span class="keyword">this</span>.ordinal = ordinal;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 返回枚举常量的名称，默认是返回name值。可以重写该方法，输出更加友好的描述。  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> name;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 比较当前枚举常量是否和指定的对象相等。因为枚举常量是单例的，所以直接调用==操作符。子类不可以重写该方法。 </span></div><div class="line">    <span class="comment">//由于子类是不能重写这个方法   保证枚举本身就是单例  线程安全</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;   </div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>==other;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 返回该枚举常量的哈希码。和equals一致，该方法不可以被重写。  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 因为枚举常量是单例的，所以不允许克隆。  </span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;  </div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportedException();  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 比较该枚举常量和指定对象的大小。它们的类型要相同，根据它们在枚举声明中的先后顺序来返回大小（前面的小，后面的大）。子类不可以重写该方法  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(E o)</span> </span>&#123;  </div><div class="line">    Enum other = (Enum)o;  </div><div class="line">    Enum self = <span class="keyword">this</span>;  </div><div class="line">    <span class="keyword">if</span> (self.getClass() != other.getClass() &amp;&amp; <span class="comment">// optimization  </span></div><div class="line">            self.getDeclaringClass() != other.getDeclaringClass())  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();  </div><div class="line">    <span class="keyword">return</span> self.ordinal - other.ordinal;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 得到枚举常量所属枚举类型的Class对象  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Class&lt;E&gt; <span class="title">getDeclaringClass</span><span class="params">()</span> </span>&#123;  </div><div class="line">    Class clazz = getClass();  </div><div class="line">    Class zuper = clazz.getSuperclass();  </div><div class="line">    <span class="keyword">return</span> (zuper == Enum.class) ? clazz : zuper;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 返回带指定名称的指定枚举类型的枚举常量。名称必须与在此类型中声明枚举常量所用的标识符完全匹配。不允许使用额外的空白字符。  </span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType, String name)</span> </span>&#123;  </div><div class="line">        T result = enumType.enumConstantDirectory().get(name);  </div><div class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>)  </div><div class="line">            <span class="keyword">return</span> result;  </div><div class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>)  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Name is null"</span>);  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(  </div><div class="line">            <span class="string">"No enum const "</span> + enumType +<span class="string">"."</span> + name);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 不允许反序列化枚举对象  从这里我们可以看出枚举在反序列化创建对象的时候也能保证实例是单例的 </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException,  </span></div><div class="line"><span class="function">        ClassNotFoundException </span>&#123;  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"can't deserialize enum"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 不允许反序列化枚举对象  </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"can't deserialize enum"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 枚举类不可以有finalize方法，子类不可以重写该方法  保证实例的对象唯一</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123; &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来说，单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举。上述所说都是线程安全的实现，文章开头给出的第一种方法不算正确的写法。</p><p>这里要特别注意的是，双重检验锁的方法，需要在instance上加volatile，这样才能保证线程安全。</p><p>这里的建议是：</p><h4 id="条件允许-JDK5-，这个条件很容易满足了-，使用单例是最好的方法。"><a href="#条件允许-JDK5-，这个条件很容易满足了-，使用单例是最好的方法。" class="headerlink" title="条件允许(JDK5+，这个条件很容易满足了)，使用单例是最好的方法。"></a>条件允许(JDK5+，这个条件很容易满足了)，使用单例是最好的方法。</h4><h4 id="其他正常情况下，最好的方法是使用静态内部类或者饿汉式，毕竟对于大多数业务场景，正常的初始化要优于延迟初始化，内部类方式可以写的很『优秀』，而对于新手来说，饿汉式很简单且不易出错；如果需要对实例字段进行线程安全的延迟初始化，则可以用基于volatile的延迟方案；如果需要对静态字段进行线程安全的延迟初始化，则依然使用静态内部类的初始化方法。"><a href="#其他正常情况下，最好的方法是使用静态内部类或者饿汉式，毕竟对于大多数业务场景，正常的初始化要优于延迟初始化，内部类方式可以写的很『优秀』，而对于新手来说，饿汉式很简单且不易出错；如果需要对实例字段进行线程安全的延迟初始化，则可以用基于volatile的延迟方案；如果需要对静态字段进行线程安全的延迟初始化，则依然使用静态内部类的初始化方法。" class="headerlink" title="其他正常情况下，最好的方法是使用静态内部类或者饿汉式，毕竟对于大多数业务场景，正常的初始化要优于延迟初始化，内部类方式可以写的很『优秀』，而对于新手来说，饿汉式很简单且不易出错；如果需要对实例字段进行线程安全的延迟初始化，则可以用基于volatile的延迟方案；如果需要对静态字段进行线程安全的延迟初始化，则依然使用静态内部类的初始化方法。"></a>其他正常情况下，最好的方法是使用静态内部类或者饿汉式，毕竟对于大多数业务场景，正常的初始化要优于延迟初始化，内部类方式可以写的很『优秀』，而对于新手来说，饿汉式很简单且不易出错；如果需要对实例字段进行线程安全的延迟初始化，则可以用基于volatile的延迟方案；如果需要对静态字段进行线程安全的延迟初始化，则依然使用静态内部类的初始化方法。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 今天看到之前某同学写的单例创建异步httoclient的代码，发现了一个双重校验线程安全的问题，这里顺带回顾一下单例，重点介绍一下单例的2种经典实现–基于volatile的双重校验 和 静态内部类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id
      
    
    </summary>
    
    
      <category term="java" scheme="http://chen-tao.github.io/tags/java/"/>
    
      <category term="jvm" scheme="http://chen-tao.github.io/tags/jvm/"/>
    
  </entry>
  
</feed>
