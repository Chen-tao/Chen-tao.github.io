<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chen-Tao</title>
  
  <subtitle>颂其诗，读其书，不知其人，可乎？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chen-tao.github.io/"/>
  <updated>2018-05-27T12:29:54.241Z</updated>
  <id>http://chen-tao.github.io/</id>
  
  <author>
    <name>Chen Tao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编程的经验</title>
    <link href="http://chen-tao.github.io/2018/05/27/write-code-exp/"/>
    <id>http://chen-tao.github.io/2018/05/27/write-code-exp/</id>
    <published>2018-05-26T16:00:00.000Z</published>
    <updated>2018-05-27T12:29:54.241Z</updated>
    
    <content type="html"><![CDATA[<p>有经验的程序员会做到下面 29 项事情，这也是每个新手程序员应该知道的事情。</p><p>如果你想成为更好的开发者，你应该尤其注意第15 点和第29 点。</p><ol><li><p><strong>积极大胆地谷歌。</strong>你得知道如何有效地组织搜索关键字，查阅别人写的代码，然后合理地用在代码里，从而解决问题。</p></li><li><p><strong>拥抱变化，坚持不懈。</strong>老手程序员在接触新技术时，能欣然接受像个初学者一样处处受挫，并总能在完成工作的同时自学成才。</p></li><li><p><strong>承认细节的重要性。</strong>例如变量和函数的命名、CSS 属性的命名、该用哈希还是用数组，以及其他看起来微不足道，但可能对项目有深远影响的事情。</p></li><li><p><strong>承认大多数的“重要决定”其实并没有那么重要。</strong>一般的开发者经常在技术选型等“重大问题”上陷入唇枪舌战，而程序员老鸟们会避免浪费时间在骂战中。这一点上，他们就像禅宗大师一样（zen-like）。</p></li><li><p><strong>选择合适的工具解决问题。</strong>网上有无数的开源库、工具和框架，让人眼花缭乱。而老手们清楚地知道针对怎样的问题，应该用什么样的工具。</p></li><li><p><strong>明白代码「不值钱」（该删就删）。</strong>你必须习惯于删掉几百行代码来重写程序的某一部分，毫不留情。</p></li><li><p><strong>在评估技术的时候要全面。</strong>例如，我一直在鼓吹Elixir。它语法优美，社区完善，有很大的潜力。但Elixir诞生的时间太短，所以如果要构建复杂的功能，可能会难以找到能帮你提高效率的开源工具。因此，在评估要不要选择使用一项技术时，你得把所有这些因素都考虑在内。</p></li><li><p><strong>学会说“我不知道”。</strong>没有比拒绝承认自己不知道更能浪费一个开发者的时间了。</p></li><li><p><strong>仔细分析错误信息里的线索。</strong>传统教育告诉我们：失败是坏事。报错信息这种东西也经常被跟失败联系起来，然而优秀程序员明白，这些错误消息里其实隐藏着能将你指向最终正确解决方案的线索。</p></li><li><p><strong>了解过早优化和必要的“炫技式”优化的区别。</strong>老手们清楚在什么时候需要写一些看上去没那么好懂，但会让程序运行更快的代码。</p></li><li><p><strong>每个人都会犯错，为自己的过失负责。</strong>而尤其在团队里，把责任推来推去没有任何意义，因为错误的发生往往不只是一方的因素造成的。</p></li><li><p><strong>成为你所用的开发工具的重度用户。</strong>如果长期在某个开发环境下有相当比例的开发工作，那你应该去掌握使用它的细节。</p></li><li><p><strong>学会用Vim（至少会一点）。</strong> 你至少应该在这个编辑器里学会勉强地移动和翻页。</p></li><li><p><strong>不要接陌生技术领域的私活。</strong>个人做自由职业项目，其中很大一部分挑战就是评估项目时间。不要规划自己未知领域的事情，那会让你处于想当尴尬的境地。</p></li><li><p><strong>不要数你干活花了几个小时。</strong>技术大牛会把时间花在有深度的工作上，并且他们清楚花了多少时间完全不重要。</p></li><li><p><strong>学会坦然接受批评。</strong>当你的代码因为各种原因四分五裂时，你需要培养用理性和逻辑的方式来应对（而不是情绪化处理）。</p></li><li><p><strong>同有更多经验的人结对编程。</strong>没有比这个更高效的编程学习方式了。</p></li><li><p><strong>一定要先自己做一遍代码审查。</strong>当你在GitHub上发起一个pull request之前，先把代码当成别人写的，自己先审查一遍。</p></li><li><p><strong>认识到做自由职业的难点不是写代码，而是其余的所有事情。</strong>销售、推广、客户支持，质量保证以及产品管理，所有这些都会花费大量时间。</p></li><li><p><strong>发现并解决更大的问题。</strong>优秀的程序员不拘泥于眼前的问题，而是清楚如何用更长远的方式彻底的解决这一类问题。</p></li><li><p><strong>深入了解一些大型开源项目的核心能让你开发时如虎添翼。</strong>如果你知道如何给你的项目打猴子补丁(Monkey Patch), 那么你将无所不能。</p></li><li><p><strong>跳过多数的会议。</strong>你的公司雇你是来写代码的，而不是谈代码的。当会议多到失控的时候，不去参加也没有任何问题。而且一旦你开始这样做，别人会更珍惜你的时间。</p></li><li><p><strong>知道什么时候开始回馈。</strong> 到了某个时候你需要将你的技能和经验传授给年轻的开发人员，就像你的导师当时教授你一样。</p></li><li><p><strong>能写烂代码。</strong>有时候可以当一当“胶带式程序员”。关键是随着时间推移，你需要弄清楚什么时候可以走捷径，什么时候必须走捷径。这其实是最难掌握的技能之一。</p></li><li><p><strong>礼貌地告诉别人你工作到很晚。</strong>如果你是办公室里最后一个，可以发一封简短的汇报邮件。别人一般会注意到邮件上的时间戳的。</p></li><li><p><strong>像一个领导者(Leader)一样做事，而不是老板(Boss)。</strong>老板是让别人为他工作的人，领导者是人们追随的人。做个领导者。</p></li><li><p><strong>去打打桌上足球。</strong>从长期来看，同其他开发者（或不同岗位上的同事）建立联系会比在紧巴巴的期限里交付一个功能更有价值。</p></li><li><p><strong>在压力下学习。</strong>你需要知道如何应对像系统宕机而你要负责将它复原的情况，即使一开始你完全没有头绪。</p></li><li><p><strong>“Move fast and break things” 别让完美主义阻止你做事。</strong>错误往往是最好的学习机会。所以别把犯错当作失败，而应该把它们当作值得学习的经历，并意识到：正是不断克服和突破这些错误，作为一个程序员，你才能不断成长起来。</p></li></ol><p>像生活中的很多事情一样，编程也是你做的越多，了解的就越多。所以如果你是一个新手程序员，还是直接去编码吧。记得将这些最佳实践应用在日常工作中，来不断提升你的编程技艺。</p>]]></content>
    
    <summary type="html">
    
      From Ken Mazaika
    
    </summary>
    
      <category term="感悟" scheme="http://chen-tao.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="感悟" scheme="http://chen-tao.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="人生" scheme="http://chen-tao.github.io/tags/%E4%BA%BA%E7%94%9F/"/>
    
      <category term="通用技能" scheme="http://chen-tao.github.io/tags/%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
      <category term="能力提升" scheme="http://chen-tao.github.io/tags/%E8%83%BD%E5%8A%9B%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>golang Map 并发安全的几个点</title>
    <link href="http://chen-tao.github.io/2018/01/30/go-sync-map/"/>
    <id>http://chen-tao.github.io/2018/01/30/go-sync-map/</id>
    <published>2018-01-29T16:00:00.000Z</published>
    <updated>2018-01-30T02:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现1"><a href="#实现1" class="headerlink" title="实现1"></a>实现1</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// map_safe.go</span></div><div class="line"><span class="comment">// Copyright (C) 2018 chentao &lt;chentao@chentaos-MacBook-Pro.local&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Distributed under terms of the MIT license.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line"><span class="string">"fmt"</span></div><div class="line"><span class="string">"sync"</span></div><div class="line"><span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> ctr <span class="keyword">struct</span> &#123;</div><div class="line">sync.RWMutex</div><div class="line">m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">counter := &amp;ctr&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line"><span class="keyword">go</span> bc(counter)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//for i := 0; i &lt; 10; i++ &#123;</span></div><div class="line"><span class="comment">//go set(counter, i*10)</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="comment">//for i := 0; i &lt; 10; i++ &#123;</span></div><div class="line"><span class="comment">//go get(counter)</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line">time.Sleep(time.Second * <span class="number">2</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">bc</span><span class="params">(counter *ctr)</span></span> &#123;</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line"><span class="keyword">go</span> set(counter, i)</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line"><span class="keyword">go</span> get(counter)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// counter 这里必须是引用</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(counter *ctr, v <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">counter.Lock()</div><div class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">counter.Unlock()</div><div class="line">fmt.Printf(<span class="string">"set unlock mutex addr %p \n"</span>, &amp;counter.RWMutex)</div><div class="line">fmt.Printf(<span class="string">"set unlock count addr %p \n"</span>, &amp;counter.m)</div><div class="line">fmt.Printf(<span class="string">"set unlock all addr %p \n"</span>, &amp;counter)</div><div class="line">&#125;()</div><div class="line"><span class="comment">//counter.m["some_key"] = v</span></div><div class="line">counter.m[<span class="string">"some_key"</span>] = counter.m[<span class="string">"some_key"</span>] + v</div><div class="line"><span class="comment">//time.Sleep(time.Millisecond * 10)</span></div><div class="line">fmt.Println(<span class="string">"some_key set:"</span>, counter.m[<span class="string">"some_key"</span>])</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(counter *ctr)</span></span> &#123;</div><div class="line">counter.RLock()</div><div class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">counter.RUnlock()</div><div class="line">fmt.Printf(<span class="string">"get unlock mutex addr %p \n"</span>, &amp;counter.RWMutex)</div><div class="line">fmt.Printf(<span class="string">"get unlock count addr %p \n"</span>, &amp;counter.m)</div><div class="line">fmt.Printf(<span class="string">"get unlock all addr %p \n"</span>, &amp;counter)</div><div class="line">&#125;()</div><div class="line">n := counter.m[<span class="string">"some_key"</span>]</div><div class="line">fmt.Println(<span class="string">"some_key get:"</span>, n)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="实现2"><a href="#实现2" class="headerlink" title="实现2"></a>实现2</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// map_safe.go</span></div><div class="line"><span class="comment">// Copyright (C) 2018 chentao &lt;chentao@chentaos-MacBook-Pro.local&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Distributed under terms of the MIT license.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line"><span class="string">"fmt"</span></div><div class="line"><span class="string">"sync"</span></div><div class="line"><span class="string">"time"</span></div><div class="line"><span class="string">"unsafe"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> ctr2 <span class="keyword">struct</span> &#123;</div><div class="line">sync.RWMutex</div><div class="line">m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">counter := ctr2&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line"><span class="keyword">go</span> counter.bc()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//for i := 0; i &lt; 10; i++ &#123;</span></div><div class="line"><span class="comment">//go set(counter, i*10)</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="comment">//for i := 0; i &lt; 10; i++ &#123;</span></div><div class="line"><span class="comment">//go get(counter)</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line">time.Sleep(time.Second * <span class="number">2</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// counter这里都OK</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(counter *ctr2)</span> <span class="title">bc</span><span class="params">()</span></span> &#123;</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line"><span class="keyword">go</span> counter.set(i)</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line"><span class="keyword">go</span> counter.get()</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(counter *ctr2)</span> <span class="title">set</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">counter.Lock()</div><div class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">counter.Unlock()</div><div class="line">fmt.Printf(<span class="string">"set unlock mutex addr %p \n"</span>, &amp;counter.RWMutex)</div><div class="line">fmt.Printf(<span class="string">"set unlock count addr %p \n"</span>, &amp;counter.m)</div><div class="line">fmt.Printf(<span class="string">"set unlock all addr %p \n"</span>, &amp;(*counter))</div><div class="line">fmt.Printf(<span class="string">"set unlock all addr %p \n"</span>, unsafe.Pointer(counter))</div><div class="line">fmt.Printf(<span class="string">"set unlock all addr %p \n"</span>, counter)</div><div class="line">&#125;() <span class="comment">// 注意这几个对象引用和地址的区分</span></div><div class="line"><span class="comment">//counter.m["some_key"] = v</span></div><div class="line">counter.m[<span class="string">"some_key"</span>] = counter.m[<span class="string">"some_key"</span>] + v</div><div class="line"><span class="comment">//time.Sleep(time.Millisecond * 10)</span></div><div class="line">fmt.Println(<span class="string">"some_key set:"</span>, counter.m[<span class="string">"some_key"</span>])</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(counter *ctr2)</span> <span class="title">get</span><span class="params">()</span></span> &#123;</div><div class="line">counter.RLock()</div><div class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">counter.RUnlock()</div><div class="line">fmt.Printf(<span class="string">"get unlock mutex addr %p \n"</span>, &amp;counter.RWMutex)</div><div class="line">fmt.Printf(<span class="string">"get unlock count addr %p \n"</span>, &amp;counter.m)</div><div class="line">fmt.Printf(<span class="string">"get unlock all addr %p \n"</span>, &amp;(*counter))</div><div class="line">fmt.Printf(<span class="string">"get unlock all addr %p \n"</span>, unsafe.Pointer(counter))</div><div class="line">fmt.Printf(<span class="string">"get unlock all addr %p \n"</span>, counter)</div><div class="line">&#125;()</div><div class="line">n := counter.m[<span class="string">"some_key"</span>]</div><div class="line">fmt.Println(<span class="string">"some_key get:"</span>, n)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      有几个坑，需要注意一下
    
    </summary>
    
      <category term="Golang" scheme="http://chen-tao.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://chen-tao.github.io/tags/Golang/"/>
    
      <category term="Sync" scheme="http://chen-tao.github.io/tags/Sync/"/>
    
  </entry>
  
  <entry>
    <title>Hive CookBook</title>
    <link href="http://chen-tao.github.io/2017/10/17/hive-tips/"/>
    <id>http://chen-tao.github.io/2017/10/17/hive-tips/</id>
    <published>2017-10-16T16:00:00.000Z</published>
    <updated>2017-10-17T08:23:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查询配置"><a href="#查询配置" class="headerlink" title="查询配置"></a>查询配置</h2><p>设置任务名称 <code>set mapreduce.job.name=xxx_yourname;</code></p><p>指定任务队列 <code>set mapreduce.job.queuename=offline.data;</code></p><p>任务结果输出header信息 <code>set hive.cli.print.header=true;</code></p><p>设置优先级 <code>set mapreduce.job.priority=HIGH;</code></p><blockquote><p>优先级说明:<br>配置 <code>mapreduce.job.priority</code> 来调整优先级，支持的值：</p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">对应YARN优先级</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">NORMAL(默认)</td><td style="text-align:left">1</td><td style="text-align:left">普通任务</td></tr><tr><td style="text-align:left">HIGH</td><td style="text-align:left">2</td><td style="text-align:left">nearline 任务</td></tr><tr><td style="text-align:left">VERY_HIGH</td><td style="text-align:left">3</td><td style="text-align:left">在线任务</td></tr><tr><td style="text-align:left">CRITICAL</td><td style="text-align:left">6</td><td style="text-align:left">关键任务</td></tr><tr><td style="text-align:left">VERY_CRITICAL</td><td style="text-align:left">9</td><td style="text-align:left">非常关键的任务</td></tr></tbody></table></blockquote><h3 id="reduce阶段内存配置："><a href="#reduce阶段内存配置：" class="headerlink" title="reduce阶段内存配置："></a><strong>reduce阶段内存配置：</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> mapreduce.reduce.java.opts=-Xmx3072m;</div><div class="line"><span class="built_in">set</span> mapreduce.reduce.memory.mb=4096;</div></pre></td></tr></table></figure><h3 id="map阶段内存配置："><a href="#map阶段内存配置：" class="headerlink" title="map阶段内存配置："></a>map阶段内存配置：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> mapreduce.map.java.opts=-Xmx3072m;</div><div class="line"><span class="built_in">set</span> mapreduce.map.memory.mb=4096;</div></pre></td></tr></table></figure><h3 id="map数过多："><a href="#map数过多：" class="headerlink" title="map数过多："></a>map数过多：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> mapred.min.split.size=536870912;</div><div class="line"><span class="built_in">set</span> mapred.max.split.size=536870912;</div></pre></td></tr></table></figure><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><h3 id="使用-Rank-计算分组-TopN-或-Top-Percentile"><a href="#使用-Rank-计算分组-TopN-或-Top-Percentile" class="headerlink" title="使用 Rank() 计算分组 TopN 或 Top Percentile"></a>使用 Rank() 计算分组 TopN 或 Top Percentile</h3><p>文档：<a href="http://www.cloudera.com/content/cloudera/en/documentation/cloudera-impala/latest/topics/impala_analytic_functions.html#rank_unique_1" target="_blank" rel="external">Rank()</a></p><p>Rank() 可以为原始数据的每一行生成新的一列，值为这一行所在分组的排序 rank； 这样就可以根据 rank 值来保留所需要的 Top N 的行，也可以参考所在分组的总行数，保留 Top n% 的行。</p><p>Example: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span></div><div class="line">    *</div><div class="line"><span class="keyword">FROM</span></div><div class="line">    (</div><div class="line">        <span class="keyword">SELECT</span></div><div class="line">            ut,</div><div class="line">            uid,</div><div class="line">            gid,</div><div class="line">            it,</div><div class="line">            <span class="keyword">RANK</span>() <span class="keyword">OVER</span> (</div><div class="line">                <span class="keyword">PARTITION</span> <span class="keyword">BY</span> gid</div><div class="line">                <span class="keyword">ORDER</span> <span class="keyword">BY</span></div><div class="line">                    it</div><div class="line">            ) <span class="keyword">AS</span> gir</div><div class="line">        <span class="keyword">FROM</span></div><div class="line">            is_daily</div><div class="line">        <span class="keyword">WHERE</span></div><div class="line">            <span class="string">`date=`</span> <span class="string">"20170803"</span></div><div class="line">            <span class="keyword">AND</span> <span class="keyword">is</span> = <span class="string">"f"</span></div><div class="line">    ) <span class="keyword">AS</span> tmp_t</div><div class="line"><span class="keyword">WHERE</span></div><div class="line">    gir &lt; <span class="number">10</span></div><div class="line"><span class="keyword">LIMIT</span></div><div class="line">    <span class="number">100</span></div></pre></td></tr></table></figure><h3 id="使用-NDV-实现快速计数"><a href="#使用-NDV-实现快速计数" class="headerlink" title="使用 NDV() 实现快速计数"></a>使用 NDV() 实现快速计数</h3><p>文档： <a href="http://www.cloudera.com/content/cloudera/en/documentation/cloudera-impala/v2-0-x/topics/impala_ndv.html" target="_blank" rel="external">NDV()</a></p><p>相比 count distinct 更快、更节省内存，但存在误差 (HyperLogLog). 在查询很大的 count distinct，且对准确性要求量级正确即可时，e.g. 月活跃用户(MAU)，可以考虑用 NDV 代替 count distinct.</p><p>NDV() 只能对单列做计数，所以如果需要多列组合计数，需要做一个拼接转换。</p><p>Example: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span></div><div class="line">    ndv(</div><div class="line">        <span class="keyword">concat</span>(</div><div class="line">            <span class="keyword">cast</span>(uid <span class="keyword">AS</span> <span class="keyword">STRING</span>),</div><div class="line">            <span class="string">','</span>,</div><div class="line">            <span class="keyword">cast</span>(user_uid <span class="keyword">AS</span> <span class="keyword">STRING</span>)</div><div class="line">        )</div><div class="line">    )</div><div class="line">)</div><div class="line"><span class="keyword">FROM</span></div><div class="line">    default.isd</div><div class="line"><span class="keyword">WHERE</span></div><div class="line">    <span class="string">`date=`</span> <span class="string">"20170803"</span></div><div class="line">    <span class="keyword">AND</span> <span class="keyword">is</span> = <span class="string">"f"</span></div><div class="line"><span class="keyword">SELECT</span></div><div class="line">    <span class="keyword">count</span>(<span class="keyword">distinct</span> uid, user_uid)</div><div class="line"><span class="keyword">FROM</span></div><div class="line">    default.isd</div><div class="line"><span class="keyword">WHERE</span></div><div class="line">    <span class="string">`date=`</span> <span class="string">"20170803"</span></div><div class="line">    <span class="keyword">AND</span> <span class="keyword">is</span> = <span class="string">"f"</span></div></pre></td></tr></table></figure><h3 id="使用lateral-view和explode展开array嵌套结构"><a href="#使用lateral-view和explode展开array嵌套结构" class="headerlink" title="使用lateral view和explode展开array嵌套结构"></a>使用lateral view和explode展开array嵌套结构</h3><p>对字符串split得到array，再把array展开</p><p>示例：it是字符串，取值样例’refresh,push’</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span></div><div class="line">    uid,</div><div class="line">    ut,</div><div class="line">    it</div><div class="line"><span class="keyword">from</span></div><div class="line">    t LATERAL <span class="keyword">VIEW</span> explode(<span class="keyword">split</span>(it, <span class="string">','</span>)) tb <span class="keyword">as</span> it</div><div class="line"><span class="keyword">where</span></div><div class="line">    <span class="string">`date = `</span> <span class="string">'20161229'</span></div><div class="line"><span class="keyword">limit</span></div><div class="line">    <span class="number">100</span></div></pre></td></tr></table></figure><h3 id="使用lateral-view和explode展开map嵌套结构"><a href="#使用lateral-view和explode展开map嵌套结构" class="headerlink" title="使用lateral view和explode展开map嵌套结构"></a>使用lateral view和explode展开map嵌套结构</h3><p>对value值进行过滤，选取符合要求的keys</p><p>示例：lt_lk_keyword是Map，取值样例{123: 0.1234, 234: 0.2345}</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span></div><div class="line">    uid,</div><div class="line">    ut,</div><div class="line">    <span class="keyword">key</span>,</div><div class="line">    <span class="keyword">value</span></div><div class="line"><span class="keyword">from</span></div><div class="line">    x LATERAL <span class="keyword">VIEW</span> explode(lt_lk_keyword) tb <span class="keyword">as</span> <span class="keyword">key</span>,</div><div class="line">    <span class="keyword">value</span></div><div class="line"><span class="keyword">where</span></div><div class="line">    <span class="string">`date = `</span> <span class="string">'20151229'</span></div></pre></td></tr></table></figure><h3 id="使用lateral-view-和-json-tuple-处理json"><a href="#使用lateral-view-和-json-tuple-处理json" class="headerlink" title="使用lateral view 和 json_tuple 处理json"></a>使用lateral view 和 json_tuple 处理json</h3><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span></div><div class="line">    *</div><div class="line"><span class="keyword">FROM</span></div><div class="line">    (</div><div class="line">        <span class="keyword">select</span></div><div class="line">            *</div><div class="line">        <span class="keyword">from</span></div><div class="line">            x LATERAL <span class="keyword">VIEW</span> json_tuple(extra, <span class="string">"gs"</span>, <span class="string">"uid"</span>) t1 <span class="keyword">as</span> uid,</div><div class="line">            gs</div><div class="line">    ) g</div><div class="line">    <span class="keyword">JOIN</span> default.web_article_item_dict <span class="keyword">as</span> i <span class="keyword">on</span> g.date = i.date</div><div class="line">    <span class="keyword">and</span> g.kid = iid</div><div class="line"><span class="keyword">where</span></div><div class="line">    g.date = <span class="string">"20171016"</span></div><div class="line"><span class="keyword">limit</span></div><div class="line">    <span class="number">10</span></div></pre></td></tr></table></figure><h2 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h2><h3 id="保存查询结果到hive表"><a href="#保存查询结果到hive表" class="headerlink" title="保存查询结果到hive表"></a>保存查询结果到hive表</h3><p>直接以查询结果建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test.tb_abc <span class="keyword">AS</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">distinct</span> uit, uid</div><div class="line">  <span class="keyword">FROM</span> default.isd</div><div class="line">  WHEREdate=<span class="string">"20150803"</span></div></pre></td></tr></table></figure><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><h3 id="创建空Parquet分区表"><a href="#创建空Parquet分区表" class="headerlink" title="创建空Parquet分区表"></a>创建空Parquet分区表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> test.tmp_users1(</div><div class="line">    ut tinyint,</div><div class="line">    uid <span class="built_in">bigint</span></div><div class="line">)</div><div class="line">PARTITIONED <span class="keyword">BY</span> (</div><div class="line">   <span class="string">`date string`</span></div><div class="line">)</div><div class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> PARQUET;</div></pre></td></tr></table></figure><h3 id="基于JSON数据创建外部数据表"><a href="#基于JSON数据创建外部数据表" class="headerlink" title="基于JSON数据创建外部数据表"></a>基于JSON数据创建外部数据表</h3><p>文档：<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-CreateTable" target="_blank" rel="external">CreateTable</a></p><p>Example: 创建包含2个字段的临时外部数据表</p><p>HDFS数据：xx.json。目录中可包含多个文件。json文件内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;'ut': 12, 'uid': 8&#125;</div><div class="line"></div><div class="line">&#123;'ut': 14, 'uid': 12345&#125;</div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> test.tmp_users1(</div><div class="line">    ut tinyint,</div><div class="line">    uid <span class="built_in">bigint</span></div><div class="line">)</div><div class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> SERDE <span class="string">'org.openx.data.jsonserde.JsonSerDe'</span> <span class="keyword">WITH</span> SERDEPROPERTIES (<span class="string">'ignore.malformed.json'</span>=<span class="string">'true'</span>)</div><div class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> TEXTFILE</div><div class="line">LOCATION <span class="string">'/locate'</span>;</div></pre></td></tr></table></figure><h3 id="基于CSV数据创建外部数据表（数据在本地）"><a href="#基于CSV数据创建外部数据表（数据在本地）" class="headerlink" title="基于CSV数据创建外部数据表（数据在本地）"></a>基于CSV数据创建外部数据表（数据在本地）</h3><p>不将数据存储在hdfs，直接从本地load进表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 12,674930234</span></div><div class="line"><span class="comment">-- 14,759234924</span></div><div class="line"></div><div class="line"><span class="comment">-- step1: 建表</span></div><div class="line"></div><div class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> csv_load_test(</div><div class="line">    ut <span class="built_in">bigint</span>,</div><div class="line">    uid <span class="built_in">bigint</span></div><div class="line">)</div><div class="line"><span class="keyword">row</span> <span class="keyword">format</span></div><div class="line"><span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span></div><div class="line"><span class="keyword">stored</span> <span class="keyword">as</span> textfile</div><div class="line"></div><div class="line"><span class="comment">-- step2: load数据</span></div><div class="line"></div><div class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'./test.csv'</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> csv_load_test</div></pre></td></tr></table></figure><h3 id="基于CSV数据创建外部数据表（数据在hdfs）"><a href="#基于CSV数据创建外部数据表（数据在hdfs）" class="headerlink" title="基于CSV数据创建外部数据表（数据在hdfs）"></a>基于CSV数据创建外部数据表（数据在hdfs）</h3><p>文档：<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-CreateTable" target="_blank" rel="external">CreateTable</a></p><p>Example: 创建包含2个字段的临时外部数据表</p><p>HDFS数据：/users.csv。目录中可包含多个文件。csv文件内容，以\t分隔：</p><p>将数据表从hive同步到impala, 在impala执行: invalidate metadata test.source_list_focus;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 12,8</span></div><div class="line"><span class="comment">-- 14,12345</span></div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> test.tmp_users2(</div><div class="line">    ut tinyint,</div><div class="line">    uid <span class="built_in">bigint</span></div><div class="line">)</div><div class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span></div><div class="line"><span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span></div><div class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> TEXTFILE</div><div class="line">LOCATION <span class="string">'/locate'</span>;</div></pre></td></tr></table></figure><h3 id="创建包含map和array结构的临时表："><a href="#创建包含map和array结构的临时表：" class="headerlink" title="创建包含map和array结构的临时表："></a>创建包含map和array结构的临时表：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> test.impala_complex_type_json(</div><div class="line">    <span class="string">`uid string,`</span></div><div class="line">    <span class="string">`properties map,`</span></div><div class="line">    ids<span class="string">` array&lt;int`</span>&gt;)</div><div class="line">    <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span></div><div class="line">      <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span></div><div class="line">      collection items <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span></div><div class="line">      <span class="keyword">map</span> <span class="keyword">keys</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">':'</span></div><div class="line">    <span class="keyword">STORED</span> <span class="keyword">AS</span> TEXTFILE;</div><div class="line"></div><div class="line"><span class="comment">-- local file</span></div><div class="line"></div><div class="line">u1 &#123;"name":"xiaoming","age":"18","gender":"male"&#125; [1,2,3]</div><div class="line"></div><div class="line">u2 &#123;"name":"dagou","age":"18","gender":"female"&#125; [4,5,6]</div><div class="line"></div><div class="line"><span class="comment">-- cli - command</span></div><div class="line"></div><div class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'./a'</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> test.impala_complex_type_json</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      some tips for hive to handle data
    
    </summary>
    
      <category term="Hive" scheme="http://chen-tao.github.io/categories/Hive/"/>
    
    
      <category term="Hive" scheme="http://chen-tao.github.io/tags/Hive/"/>
    
      <category term="Hadoop" scheme="http://chen-tao.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Git全局递归忽略.DS_Store</title>
    <link href="http://chen-tao.github.io/2017/09/24/Git%E5%85%A8%E5%B1%80%E9%80%92%E5%BD%92%E5%BF%BD%E7%95%A5-DS-Store/"/>
    <id>http://chen-tao.github.io/2017/09/24/Git全局递归忽略-DS-Store/</id>
    <published>2017-09-24T05:43:21.000Z</published>
    <updated>2017-09-24T06:01:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Mac下，只要在Finder访问过的文件夹，都会生成一个.DS_Store的文件，Mac用它来存储当前文件夹的一些Meta信息。对于Git来说，不经意间总是会干扰到其他正常的提交和本地仓库状态，是很烦恼，找了半天，终于有一个比较好的办法处理了</p></blockquote><p>流程大致是这样的：</p><h2 id="对于项目内已经提交了-DS-Store到仓库的情况"><a href="#对于项目内已经提交了-DS-Store到仓库的情况" class="headerlink" title="对于项目内已经提交了.DS_Store到仓库的情况"></a>对于项目内已经提交了.DS_Store到仓库的情况</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name .DS_Store -print0 | xargs -0 git rm --ignore-unmatch</div></pre></td></tr></table></figure><p>搜索一下项目内所有的<code>.DS_Store</code>，全部<code>rm</code>掉，然后再<code>push</code>一把</p><h2 id="对于今后的项目，做全局的配置"><a href="#对于今后的项目，做全局的配置" class="headerlink" title="对于今后的项目，做全局的配置"></a>对于今后的项目，做全局的配置</h2><p>如果没有<code>~/. gitignore_global</code>文件，<code>echo</code>也会为你生成一个，这里的主要目的是覆盖所有可能的<code>OS X</code>版本生成的<code>.DS_Store</code>，逐一执行一次就可以了，之后<code>cat</code>一下看是否正常写入了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">".DS_Store"</span> &gt;&gt; ~/.gitignore_global</div><div class="line"><span class="built_in">echo</span> <span class="string">"._.DS_Store"</span> &gt;&gt; ~/.gitignore_global</div><div class="line"><span class="built_in">echo</span> <span class="string">"**/.DS_Store"</span> &gt;&gt; ~/.gitignore_global</div><div class="line"><span class="built_in">echo</span> <span class="string">"**/._.DS_Store"</span> &gt;&gt; ~/.gitignore_global</div></pre></td></tr></table></figure><p>然后设置一下全局的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global core.excludesfile ~/.gitignore_global</div></pre></td></tr></table></figure><p>大功告成~</p><p>另外，Github还提供了一个官方的全局示例，可以根据实际需求使用：</p><script src="https://gist.github.com/Chen-tao/98be9441fd238a1eccadba141d89d64a.js"></script><blockquote><p>最后补充一下<code>.gitignore</code>的语法</p></blockquote><h3 id="gitignore规范"><a href="#gitignore规范" class="headerlink" title="gitignore规范"></a>gitignore规范</h3><ul><li>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上（!）取反。</li></ul><h3 id="glob模式要点"><a href="#glob模式要点" class="headerlink" title="glob模式要点"></a>glob模式要点</h3><ul><li><code>*</code>:任意个任意字符,</li><li><code>[]</code>:匹配任何一个在方括号中的字符,</li><li><code>?</code>:匹配一个任意字符，</li><li><code>[0-9]</code>:匹配字符范围内所有字符</li></ul>]]></content>
    
    <summary type="html">
    
      解决Mac下统一递归的忽略.DS_Store的方法
    
    </summary>
    
      <category term="Git" scheme="http://chen-tao.github.io/categories/Git/"/>
    
    
      <category term="Mac" scheme="http://chen-tao.github.io/tags/Mac/"/>
    
      <category term="OS X" scheme="http://chen-tao.github.io/tags/OS-X/"/>
    
      <category term="Git" scheme="http://chen-tao.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git submodule Note</title>
    <link href="http://chen-tao.github.io/2017/09/24/Git-submodule-Note/"/>
    <id>http://chen-tao.github.io/2017/09/24/Git-submodule-Note/</id>
    <published>2017-09-24T03:29:54.000Z</published>
    <updated>2017-09-24T05:40:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="add-submodule"><a href="#add-submodule" class="headerlink" title="add submodule"></a>add submodule</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git submodule add --force gitr:service_rpc/idl idl</div></pre></td></tr></table></figure><p>If this repo has not previously been used submodule then Git will create a directory in the directory called <em>.gitmodules</em> , which records the URL of the remote repo and the submodule in this project path.</p><p>After executing this command submodule and <em>.gitmodules</em> will automatically staged, this time can commit and push.</p><h3 id="Update-submodule"><a href="#Update-submodule" class="headerlink" title="Update submodule"></a>Update submodule</h3><p>Individual repo update is too much trouble, it is necessary to separate directory under execution <code>git pull</code>to pull the upstream code, but that would be more secure; all at once to update all of submodule can use this <code>foreach</code>command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git submodule foreach --recursive git pull origin master</div></pre></td></tr></table></figure><h3 id="Remove-submodule"><a href="#Remove-submodule" class="headerlink" title="Remove submodule"></a>Remove submodule</h3><p>I thought there will be like <code>git submodule rm</code>such an instruction, the result is not even, you must manually remove the hard ground one by one, not knowing what not to implement this directive considerations, I hope that future versions can add to it.</p><p>Remove submodule has the following steps to do, first remove the submodule directory from the version control system:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git rm --cached /path/to/files</div><div class="line">rm -rf /path/to/files</div></pre></td></tr></table></figure><p>Again to modify <em>.gitmodules</em> , remove the <em>unwrought</em> submodule, for example:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[submodule <span class="string">".vim/bundle/vim-gitgutter"</span>]</div><div class="line">  path = .vim/bundle/vim-gitgutter</div><div class="line">  url = git://github.com/airblade/vim-gitgutter.git</div><div class="line">-[submodule <span class="string">".vim/bundle/vim-autoclose"</span>]</div><div class="line">- path = .vim/bundle/vim-autoclose</div><div class="line">- url = git://github.com/Townk/vim-autoclose.git</div></pre></td></tr></table></figure><p>Not yet finished! But also modify the contents of <em>.git / config</em> , with. <em>Gitmodules</em> , the need to remove the submodule deleted, and finally commit.</p><h3 id="clone-when-the-submodule-together-to-catch-down"><a href="#clone-when-the-submodule-together-to-catch-down" class="headerlink" title="clone when the submodule together to catch down"></a>clone when the submodule together to catch down</h3><p>Implementation of <code>git clone</code>Git clone does not automatically come together when submodule must be added <code>--recursive</code>recursive parameter, so you can catch all associated submodule in submodule down together:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> --recursive git@github.com:Chen-tao/go-stuff.git</div></pre></td></tr></table></figure><p>If you have been caught to find submodule is empty, you can use the following instructions to catch, <code>init</code>will be registered in _.git / config` remote repo URL and local path:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git submodule init</div><div class="line">git submodule update --recursive</div></pre></td></tr></table></figure><p>Or merged into one line <code>git submodule update --init --recursive</code>can, if upstream someone to turn over <em>.gitmodules</em> , it seems that local end also using this method update.</p><h2 id="Explanation-of-instructions"><a href="#Explanation-of-instructions" class="headerlink" title="Explanation of instructions"></a>Explanation of instructions</h2><ul><li><code>git submodule init</code>: According to <em>.gitmodules</em> name and URL, these information will be registered to . *Git *<em>/ config</em> , but not <em>.gitmodules</em> not removed submodule, the use of this directive and no way to automatically delete. <em>Git / config</em> related content, you must manually delete ;</li><li><code>git submodule update</code>: According to registered (that is, <em>.git / config</em> ) submodule to update, such as clone lost submodule, which is the last paragraph of the method, so the implementation of this instruction before the best plus <code>--init</code>;</li><li><code>git submodule sync</code>: If the submodule’s remote URL changes, you can correct the URL in <em>.gitmodules</em> , and then execute this command, the submodule’s remote URL will be corrected.</li></ul>]]></content>
    
    <summary type="html">
    
      项目中使用了git的submodule功能，但突然发现，更新项目或者重写clone项目时，submodule并没有一起更新……这里总结和学习一下submodule相关的功能
    
    </summary>
    
      <category term="Git" scheme="http://chen-tao.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://chen-tao.github.io/tags/Git/"/>
    
      <category term="github" scheme="http://chen-tao.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>使用gvm管理多版本golang</title>
    <link href="http://chen-tao.github.io/2017/09/14/Use-gvm-manage-golang-version/"/>
    <id>http://chen-tao.github.io/2017/09/14/Use-gvm-manage-golang-version/</id>
    <published>2017-09-14T05:36:32.000Z</published>
    <updated>2017-09-24T03:46:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Golang发展迅速，代码迭代非常快，想要调试和梳理项目进程就成了一件相对棘手的事情。偶然间发现了gvm - <a href="http://github.com/moovweb/gvm" target="_blank" rel="external">Go Version Manager</a>，算是找到了调试切换版本的福音。</p><h2 id="关于gvm"><a href="#关于gvm" class="headerlink" title="关于gvm"></a>关于gvm</h2><p>GVM，类似于ruby 中的<a href="https://rvm.io/" target="_blank" rel="external">RVM</a>，java 中的<a href="https://github.com/linux-china/jenv" target="_blank" rel="external">jenv</a>（国产），可用于方便管理 Go 的版本，它有如下几个主要特性：</p><ul><li><p>管理 Go 的多个版本，包括安装、卸载和指定使用 Go 的某个版本</p></li><li><p>查看官方所有可用的 Go 版本，同时可以查看本地已安装和默认使用的 Go 版本</p></li><li><p>管理多个 GOPATH，并可编辑 Go 的环境变量</p></li><li><p>可将当前目录关联到 GOPATH</p></li><li><p>可以查看 GOROOT 下的文件差异</p></li></ul><h2 id="Go-版本切换"><a href="#Go-版本切换" class="headerlink" title="Go 版本切换"></a>Go 版本切换</h2><p>二进制文件的管理比较简单，通过链接使用不同版本的程序即可，实际上主要是一些环境变量和标准库的设置问题，环境变量主要是 GOPATH 以及 GOROOT，标准库的话需要在切换 go 版本时也能跟着切换。gvm 实际上就是帮助完成这些配置工作。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>按照官方文档操作即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)</div><div class="line"><span class="comment"># or</span></div><div class="line">zsh &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)</div></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$ gvm</div><div class="line">Usage: gvm [<span class="built_in">command</span>]</div><div class="line"></div><div class="line">Description:</div><div class="line">  GVM is the Go Version Manager</div><div class="line"></div><div class="line">Commands:</div><div class="line">  version    - <span class="built_in">print</span> the gvm version number</div><div class="line">  get        - gets the latest code (<span class="keyword">for</span> debugging)</div><div class="line">  use        - select a go version to use (--default to <span class="built_in">set</span> permanently)</div><div class="line">  diff       - view changes to Go root</div><div class="line">  <span class="built_in">help</span>       - display this usage text</div><div class="line">  implode    - completely remove gvm</div><div class="line">  install    - install go versions</div><div class="line">  uninstall  - uninstall go versions</div><div class="line">  cross      - install go cross compilers</div><div class="line">  linkthis   - link this directory into GOPATH</div><div class="line">  list       - list installed go versions</div><div class="line">  listall    - list available versions</div><div class="line">  <span class="built_in">alias</span>      - manage go version aliases</div><div class="line">  pkgset     - manage go packages sets</div><div class="line">  pkgenv     - edit the environment <span class="keyword">for</span> a package <span class="built_in">set</span></div></pre></td></tr></table></figure><p>Mac下需要这样一把（如果你的环境有问题的话）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xcode-select --install</div><div class="line">brew update</div><div class="line">brew install mercurial</div></pre></td></tr></table></figure><p>一般常规的操作是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 先列一下看支持哪些版本</span></div><div class="line">gvm listall</div><div class="line"></div><div class="line"><span class="comment"># 看下自己环境有哪些版本</span></div><div class="line">gvm list</div><div class="line"></div><div class="line"><span class="comment"># 安装需要的版本，比如go1.8.3，加--default代表每次再进terminal时默认使用这个版本</span></div><div class="line">gvm install go1.8.3 [--default]</div><div class="line"></div><div class="line"><span class="comment"># 然后看下是否成功</span></div><div class="line">go version</div><div class="line">go env</div><div class="line"></div><div class="line"><span class="comment"># 如果不需要gvm的环境变量，则需要到GVM_ROOT/environments下面去删除</span></div><div class="line"><span class="comment"># 注意是清空文件</span></div><div class="line">&gt; <span class="variable">$GVM_ROOT</span>/environments/go1.8.3</div><div class="line"></div><div class="line"><span class="comment"># 如果需要每次打开terminal都生效的话，以下命令加入到bashrc/zshrc，注意要加在GOPATH/GOROOT的setting之前（如果希望环境变量不被修改的话）</span></div><div class="line"><span class="built_in">source</span> /Users/chentao/.gvm/scripts/gvm</div></pre></td></tr></table></figure><h2 id="几点注意"><a href="#几点注意" class="headerlink" title="几点注意"></a>几点注意</h2><ul><li>在 Linux 下安装 GVM，需要安装相关依赖，详情见<a href="https://github.com/moovweb/gvm" target="_blank" rel="external">官网说明</a></li><li>GVM 官方显示没对 Windows 做支持，考虑到 Windows 不是程序员的标配吧（有同学回复用 git-windows客户端，自带bash功能，可以自行尝试安装下）。</li><li>GVM 安装新版本之后，Go 环境变量会重新设置，为了节约磁盘空间和时间，建议把之前版本的 GOPATH 内容移动到新版本对应的 GOPATH 目录下，相关路径可以通过 go env 获取</li><li>在同一版本下，用 gvm pkgset 创建多个 GOPATH，可能会占用你比较大的磁盘空间</li><li>使用 gvm implode 需谨慎</li><li>GVM 是用 shell 编写</li></ul>]]></content>
    
    <summary type="html">
    
      go版本之间的变化较大，尤其从1.4开始，增删了很多包和相关的代码。使用gvm可以模拟各种版本的go环境，进行相关的代码调试
    
    </summary>
    
      <category term="Golang" scheme="http://chen-tao.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://chen-tao.github.io/tags/Golang/"/>
    
      <category term="gvm" scheme="http://chen-tao.github.io/tags/gvm/"/>
    
  </entry>
  
  <entry>
    <title>如何安全删除Github上的commit历史</title>
    <link href="http://chen-tao.github.io/2017/09/14/How-to-delete-github-history/"/>
    <id>http://chen-tao.github.io/2017/09/14/How-to-delete-github-history/</id>
    <published>2017-09-14T03:22:16.000Z</published>
    <updated>2017-09-14T03:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Remove the history from </span></div><div class="line">rm -rf .git</div><div class="line"></div><div class="line"><span class="comment"># recreate the repos from the current content only</span></div><div class="line">git init</div><div class="line">git add .</div><div class="line">git commit -m <span class="string">"Initial commit"</span></div><div class="line"></div><div class="line"><span class="comment"># push to the github remote repos ensuring you overwrite history</span></div><div class="line">git remote add origin git@github.com:&lt;YOUR ACCOUNT&gt;/&lt;YOUR REPOS&gt;.git</div><div class="line">git push -u --force origin master</div></pre></td></tr></table></figure><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git checkout --orphan newBranch</div><div class="line">git add -A  <span class="comment"># Add all files and commit them</span></div><div class="line">git commit</div><div class="line">git branch -D master  <span class="comment"># Deletes the master branch</span></div><div class="line">git branch -m master  <span class="comment"># Rename the current branch to master</span></div><div class="line">git push -f origin master  <span class="comment"># Force push master branch to github</span></div><div class="line">git gc --aggressive --prune=all     <span class="comment"># remove the old files</span></div></pre></td></tr></table></figure><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h2><blockquote><p>Delete Github Repo = = ,that’s a sad but useful way to totally delete<br>Warning : solution 1&amp;2 not delete pull request history (discussion, file changes). If you do this in order to delete sensitive data, you should better delete the github repo (along with all its pull request history etc..) and recreate a new one from scratch.</p></blockquote><h2 id="Finnaly"><a href="#Finnaly" class="headerlink" title="Finnaly"></a>Finnaly</h2><p>说了半天，其实还是直接删除repo最安全…… 前两种我理解，大概是指向删除了，并没做物理删除。 = = SAD</p><p><em>EOF</em></p>]]></content>
    
    <summary type="html">
    
      有时候确实会有这种需求，摆烂的历史，或者，敏感信息的移除
    
    </summary>
    
      <category term="Github" scheme="http://chen-tao.github.io/categories/Github/"/>
    
    
      <category term="git" scheme="http://chen-tao.github.io/tags/git/"/>
    
      <category term="Github" scheme="http://chen-tao.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Golang Workers / Job Queue</title>
    <link href="http://chen-tao.github.io/2017/09/11/Golang-Workers-Job-Queue/"/>
    <id>http://chen-tao.github.io/2017/09/11/Golang-Workers-Job-Queue/</id>
    <published>2017-09-11T12:09:39.000Z</published>
    <updated>2017-09-14T03:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>A running example of the code from:</p><ul><li><a href="http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang" target="_blank" rel="external">http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang</a></li><li><a href="http://nesv.github.io/golang/2014/02/25/worker-queues-in-go.html" target="_blank" rel="external">http://nesv.github.io/golang/2014/02/25/worker-queues-in-go.html</a></li></ul><p>This gist creates a working example from blog post, and a alternate example using simple worker pool.</p><p>TLDR: if you want simple and controlled concurrency use a <a href="https://gist.github.com/harlow/49318d54f45d29f1a77cc641faf14054" target="_blank" rel="external">worker pool</a>.</p><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>Small refactorings made to original code:</p><ul><li>Use non-exported private methods</li><li>Remove global variables</li><li>Bring the flags closer to their usage in <code>main()</code> from <a href="https://robots.thoughtbot.com/where-to-define-command-line-flags-in-go" target="_blank" rel="external">where to define flags in program</a>.</li></ul><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>Simplify the worker queue by removing the <code>Dispatcher</code>.</p><ul><li>Creates workers directly and passes job queue to them</li></ul><p><a href="https://gist.github.com/harlow/dbcd639cf8d396a2ab73#file-worker_refactored-go" target="_blank" rel="external">https://gist.github.com/harlow/dbcd639cf8d396a2ab73#file-worker_refactored-go</a></p><h2 id="Run-the-Application"><a href="#Run-the-Application" class="headerlink" title="Run the Application"></a>Run the Application</h2><p>Boot either the <code>worker_original.go</code> or the <code>worker_refactored.go</code> applications. Use flags to adjust the <code>max_workers</code> and <code>max_queue_size</code> to override the default values.</p><pre><code>$ go run worker_original.go -max_workers 5</code></pre><p>cURL the application from another terminal window:</p><pre><code>$ for i in {1..15}; do curl localhost:8080/work -d name=job$i -d delay=$(expr $i % 9 + 1)s; done</code></pre><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>The test run with Pprof show performance characteristics remain the same between both examples.</p><h2 id="Code-Time"><a href="#Code-Time" class="headerlink" title="Code Time"></a>Code Time</h2><script src="https://gist.github.com/Chen-tao/69d3dd7202dba1beb8abedf6fe712308.js"></script>]]></content>
    
    <summary type="html">
    
      看 otium/queue 如何用go实现的后台处理任务队列
    
    </summary>
    
      <category term="Golang" scheme="http://chen-tao.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://chen-tao.github.io/tags/Golang/"/>
    
      <category term="MQ" scheme="http://chen-tao.github.io/tags/MQ/"/>
    
      <category term="消息队列" scheme="http://chen-tao.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Golang 如何确定App是否运行在Docker内</title>
    <link href="http://chen-tao.github.io/2017/09/11/Go-check-if-app-running-in-docker/"/>
    <id>http://chen-tao.github.io/2017/09/11/Go-check-if-app-running-in-docker/</id>
    <published>2017-09-11T05:48:47.000Z</published>
    <updated>2017-09-14T03:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景</p><p>项目需要隔离部署，如果在docker环境需要使用一些特殊的配置，之前没有太好的判别方法，现在总结一下。</p></blockquote><h2 id="V1-使用-dockerenv判断"><a href="#V1-使用-dockerenv判断" class="headerlink" title="V1 使用/.dockerenv判断"></a>V1 使用<code>/.dockerenv</code>判断</h2><p>如果是Docker容器内，根目录会生成一个可执行的<code>/.dockerenv</code>文件，判断此文件是否存在可以基本断定是否运行内容器内，注意是“基本”，极少数的发行版或者某些定制化较高的系统，可能会不存在此文件。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> DOCKERENV_FILE <span class="keyword">string</span> = <span class="string">"/.dockerenv"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathExist</span><span class="params">(_path <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">_, err := os.Stat(_path)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; os.IsNotExist(err) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> pathExist(DOCKERENV_FILE) &#123;</div><div class="line">logs.Warn(<span class="string">"Running in Docker, not check for now..."</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="V2-使用cgroup信息进行判断"><a href="#V2-使用cgroup信息进行判断" class="headerlink" title="V2 使用cgroup信息进行判断"></a>V2 使用<code>cgroup</code>信息进行判断</h2><p>Docker在Xnix下虚拟环境，使用了cgroup，容器内的group信息与物理机会有本质不同，可以根据Docker内特殊化的环境信息进行判断，这也是目前最靠谱的方案。</p><p>正常情况下物理机的cgroup:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> cat /proc/1/cgroup</span></div><div class="line">9:blkio:/</div><div class="line">8:devices:/</div><div class="line">7:freezer:/</div><div class="line">6:cpuset:/</div><div class="line">5:memory:/</div><div class="line">4:cpu,cpuacct:/</div><div class="line">3:perf_event:/</div><div class="line">2:net_cls,net_prio:/</div><div class="line">1:name=systemd:/</div></pre></td></tr></table></figure><p>Docker内的cgroup(例子)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> cat /proc/1/cgroup </span></div><div class="line">10:freezer:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c</div><div class="line">9:memory:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c</div><div class="line">8:cpuset:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c</div><div class="line">7:pids:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c</div><div class="line">6:devices:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c/init.scope</div><div class="line">5:blkio:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c</div><div class="line">4:cpu,cpuacct:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c</div><div class="line">3:perf_event:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c</div><div class="line">2:net_cls,net_prio:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c</div><div class="line">1:name=systemd:/kubepods/poda2804054-906f-11e7-9ae4-0cc47ad2a6d4/e0ad06c5691de850c976e780c867a254d71df81b315cdc0e2ace2c36983c946c/init.scope</div></pre></td></tr></table></figure><p>判断响应内容即可，一般情况下，主要看<code>name</code> &amp; <code>devices</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">Need Pkg:</span></div><div class="line"><span class="comment">    cgroup "github.com/containerd/cgroups"</span></div><div class="line"><span class="comment">    units "github.com/docker/go-units"</span></div><div class="line"><span class="comment">specs "github.com/opencontainers/runtime-spec/specs-go"</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    paths, err := parseCgroupFile(<span class="string">"/proc/1/cgroup"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">t.Fatal(err)</div><div class="line">&#125;</div><div class="line">dp := strings.TrimPrefix(paths[<span class="string">"devices"</span>], <span class="string">"/"</span>)</div><div class="line">path := PidPath(os.Getpid())</div><div class="line">p, err := path(<span class="string">"devices"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">t.Fatal(err)</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> p != filepath.Join(<span class="string">"/"</span>, dp) &#123;</div><div class="line">t.Fatalf(<span class="string">"expected self path of %q but received %q"</span>, filepath.Join(<span class="string">"/"</span>, dp), p)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="V3-拓展"><a href="#V3-拓展" class="headerlink" title="V3 拓展"></a>V3 拓展</h2><p>如果需要当前协程的父进程信息，会对我们定位很多关键信息起到很大的帮助</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> processNameFormat = <span class="string">"/proc/%d/comm"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">fmt.Println(os.Getppid())</div><div class="line"></div><div class="line">ppid := os.Getppid()</div><div class="line"></div><div class="line">bs, err := ioutil.ReadFile(fmt.Sprintf(processNameFormat, ppid))</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Println(err.Error())</div><div class="line">&#125;</div><div class="line">    fmt.Println(<span class="keyword">string</span>(bs)) <span class="comment">// bs is ppid info</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>EOF</p></blockquote>]]></content>
    
    <summary type="html">
    
      几种判断Golang App当前运行环境的方法
    
    </summary>
    
      <category term="Golang" scheme="http://chen-tao.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://chen-tao.github.io/tags/Golang/"/>
    
      <category term="Docker" scheme="http://chen-tao.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>WTF hexo</title>
    <link href="http://chen-tao.github.io/2017/08/27/WTF-hexo/"/>
    <id>http://chen-tao.github.io/2017/08/27/WTF-hexo/</id>
    <published>2017-08-27T12:14:51.000Z</published>
    <updated>2017-09-14T03:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>真的不知道出了什么问题，突然这个hexo就不好用了，也许是我太久没用了吧 = = </p><p>昨天开始一直报错，找不到某个Trace，另外有一点我不太明白，deploy的时候替我提交了，那为何我本地还有这么多修改。</p><p>问题很多，但是确实很多没到这边来了，我的个人页也莫名其妙丢失了，SAD。</p><p>以上です。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;真的不知道出了什么问题，突然这个hexo就不好用了，也许是我太久没用了吧 = = &lt;/p&gt;
&lt;p&gt;昨天开始一直报错，找不到某个Trace，另外有一点我不太明白，deploy的时候替我提交了，那为何我本地还有这么多修改。&lt;/p&gt;
&lt;p&gt;问题很多，但是确实很多没到这边来了，我的
      
    
    </summary>
    
    
      <category term="感悟" scheme="http://chen-tao.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>告别腾讯-一点总结</title>
    <link href="http://chen-tao.github.io/2017/03/14/about-tencent/"/>
    <id>http://chen-tao.github.io/2017/03/14/about-tencent/</id>
    <published>2017-03-14T07:39:23.000Z</published>
    <updated>2017-09-14T03:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>鹅厂工作届满三年，明天即将离开，写一点自己的感受，希望能看到一些东西，也不被一些东西所影响。</p><a id="more"></a><h3 id="Leave"><a href="#Leave" class="headerlink" title="Leave"></a>Leave</h3><p>业内讲<strong>金山银四</strong>，我也到了发痒的年纪了。一方面有家庭上的原因，另一方面，也觉得北京发展的潜力远远大于深圳，机会也多得多，于是，过年期间准备了一下，拿到了今日头条的offer，即将在北京开始新的生活了。</p><h3 id="SNG"><a href="#SNG" class="headerlink" title="SNG"></a>SNG</h3><p>2014年毕业来到腾讯SNG(社交网络事业群)，做泛QQ方向的业务，在SNG内算是比较新的业务，老板也相对重视；但从整个公司的角度看来，SNG的优势都不太大，以至于我们经常自我调侃：CDG&amp;WXG天之骄子，IEG游戏土豪，OMG一门三杰，TEG养老送终，剩下SNG吭哧吭哧的干活儿，却不知道未来在何方。</p><h3 id="Engineering-Culture"><a href="#Engineering-Culture" class="headerlink" title="Engineering Culture"></a>Engineering Culture</h3><p>作为一个后端server研发，其实大多数时候是不会带入到公司大的场景中去的，但腾讯是一家特殊的公司，是一家以<strong>产品为导向</strong>的公司，每个人都<strong>有</strong>或者说<strong>需要有</strong>那么一点产品意识，这样的结果是：一方面产品在进化发展，产品运营开发测试，每个人对业务的理解更透彻了；另一方面，对技术不那么感冒，甚至可以说，<strong>工程师文化，在腾讯销声匿迹了</strong>，也不能说没有，而是被忽略掉了。</p><p>对于大部分员工来说，KPI还是很重要的，而落实到每个人身上，很可能就是如果快速的解决某个问题，达到某个目的，一件事情做完之后，回头看的机会真的不多，业务在前进，人也一样——在业务飞速前进的大背景下，从Demo改到V3V4，是一件很痛苦的事情，甚至在一些团队变成了不切实际的行动。这样的结果是：<strong>对于大多数非核心部门而言，资源是非常有限的，新的老的业务问题都不一定能搞定，自然无法将资源投放在解决工作效率与代码质量的问题上。半年一次的KPI考评，则从另一个更重要的方面去促使员工选择去解决最能体现价值的业务问题。长期的收敛结果，就是基础设施碎片化、野蛮化生长。</strong></p><h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3><p>DevOps在腾讯，大部分部门都是很空白的。</p><p>代码权限严格，网络权限一年比一年收紧，测试环境(SecureCRT 甚至加上 sz/rz)产能底下，很多生产力工具没提供比如Mac无法申请(其实比某些台式机便宜多了)，很多老员工用着落后其他公司一个时代的硬件产品，追赶着行业领先的技术，这种戴着镣铐跳舞的感觉，很多时候实在让人无奈。</p><p>在SNG内部，经过近几年的发展，是有集成化运维这类的东西的，但仍然不够，很多重复的事情，仍然不得不人肉，而且还有一些非常蛋疼的规范限制着你——比如通过内部系统，每人每天每个pkg只能pub一次，你pub过就只能找其他同事帮忙，不然就上了本月的研发黑榜 = =||，本人有幸连续三个月上榜过。</p><p>另外，腾讯里，很多新团队开发的自动化组件，没有人去用，或者用的很少，推行起来也是困难重重，部门之间，业务不同，KPI没有交集，互帮互助都显得异常珍贵，团队之间，尤其是<em>有点历史</em>的团队之间，技术栈是大相径庭的，要他们容和统一，短时间内实在也不太现实，而长期来看，团队技术栈成型后，他们更倾向于Hire那些符合他们技术点要求的人，而不是能力相当的人，如何循环，再去改造就更加困难了；对比阿里巴巴，内部其实没有特别大的决心去推动一些东西，有学长在阿里中间件工作，基本上集团内推行一种新技术是非常容易的，JDK6到7到8，遇到的阻力也无非是一些必经之路上的技术问题，而不是该不该用好不好用的扯皮，这些问题是腾讯需要思考的。</p><p><strong>说了这么多，从我工程师的角度看，腾讯在产品上确实冠绝业界，但在工程技术上，要走的路还很远很曲折。</strong></p><h3 id="Benefit"><a href="#Benefit" class="headerlink" title="Benefit"></a>Benefit</h3><p>讲完技术，讲点福利。腾讯的福利非常之好，包含了衣食住行的方方面面，每年的旅行团建，夜宵，兑换，住房保障计划，无息贷款，覆盖全深圳堪比中型城市公交系统的班车服务，逢年过节的红包，结婚生育的礼金，甚至给下一代的VIPQQ号……<strong>对于职场新人来说，确实是一家非常值得加入的公司；对于职业暮年的人来说，则可能是可以颐养天年的公司；而对于其他员工，我觉得就因人而异了，可能要看具体工作的方向，部门，和个人对工作的理解了。</strong></p><h3 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h3><p>毕业的三年是一个非常重要的职业阶段，在腾讯我成长了非常多，也学会了很多，感谢与我一同工作的同事们，他们对我的协助，对我的指导，我都铭记于心；而我在腾讯文化的熏陶下，也完成了从一个青涩学生到一个工程师的转变，这些，都是我职业道路上毕生的财富。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鹅厂工作届满三年，明天即将离开，写一点自己的感受，希望能看到一些东西，也不被一些东西所影响。&lt;/p&gt;
    
    </summary>
    
    
      <category term="感悟" scheme="http://chen-tao.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>从jekyll到hexo</title>
    <link href="http://chen-tao.github.io/2017/03/09/move-to-hexo/"/>
    <id>http://chen-tao.github.io/2017/03/09/move-to-hexo/</id>
    <published>2017-03-09T09:39:10.000Z</published>
    <updated>2017-09-14T03:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前折腾了很多次jekyll，不管是评论，还是文章目录，都很不顺手，<strong>这次花了一天，迁移到了hexo</strong></p><p>开始是nodejs的组件报错，某些文章里有特殊的jekyll使用的字符等等，这个就折腾了半天 = = </p><p>然后是git的rebase出问题，差点崩溃，还好解决了</p><p>官网上关于迁移就是这短短的一句话：</p><p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fdgqabh8i6j31520aot9u.jpg" alt=""></p><p>结果却不是这样 = = </p><p>这边选择了next主题，觉得不错，喜欢的可以看下，后面有时间，也会折腾一下主题(可能有坑 = = )</p><p>新开始！</p>]]></content>
    
    <summary type="html">
    
      刀耕火种结束，顺利进入自动化时代。
    
    </summary>
    
    
      <category term="jekyll" scheme="http://chen-tao.github.io/tags/jekyll/"/>
    
      <category term="hexo" scheme="http://chen-tao.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm Anaysis</title>
    <link href="http://chen-tao.github.io/2017/02/08/algo-pic/"/>
    <id>http://chen-tao.github.io/2017/02/08/algo-pic/</id>
    <published>2017-02-07T16:00:00.000Z</published>
    <updated>2017-09-14T03:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/006tKfTcgy1fcivc207a8j319z0pwq8b.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/006tKfTcgy1fcivc207a8j319z0pwq8b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法" scheme="http://chen-tao.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SOA面向服务架构浅析</title>
    <link href="http://chen-tao.github.io/2017/02/01/soa-and-micro-service/"/>
    <id>http://chen-tao.github.io/2017/02/01/soa-and-micro-service/</id>
    <published>2017-01-31T16:00:00.000Z</published>
    <updated>2017-09-14T03:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SOA定义"><a href="#SOA定义" class="headerlink" title="SOA定义"></a>SOA定义</h2><p>SOA是一个组件模型，它将应用程序的不同功能单元(称为服务)通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种这样的系统中的服务可以以一种统一和通用的方式进行交互。</p><p>这种具有中立的接口定义(没有强制绑定到特定的实现上)的特征称为服务之间的松耦合。<strong>SOA的目的，就是要将复杂的紧耦合的系统进行解耦，划分成面向业务的，细粒度，松耦合，无状态的服务。</strong>松耦合系统的好处有两点，一点是它的灵活性，另一点是，当组成整个应用程序的每个服务的内部结构和实现逐渐地发生改变时，它能够继续存在。而另一方面，紧耦合意味着应用程序的不同组件之间的接口与其功能和结构是紧密相连的，因而当需要对部分或整个应用程序进行某种形式的更改时，它们就显得非常脆弱，变更可能会导致部分乃至整个系统的重构。</p><p>对松耦合的系统的需要来源于业务应用程序需要根据业务的需要变得更加灵活，以适应不断变化的环境，比如经常改变的政策、业务级别、业务重点、合作伙伴关系、行业地位以及其他与业务有关的因素，这些因素甚至会影响业务的性质。我们称能够灵活地适应环境变化的业务为按需(On demand)业务，在按需业务中，一旦需要，就可以对完成或执行任务的方式进行必要的更改。</p><p>SOA是传统的面向对象架构模型的替代模型，面向对象的模型是紧耦合的，已经存在二十多年了。虽然基于 SOA 的系统并不排除使用面向对象的设计来构建单个服务，但是其整体设计却是面向服务的。由于它考虑到了系统内的对象，所以虽然 SOA 是基于对象的，但是作为一个整体，它却不是面向对象的。不同之处在于接口本身。SOA 系统原型的一个典型例子是通用对象请求代理体系结构(Common Object Request Broker Architecture，CORBA)，它已经出现很长时间了，其定义的概念与 SOA 相似。</p><p>然而，现在的 SOA 已经有所不同了，因为它依赖于一些更新的进展，这些进展是以可扩展标记语言(eXtensible Markup Language，XML)为基础的。通过使用基于 XML 的语言(称为 Web 服务描述语言(Web Services Definition Language，WSDL))来描述接口，服务已经转到更动态且更灵活的接口系统中，非以前 CORBA 中的接口描述语言(Interface Definition Language，IDL)可比了。更新的，如protobuf，Thrift等标记语言，则已经在RPC与其他服务协议中占有极为重要的角色。</p><p>Web 服务并不是实现 SOA 的惟一方式。前面刚讲的 CORBA 是另一种方式，这样就有了面向消息的中间件(Message-Oriented Middleware)系统。但是为了建立体系结构模型，您所需要的并不只是服务描述。您需要定义整个应用程序如何在服务之间执行其工作流。您尤其需要找到业务的操作和业务中所使用的软件的操作之间的转换点。因此，SOA 应该能够将业务的商业流程与它们的技术流程联系起来，并且映射这两者之间的关系。例如，给供应商付款的操作是商业流程，而更新您的零件数据库，以包括进新供应的货物却是技术流程。因而，工作流还可以在 SOA 的设计中扮演重要的角色。</p><p>此外，动态业务的工作流不仅可以包括部门之间的操作，甚至还可以包括与不为您控制的外部合作伙伴进行的操作。因此，为了提高效率，您需要定义应该如何得知服务之间的关系的策略，这种策略常常采用服务级协定和操作策略的形式。</p><p>最后，所有这些都必须处于一个信任和可靠的环境之中，以同预期的一样根据约定的条款来执行流程。因此，安全、信任和可靠的消息传递应该在任何 SOA 中都起着重要的作用。</p><h2 id="SOA原则"><a href="#SOA原则" class="headerlink" title="SOA原则"></a>SOA原则</h2><p>FROM <a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84" target="_blank" rel="external">WIKI</a></p><p>以下指导原则是开发，维护和使用SOA的基本原则：</p><ul><li>可重复使用, 粒度, 模组性, 可组合型, 物件化原件, 构件化以及具交互操作性</li><li>符合开放标准(通用的或行业的)</li><li>服务的识别和分类，提供和发布，监控和跟踪。</li></ul><p>下面是一些特定的体系架构原则：</p><ul><li>服务封装</li><li>服务松耦合(Loosely coupled) – 服务之间的关系最小化，只是互相知道。(Decouple Infrastructure)</li><li>服务契约 - 服务按照服务描述文档所定义的服务契约行事。</li><li>服务抽象 - 除了服务契约中所描述的内容，服务将对外部隐藏逻辑。</li><li>服务的重用性 - 将逻辑分布在不同的服务中，以提高服务的重用性。</li><li>服务的可组合性 - 一组服务可以协调工作并组合起来形成一个组合服务。</li><li>服务自治 – 服务对所封装的逻辑具有控制权</li><li>服务无状态 – 服务将一个活动所需保存的资讯最小化。</li><li>服务的可被发现性 – 服务需要对外部提供描述资讯，这样可以通过现有的发现机制发现并访问这些服务。[4]</li></ul><p>除此以外，在定义一个SOA实现时，还需要考虑以下因素：</p><ul><li>生命周期管理</li><li>有效使用系统资源</li><li>服务成熟度和性能</li></ul><h2 id="SOA用途"><a href="#SOA用途" class="headerlink" title="SOA用途"></a>SOA用途</h2><p>对 SOA 的需要来源于需要使业务 IT 系统变得更加灵活，以适应业务中的改变。通过允许强定义的关系和依然灵活的特定实现，IT 系统既可以利用现有系统的功能，又可以准备在以后做一些改变来满足它们之间交互的需要。</p><p>改变和 SOA 系统适应改变的能力是最重要的部分。对于开发人员来说，这样的改变无论是在他们工作的范围之内还是在他们工作的范围之外都有可能发生，这取决于是否有改变需要知道接口是如何定义的以及它们相互之间如何进行交互。与开发人员不同的是，架构师的作用就是引起对 SOA 模型大的改变。这种分工，就是让开发人员集中精力于创建作为服务定义的功能单元，而让架构师和建模人员集中精力于如何将这些单元适当地组织在一起。</p><h2 id="SOA与微服务"><a href="#SOA与微服务" class="headerlink" title="SOA与微服务"></a>SOA与微服务</h2><p>相比于基于业务的SOA，微服务则纯粹基于服务模块，也就是每个服务独立为一个子系统，平行扩容对其他服务透明，强调系统的伸缩性，服务发现，负载均衡，故障转移，高可用。微服务是互联网时代的新产物，它对服务的容错与可用提出了更新的思考，比如多版本，灰度发布，服务降级，分布式跟踪，这些都是SOA在实践中重视不够的地方，。</p><p>SOA在企业领域的应用更为广泛，对服务的可用性保证也很高，而很多现代互联网企业，对实时性的要求，对数据一致性的要求，甚至对大流量下可用性的要求都是弹性的，比如腾讯，很多业务服务的运营核心是：有损服务，动态运营，这时候，微服务的作用就显现出来，在海量请求下，尽量保证大多数用户的服务，尽量快（弱一致性）的实现数据的同步。可以说，SOA与微服务在不同的领域，但做法可以相互借鉴。</p>]]></content>
    
    <summary type="html">
    
      SOA面向服务架构的一点自我分析，同时对比一下SOA与微服务，互相借鉴，有的放失。
    
    </summary>
    
      <category term="感悟" scheme="http://chen-tao.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="server" scheme="http://chen-tao.github.io/tags/server/"/>
    
      <category term="服务" scheme="http://chen-tao.github.io/tags/%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>quick sort快速排序算法总结 </title>
    <link href="http://chen-tao.github.io/2017/01/28/quick-sort/"/>
    <id>http://chen-tao.github.io/2017/01/28/quick-sort/</id>
    <published>2017-01-27T16:00:00.000Z</published>
    <updated>2017-09-14T03:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天总结一下非常有用的快速排序(qsort)算法, 以及由此衍生的一些其他相关算法(Knuth shuffle, quick select, 3-way partition).</p><p>快速排序的算法可以用三句话描述:<br><strong>[Algo]</strong></p><blockquote><ul><li>选择基准项(pivot element, 一般取第一个元素为pivot)</li><li>把数组里所有小于pivot的移动到pivot左边, 大于pivot的移动到右边 ⇒ 此时pivot已经位于最终排序时的正确位置</li><li>对pivot左右两个数组分别递归进行快速排序</li></ul></blockquote><p>由以上描述可见, qsort是一个递归算法, 我们可以把它的函数声明写成: <code>void qsort(int[] a, int lo, int hi)</code>, 表示排序a[lo, hi]之间(闭区间)的所有元素.</p><h2 id="quick-partition"><a href="#quick-partition" class="headerlink" title="quick partition"></a>quick partition</h2><p>由上面描述可以见, qsort最关键的是第二步: 把数组元素以pivot分为两部分. 这个操作就是quick partition.</p><p>函数声明为: <code>int partition(int[] a, int lo, int hi)</code>, 该函数返回pivot(即subarray的第一个元素<code>a[lo]</code>)所在的位置.</p><p>如果允许新建一个临时数组的话, 那么这个就不是什么问题, 但是为了节约空间占用, 现在需要直接修改(in-place)使得a[lo] 到, 而且希望可以用尽量少的交换(<code>swap(int[]a, int i, int j)</code>)操作, 就不是很evident了.</p><p>这个函数的写法是用两个指针i和j分别从两端向中间走, 如果两个指针指向的元素一个小于pivot一个大于pivot那么就进行交换, 当两个指针碰面的时候结束(最后把pivot和指针元素交换). 请看下面这个萌萌的图(图片来自&lt;&lt;啊哈!算法&gt;&gt;):<br><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7ns2lgb3j30f005p3yp.jpg" alt=""></p><p>选取第一个元素(6)为pivot, 然后j向左走直到遇到一个小于pivot(6)的数停止, i向右走直到遇到一个大于pivot的数停止(<em>注意要让j先移动</em>), 此时二者交换:<br><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7nsfvemtj30dm0a83yz.jpg" alt=""></p><p>只要重复这个过程, 直到i&gt;=j为止, 此时只要最后把pivot和j(<em>注意是j而不是i</em>)指向的元素交换即可:<br><img src="https://ww2.sinaimg.cn/large/006tNbRwgy1fc7nsr0uuxj30dp0bidga.jpg" alt=""></p><p>所以pivot的位置就是j, 函数返回j即可.</p><p>java实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;  </div><div class="line">    <span class="keyword">int</span> pivot = a[lo], i=lo, j=hi;  </div><div class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </div><div class="line">        <span class="keyword">for</span>(;j&gt;=lo &amp;&amp; a[j]&gt;=pivot;j--);<span class="comment">// move j to a point where a[j]&lt;pivot  </span></div><div class="line">        <span class="keyword">for</span>(;i&lt;=hi &amp;&amp; a[i]&lt;=pivot;i++);<span class="comment">// move i to a point where a[i]&gt;pivot  </span></div><div class="line">        <span class="keyword">if</span>(i&gt;=j) <span class="keyword">break</span>;<span class="comment">// break if i and j meets  </span></div><div class="line">        swap(a, i++, j--);  </div><div class="line">    &#125;  </div><div class="line">    swap(a, lo, j);<span class="comment">// swap pivot with a[j]  </span></div><div class="line">    <span class="keyword">return</span> j;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里有几点要注意的:</p><ul><li>让j先移动</li><li>最后pivot要和j交换而不是和i交换: 因为最后放在最左边的应该是一个小于pivot的数嘛</li><li>移动的时候别忘了需要加数组下标的边界检查(<code>i&lt;=hi</code>, <code>j&gt;=lo</code>)</li><li>partition()的复杂度是线性的<strong>O(n)</strong></li></ul><h2 id="Knuth-shuffle"><a href="#Knuth-shuffle" class="headerlink" title="Knuth shuffle"></a>Knuth shuffle</h2><p>qsort之所以快, 是因为每次都能够按照pivot分为大致同样长度的两个子数组(所以每次子问题的规模除以二), 所以复杂度为<strong>O(NlogN)</strong>. 最坏情况下, 如果每次两个子数组中可能有一个长度为0, 那么每次子问题的规模只减少了1, 所以复杂度变成了quadratic <strong>O(N2)</strong>.</p><p>为了防止这种最坏情况的出现, 可以在一切开始之前把数组打乱顺序, 所以这一节讨论快速shuffle的算法. 最经典的就是Knuth的shuffle算法了, 算法很简答, 描述为: for(k=1 to n): 每次把第k个元素和前k个元素中的随机一个元素交换.</p><p>代码只有两行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;  </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> K=<span class="number">0</span>; K&lt;a.length; K++)  </div><div class="line">        swap(K, Random.nextInt(K+<span class="number">1</span>));  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>关于算法的正确性, 其实只要证明”元素i在shuffle后最终位于位置i”的概率为1/N即可, 不难证明.</p><h2 id="quick-sort"><a href="#quick-sort" class="headerlink" title="quick sort"></a>quick sort</h2><p>好了 有了以上两个辅助函数就可以写qsort函数了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;<span class="comment">//recursive helper function  </span></div><div class="line">    <span class="keyword">if</span>(lo&gt;=hi) <span class="keyword">return</span>;  </div><div class="line">    <span class="keyword">int</span> p = partition(a, lo, hi);  </div><div class="line">    qsort(a, lo, p-<span class="number">1</span>);  </div><div class="line">    qsort(a, hi, p+<span class="number">1</span>);  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;  </div><div class="line">    shuffle(a);  </div><div class="line">    qsort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其实qsort的主体就是那个partition函数, 单独把partition列出来是因为它不止可以用在排序, 还可以用来做quick select, 见quick select节.</p><h2 id="quick-select"><a href="#quick-select" class="headerlink" title="quick select"></a>quick select</h2><p><em>对于一个没有排序的数组, 如何快速找到它的中值(median)?</em><br>以上这个问题的答案就在<code>partition()</code>函数.</p><p>之前说过, <code>partition()</code>函数的返回值表示pivot在排序好的数组中的位置(rank), 这个消息非常有用: 中值只不过是rank等于长度除以2的元素而已.</p><p>为了寻找rank等于k的元素, 我们用partition函数可以每次把问题规模缩小: 如果partition()=pk那么右边subarray不用考虑, 如果数组事先shuffle过了的话, 问题规模每次缩小一半.</p><p>定义一个函数, 寻找rank等于k的元素, 代码类似于二分查找:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int findKth(int[] a, int k)&#123;  </div><div class="line">    shuffle(a);  </div><div class="line">    int lo=0, hi=a.length-1;  </div><div class="line">    while(lo&lt;hi)&#123;  </div><div class="line">    int p = partition(a, lo, hi);  </div><div class="line">    if(p==k) return a[k];  </div><div class="line">    else if(p&lt;k) lo=p+1;  </div><div class="line">    else hi=p-1;  </div><div class="line">    &#125;  </div><div class="line">    return a[k];  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该算法内层循环为O(hi-lo), 每次问题规模减少一半, 所以复杂度为N+N/2+N/4+…+1 = 2N, 复杂度为线性时间!</p><h2 id="3-way-qsort"><a href="#3-way-qsort" class="headerlink" title="3-way qsort"></a>3-way qsort</h2><p>qsort之前有个bug: 在数组里很多重复元素的时候, 效率会下降为O(N2). 原因是qsort没有好好处理重复元素的问题.</p><p>于是Dijkstra提出了一个<strong>3-way partition</strong>的算法: 把数组分为三部分: 左边<code>[lo, lt)</code>严格小于pivot, 中间<code>[lt, gt]</code>等于pivot, 右边<code>(gt, hi]</code>严格大于pivot.</p><p>算法初始化<code>lt=lo, gt=hi, i=lo</code>, 用指针i向右扫描, [i,gt]为未处理到的部分.<br>算法很subtle, invariant是这样的:</p><blockquote><ul><li>a[lo,lt-1] &lt; pivot</li><li>a[lt, i-1] = pivot</li><li>a[i,gt] = unseen</li><li>a[gt+1, hi] &gt; pivot</li></ul></blockquote><p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fc7nt1aur7j309k03gq2v.jpg" alt=""><br>这个图很有助于写代码:<br><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7nta4jkzj308704s0sr.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort3way</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;  </div><div class="line">    <span class="keyword">if</span>(hi&lt;=lo) <span class="keyword">return</span>;  </div><div class="line">    <span class="keyword">int</span> lt=lo, i=lo, gt=hi, pivot=a[lo];  </div><div class="line">    <span class="keyword">while</span> (i&lt;=gt)&#123;<span class="comment">// [i,gt] is unseen elements  </span></div><div class="line">        <span class="keyword">if</span>(a[i]==pivot) <span class="comment">//a[lt,i-1] are elements == pivot  </span></div><div class="line">            i++;  </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;pivot) <span class="comment">// a[gt+1, hi] are elements &gt; pivot  </span></div><div class="line">            swap(a, gt--, i);  </div><div class="line">        <span class="keyword">else</span> <span class="comment">// a[lo, lt-1] are elements &lt; pivot  </span></div><div class="line">            swap(a, lt++, i++);  </div><div class="line">    &#125;  </div><div class="line">    qsort3way(a, lo, lt-<span class="number">1</span>);  </div><div class="line">    qsort3way(a, gt+<span class="number">1</span>, hi);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>说它很subtle, 除了因为没有那个图我写不出来以外, 还有就是, 在把i和lt交换时, i可以increment (因为我们知道<code>a[lt]==pivot</code>), 但是i和gt交换时, i<strong>不能</strong>increment: 因为a[gt]不知道多大, 所以i位置要继续检查.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天总结一下非常有用的快速排序(qsort)算法, 以及由此衍生的一些其他相关算法(Knuth shuffle, quick select, 3-way partition).&lt;/p&gt;
&lt;p&gt;快速排序的算法可以用三句话描述:&lt;br&gt;&lt;strong&gt;[Algo]&lt;/stron
      
    
    </summary>
    
      <category term="算法" scheme="http://chen-tao.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://chen-tao.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="快速排序" scheme="http://chen-tao.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
      <category term="sort" scheme="http://chen-tao.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>递归，回溯，DFS，BFS的理解和模板</title>
    <link href="http://chen-tao.github.io/2017/01/27/al-template/"/>
    <id>http://chen-tao.github.io/2017/01/27/al-template/</id>
    <published>2017-01-26T16:00:00.000Z</published>
    <updated>2017-09-14T03:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 里面很大一部分题目都是属于这个范围，例如Path Sum用的就是递归+DFS，Path Sum2用的是递归+DFS+回溯</p><p>这里参考了一些网上写得很不错的文章，总结一下理解与模板</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归：就是出现这种情况的代码： （或者说是用到了栈）</p><p>解答树角度：在dfs遍历一棵解答树      </p><p>优点：结构简洁</p><p>缺点：效率低，可能栈溢出</p><p>递归的一般结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">     <span class="keyword">if</span>(符合边界条件)</div><div class="line">    &#123;</div><div class="line">       <span class="comment">///////</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">     <span class="comment">//某种形式的调用</span></div><div class="line">     f();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>回溯：递归的一种，或者说是通过递归这种代码结构来实现回溯这个目的。回溯法可以被认为是一个有过剪枝的DFS过程。</p><p>解答树角度：带回溯的dfs遍历一棵解答树</p><p>回溯的一般结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> 当前状态)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">      <span class="keyword">if</span>(当前状态为边界状态)</div><div class="line">      &#123;</div><div class="line">        记录或输出</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//横向遍历解答树所有子节点</span></div><div class="line">     &#123;</div><div class="line">           <span class="comment">//扩展出一个子状态。</span></div><div class="line">           修改了全局变量</div><div class="line">           <span class="keyword">if</span>(子状态满足约束条件)</div><div class="line">            &#123;</div><div class="line">              dfs(子状态)</div><div class="line">           &#125;</div><div class="line">            恢复全局变量<span class="comment">//回溯部分</span></div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="BFS-amp-DFS"><a href="#BFS-amp-DFS" class="headerlink" title="BFS&amp;DFS"></a>BFS&amp;DFS</h2><p>常用的搜索方式。</p><ol><li>枚举。枚举运算量很大，需要预先确定枚举的定义域。</li><li>广度优先搜索（BFS ）——通常可以用于计算图的连通性、单源最短路径、计算最小操作次数等。</li><li>深度优先搜索（DFS）——经典题：火力中心布局。</li></ol><p>BFS的占用的是队列的空间</p><p>DFS 占用的是栈的空间（因为递归）</p><p>BFS和DFS的空间复杂度恰好相反</p><p>对链状图，BFS最好（队列中最多只有1个元素），DFS最差（所有节点都在根节点的递归内）</p><p>对起点与其他所有点相邻的图，DFS最好（递归深度为1），BFS最差（队列中放满了所有与起点相邻的图）。</p><h3 id="BFS模版"><a href="#BFS模版" class="headerlink" title="BFS模版"></a>BFS模版</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">queue</span>&lt;type&gt; q;</div><div class="line">q.push(初始状态);</div><div class="line"><span class="keyword">while</span> (!q.empty())</div><div class="line">&#123;</div><div class="line">  type t = q.front() ;</div><div class="line">  q.pop();</div><div class="line">  遍历 t 的各个Next状态  next</div><div class="line">  &#123; </div><div class="line">    <span class="keyword">if</span> (next is legal)</div><div class="line">      q.push(next); 计数或维护等; </div><div class="line">  &#125; </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是BFS的状态数一多，需要的空间就会较大。因此就需要状态压缩，BUPT OJ上的1180就是一个典型的例子，但是状态压缩以及解压的时候，又会涉及效率，反正1180将80M的状态压缩到40K以后就超时了……</p><h3 id="DFS模板"><a href="#DFS模板" class="headerlink" title="DFS模板"></a>DFS模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">DFS（顶点） </div><div class="line">&#123;</div><div class="line">　　处理当前顶点，记录为已访问</div><div class="line">　　遍历与当前顶点相邻的所有未访问顶点</div><div class="line">　　&#123;</div><div class="line">　　　　　　标记更改;</div><div class="line">　　　　　　DFS( 下一子状态);</div><div class="line">　　　　　　恢复更改;</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>回溯法：DFS适用于 显式图，但是对于一些隐式关系，我们需要使用回溯法，通过定义或找到各个状态、边界条件、搜索范围、约束条件和最优解结果进行建模求解。</p><p>边界条件：达到某状态时，需要检查并确定是继续搜索还是回到上一状态的条件（例如当前已使用时间比当前最优解要长，此时就不需要再进行搜索）</p><p>搜索范围：当前从当前状态开始进行搜索的所有下一级状态。 </p><p>搜索范围：</p><p>另外一定要注意，假如参与递归的参数不是通过传参形式的方式进入递归的话，那么一定要做好数据恢复。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Trace（当前状态） </div><div class="line">&#123;</div><div class="line">    if 当前状态是结束状态</div><div class="line">    &#123;</div><div class="line">         if 是最佳解： 记录。</div><div class="line">         退出</div><div class="line">    &#125;</div><div class="line">    遍历当前状态的各个邻接状态</div><div class="line">    &#123;</div><div class="line">        if 当前状态满足约束条件 且 满足最优性要求 ： Trace（子状态） </div><div class="line">    &#125; </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LeetCode 里面很大一部分题目都是属于这个范围，例如Path Sum用的就是递归+DFS，Path Sum2用的是递归+DFS+回溯&lt;/p&gt;
&lt;p&gt;这里参考了一些网上写得很不错的文章，总结一下理解与模板&lt;/p&gt;
&lt;h2 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; cl
      
    
    </summary>
    
      <category term="算法" scheme="http://chen-tao.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://chen-tao.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="http://chen-tao.github.io/tags/BFS/"/>
    
      <category term="递归" scheme="http://chen-tao.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="回溯" scheme="http://chen-tao.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
      <category term="DFS" scheme="http://chen-tao.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>DFS深度优先搜索算法总结</title>
    <link href="http://chen-tao.github.io/2017/01/26/about-dfs/"/>
    <id>http://chen-tao.github.io/2017/01/26/about-dfs/</id>
    <published>2017-01-25T16:00:00.000Z</published>
    <updated>2017-09-14T03:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><ul><li><a href="#recursive-dfs">Recursive DFS</a></li><li><a href="#non-recursive-dfs">Non-Recursive DFS</a><ul><li><a href="#for-tree-dfs-with-depth">(for Tree) DFS with depth</a></li><li><a href="#dfs-for-binary-tree--preorder-traversal">DFS for binary tree–PreOrder traversal</a></li></ul></li><li><a href="#cycle-detection">Cycle Detection</a></li><li><a href="#topology-sort">Topology Sort</a></li><li><a href="#leetcode-dfs">LeetCode DFS</a><ul><li><a href="#subsets">Subsets</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><p>总结复习一下DFS算法。</p><p>深度优先算法是N种算法的基础，是算法学习中的重中之重。</p><p>可以解决的问题类型也很多：递归，回溯，隐图式搜索，甚至是暴力类型算法的万金油。</p><h2 id="DFS-intro"><a href="#DFS-intro" class="headerlink" title="DFS intro"></a>DFS intro</h2><p>图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。</p><p>它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>显然，深度优先搜索是一个递归的过程。</p><h2 id="Understand-DFS"><a href="#Understand-DFS" class="headerlink" title="Understand DFS"></a>Understand DFS</h2><h3 id="无向图-undirected-graph"><a href="#无向图-undirected-graph" class="headerlink" title="无向图(undirected graph)"></a>无向图(undirected graph)</h3><p><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7glkmecsj30bl08fq3b.jpg" alt=""></p><p>对于上图的遍历，步骤如下：</p><p><img src="https://ww1.sinaimg.cn/large/006tNbRwgy1fc7gowbrw3j30c409hmxs.jpg" alt=""></p><p><strong>第1步</strong>：访问A。 </p><p><strong>第2步</strong>：访问(A的邻接点)C。 </p><pre><code>在第1步访问A之后，接下来应该访问的是A的邻接点，即&quot;C,D,F&quot;中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在&quot;D和F&quot;的前面，因此，先访问C。 </code></pre><p><strong>第3步</strong>：访问(C的邻接点)B。 </p><pre><code>在第2步访问C之后，接下来应该访问C的邻接点，即&quot;B和D&quot;中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。 </code></pre><p><strong>第4步</strong>：访问(C的邻接点)D。 </p><pre><code>在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。 </code></pre><p><strong>第5步</strong>：访问(A的邻接点)F。 </p><pre><code>前面已经访问了A，并且访问完了&quot;A的邻接点B的所有邻接点(包括递归的邻接点在内)&quot;；因此，此时返回到访问A的另一个邻接点F。 </code></pre><p><strong>第6步</strong>：访问(F的邻接点)G。 </p><p><strong>第7步</strong>：访问(G的邻接点)E。</p><p>因此访问顺序是：<strong>A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E</strong></p><h3 id="有向图-directed-graph"><a href="#有向图-directed-graph" class="headerlink" title="有向图(directed graph)"></a>有向图(directed graph)</h3><p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fc7gqb4esdj308f08y74n.jpg" alt=""></p><p><img src="https://ww2.sinaimg.cn/large/006tNbRwgy1fc7gqggvlfj308f0a0gm7.jpg" alt=""></p><p><strong>第1步</strong>：访问A。 </p><p><strong>第2步</strong>：访问B。 </p><pre><code>在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。 </code></pre><p><strong>第3步</strong>：访问C。 </p><pre><code>在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。 </code></pre><p><strong>第4步</strong>：访问E。 </p><pre><code>接下来访问C的出边的另一个顶点，即顶点E。 </code></pre><p><strong>第5步</strong>：访问D。 </p><pre><code>接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。 </code></pre><p><strong>第6步</strong>：访问F。 </p><pre><code>接下应该回溯&quot;访问A的出边的另一个顶点F&quot;。 </code></pre><p><strong>第7步</strong>：访问G。</p><p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G</strong></p><h2 id="DFS-implement"><a href="#DFS-implement" class="headerlink" title="DFS implement"></a>DFS implement</h2><p>由于tree可以看做特殊的graph，这里针对graph来实现</p><p>​<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> calss GraphNode&#123;</div><div class="line">  <span class="keyword">int</span> val;</div><div class="line">  List&lt;GraphNode&gt; neighnors;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>为了防止重复，使用一个HashSet来保存已经遍历过的节点</p><p>​<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HashSet&lt;GraphNode&gt; visited = <span class="keyword">new</span> HashSet&lt;GraphNode&gt;();</div></pre></td></tr></table></figure></p><h3 id="Recursive-DFS"><a href="#Recursive-DFS" class="headerlink" title="Recursive DFS"></a>Recursive DFS</h3><p>每到一个节点，标记已经被访问过，对邻居里没有访问的节点进行DFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(GraphNode nd)</span></span>&#123;</div><div class="line">  <span class="comment">//print nd.val</span></div><div class="line">  visited.add(nd);</div><div class="line">  <span class="keyword">for</span>(GraphNode next : nd.neighbours)&#123;</div><div class="line">    <span class="keyword">if</span>(!visited.contains(next))&#123;</div><div class="line">      DFS(next);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>经典的DFS，回溯算法(backtracking)其实相当于在一个求解域做DFS(剪枝)，另外，拓扑排序也是基于递归DFS进行的一点修改</p><h3 id="Non-Recursive-DFS"><a href="#Non-Recursive-DFS" class="headerlink" title="Non-Recursive DFS"></a>Non-Recursive DFS</h3><p>非递归版本，相比递归版本效率高，且不会导致栈溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(GraphNode start)</span></span>&#123;</div><div class="line">  Stack&lt;GraphNode&gt; s = <span class="keyword">new</span> Stack&lt;GraphNode&gt;();</div><div class="line">  q.push(start);</div><div class="line">  visited.add(start);</div><div class="line">  <span class="keyword">while</span>(!s.empty())&#123;</div><div class="line">    GraphNode cur = s.pop();</div><div class="line">    <span class="comment">//print cur.val</span></div><div class="line">    <span class="keyword">for</span>(GraphNode next : cur.children)&#123;</div><div class="line">      <span class="keyword">if</span>(!visited.contains(next))&#123;</div><div class="line">        s.push(next);</div><div class="line">        visited.add(next);<span class="comment">//mark node as visited when adding to stack.</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="comment">//while end</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="for-Tree-DFS-with-depth"><a href="#for-Tree-DFS-with-depth" class="headerlink" title="(for Tree) DFS with depth"></a>(for Tree) DFS with depth</h3><p>深度在搜索中记录，递归版本加一个depth参数++就可以了，非递归版本用一个和s平行的栈记录深度</p><h3 id="DFS-for-binary-tree–PreOrder-traversal"><a href="#DFS-for-binary-tree–PreOrder-traversal" class="headerlink" title="DFS for binary tree–PreOrder traversal"></a>DFS for binary tree–PreOrder traversal</h3><p>DFS对于二叉树而言，其遍历序列就是其前序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[preorder(node)] = node.val + [preorder(node.left)] + [preorder(node.right)]</div></pre></td></tr></table></figure><h2 id="Cycle-Detection"><a href="#Cycle-Detection" class="headerlink" title="Cycle Detection"></a>Cycle Detection</h2><p>对DFS稍作修改，可以判断一个有向图是否有回路</p><p>在递归版本里，我们队每一个点改为三种标记：</p><ul><li>未访问过(0)</li><li>正在访问其邻居节点(1)</li><li>已经访问完毕该节点以及所有该节点可以到达的节点(2)</li></ul><p>什么时候会出现回路？<strong>就是当前节点v的一个邻居u的状态为1的时候。</strong></p><p>因为该节点状态为1，即还没有把它以后的节点全部遍历，所以当前节点v肯定可以从u到达，而现在又可以从v到达u，所以回路构成。</p><p>为了表示一个节点的三种状态, 我们把visited的定义改一下, 定义为一个hashmap:<br><code>HasheMap visited = new HasheMap();</code></p><p>节点不在visited表示还未访问过, 节点对应为false表示正在访问, 节点对应为true表示已经访问该节点以及所有可以从它到达的节点.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(GraphNode nd)</span></span>&#123;      </div><div class="line">    visited.put(nd, <span class="keyword">false</span>); <span class="comment">// mark as status-1   </span></div><div class="line">    <span class="keyword">for</span>(GraphNode next: nd.neighbors)&#123;   </div><div class="line">        <span class="keyword">if</span>( !visited.contains(next) )   </div><div class="line">            DFS(next);   </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(visited.get(next)==<span class="keyword">false</span>) <span class="comment">// found cycle   </span></div><div class="line">            System.out.println(<span class="string">"Cycle detected!!!"</span>);   </div><div class="line">    &#125;<span class="comment">// now all touchable nodes from nd are visited   </span></div><div class="line">    visited.put(nd, <span class="keyword">true</span>); <span class="comment">// mark as status-2   </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Topology-Sort"><a href="#Topology-Sort" class="headerlink" title="Topology Sort"></a>Topology Sort</h2><p>这一节(以及上一节)参考这个非常棒的视频: <a href="https://class.coursera.org/algo-003/lecture/52" target="_blank" rel="external">https://class.coursera.org/algo-003/lecture/52</a></p><p>拓扑排序是一个dfs的应用, 所谓拓扑排序是指在一个DAG(有向无回路图)里给每个节点定义一个顺序(v1…vn), 使得按照这个顺序遍历的节点, 每一个节点vi都是之前遍历过的的节点(v1 ~ vi-1)所指向的(或没有任何其他节点指向的).</p><p>好像还没说清楚… 拓扑排序的一个应用就是对于各种依赖性(比如学习课程A需要先学习过课程B)组成的图寻找一个节点遍历的顺序使其可行.</p><p><strong>propositions</strong>:</p><blockquote><ul><li>拓扑排序的结果不唯一.</li><li>有回路的图不存在拓扑顺序.</li><li>如果一个节点没有出边, 那么它可以放在拓扑排序的最后面(没有节点以来它).</li><li>如果一个节点没有入边, 那么它可以放在拓扑排序的最后面.</li></ul></blockquote><p>简单修改一下递归的dfs就可以处理拓扑排序: 维护一个计数器<code>K</code>(初始化为n=所有节点数), 每当一个点已经遍历完毕(所有通过这个点可以到达的点都已经被走过)以后, 就把这个点的顺序设为K, 同时减少K.</p><p>就用一个HashMap来为每个节点关联一个序号好了:<br><code>HasheMap order = new HasheMap();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(GraphNode nd)</span></span>&#123;      </div><div class="line">    <span class="keyword">for</span>(GraphNode next: nd.neighbors)&#123;   </div><div class="line">        <span class="keyword">if</span>( !visited.contains(next) )   </div><div class="line">            DFS(next);   </div><div class="line">    &#125;<span class="comment">// all touchable nodes from nd are visited   </span></div><div class="line">    order.put(nd, K--);   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面只是对于一个点进行的, 为了给所有点拓扑排序, 只要从一个没有出边的节点出发进行遍历, 一直运行到所有的节点都已经访问过为止。</p><h2 id="LeetCode-DFS"><a href="#LeetCode-DFS" class="headerlink" title="LeetCode DFS"></a>LeetCode DFS</h2><p>LeetCode上很多题目都是使用DFS或其思想进行处理的</p><p>DFS的框架可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//结果集</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> T ans = <span class="keyword">new</span> T();</div><div class="line"><span class="comment">//中间结果集</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> T path = <span class="keyword">new</span> T();</div><div class="line"><span class="comment">//问题</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">problem</span><span class="params">()</span></span>&#123;</div><div class="line">  ans.clear();<span class="comment">//leetcode的一个特殊点，每次要清空结果集，避免重复</span></div><div class="line">  robot(idx ,...);<span class="comment">//DFS部分，常用idx作为结果递归的标志</span></div><div class="line">  <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"><span class="comment">//DFS</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">robot</span><span class="params">(<span class="keyword">int</span> idx, ...)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(xxx)&#123;<span class="comment">//边界条件，递归出口条件</span></div><div class="line">    <span class="comment">//用当前path内容生成一部分结果集</span></div><div class="line">    <span class="comment">//handle path </span></div><div class="line">    ans.add(tmp);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//递归处理</span></div><div class="line">  path[idx] = <span class="keyword">true</span>;<span class="comment">//递归前假设</span></div><div class="line">  robot(++idx, ...);<span class="comment">//根据不同情况进行处理</span></div><div class="line">  path[idx] = <span class="keyword">false</span>;<span class="comment">//递归后还原</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里举例进行分析：</p><h3 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h3><p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets.</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p>For example,<br>If <strong>nums</strong> = <code>[1,2,3]</code>, a solution is:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [3],</div><div class="line">  [1],</div><div class="line">  [2],</div><div class="line">  [1,2,3],</div><div class="line">  [1,3],</div><div class="line">  [2,3],</div><div class="line">  [1,2],</div><div class="line">  []</div><div class="line">]</div></pre></td></tr></table></figure><script src="https://gist.github.com/Chen-tao/f97f5628bdf96b2ce8ea3b11822d40c5.js"></script><p>原集合每一个数字只有两种状态，要么存在，要么不存在，那么在构造子集时就有选择和不选择两种情况，所以可以构造一棵二叉树，左子树表示选择该层处理的节点，右子树表示不选择，最终的叶节点就是所有子集合，树的结构如下：</p><p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fc7i519tsrj30d6083jru.jpg" alt=""></p><p>DFS几乎可以算是图与树种最重要的算法，这里总结不算全面，但基本涵盖，这里最主要是搜索递归的思想。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#recursive-dfs&quot;&gt;Recursive DFS&lt;/a&gt;&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://chen-tao.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://chen-tao.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="http://chen-tao.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="回溯" scheme="http://chen-tao.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
      <category term="DFS" scheme="http://chen-tao.github.io/tags/DFS/"/>
    
      <category term="搜索" scheme="http://chen-tao.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>BFS广度优先搜索算法总结</title>
    <link href="http://chen-tao.github.io/2017/01/25/about-bfs/"/>
    <id>http://chen-tao.github.io/2017/01/25/about-bfs/</id>
    <published>2017-01-24T16:00:00.000Z</published>
    <updated>2017-09-14T03:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BFS-intro"><a href="#BFS-intro" class="headerlink" title="BFS intro"></a>BFS intro</h2><p>广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。</p><p>它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。</p><h2 id="Understand-BFS"><a href="#Understand-BFS" class="headerlink" title="Understand BFS"></a>Understand BFS</h2><h3 id="无向图-undirected-graph"><a href="#无向图-undirected-graph" class="headerlink" title="无向图(undirected graph)"></a>无向图(undirected graph)</h3><p><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7jidbnayj30eq0e73zi.jpg" alt=""></p><p><strong>第1步</strong>：访问A。 </p><p><strong>第2步</strong>：依次访问C,D,F。 </p><pre><code>在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在&quot;D和F&quot;的前面，因此，先访问C。再访问完C之后，再依次访问D,F。 </code></pre><p><strong>第3步</strong>：依次访问B,G。 </p><pre><code>在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。 </code></pre><p><strong>第4步</strong>：访问E。 </p><pre><code>在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。</code></pre><p>因此访问顺序是：<strong>A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E</strong></p><h3 id="有向图-directed-graph"><a href="#有向图-directed-graph" class="headerlink" title="有向图(directed graph)"></a>有向图(directed graph)</h3><p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fc7jjkk7w8j30fs0cn75e.jpg" alt=""></p><p><strong>第1步</strong>：访问A。 </p><p><strong>第2步</strong>：访问B。 </p><p><strong>第3步</strong>：依次访问C,E,F。 </p><pre><code>在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。 </code></pre><p><strong>第4步</strong>：依次访问D,G。 </p><pre><code>在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。</code></pre><p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G</strong></p><h2 id="BFS-implement"><a href="#BFS-implement" class="headerlink" title="BFS implement"></a>BFS implement</h2><p>对于没有边权重的图来说可以计算最短路径. </p><p>由于树的BFS只是图的BFS的一种特殊情况, 而且比较简单不需要visited标记, 这里只写一下图的BFS好了. </p><p>先定义一个Graph类, 这里在每一个节点保存邻居信息:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphNode</span></span>&#123;   </div><div class="line">    <span class="keyword">int</span> val;   </div><div class="line">    List&lt;GraphNode&gt; neighbors;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="BFS-for-trees-graphs"><a href="#BFS-for-trees-graphs" class="headerlink" title="BFS for trees/graphs"></a>BFS for trees/graphs</h3><p>图的遍历需要注意不走重复节点, 所以需要一个HashSet(名字叫visited)来保存哪些节点已经访问过了. </p><p>需要注意的是, <em>在把一个节点放进队列queue的时刻就要把它放进visited</em>, 而不是在队列里取出来的时刻再放.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(GraphNode start)</span></span>&#123;   </div><div class="line">    LinkedList&lt;GraphNode&gt; q = <span class="keyword">new</span> LinkedList&lt;GraphNode&gt;();   </div><div class="line">    HasheSet&lt;GraphNode&gt; visited = <span class="keyword">new</span> HasheSet&lt;GraphNode&gt;();   </div><div class="line">    q.push(start);   </div><div class="line">    visited.add(start);   </div><div class="line">    <span class="keyword">while</span>(!q.empty())&#123;   </div><div class="line">        GraphNode cur = q.poll();   </div><div class="line">        System.out.println(cur.val);   </div><div class="line">        <span class="keyword">for</span>(GraphNode next: cur.children)&#123;    </div><div class="line">            <span class="keyword">if</span>(!visited.contains(next))&#123;   </div><div class="line">                q.push(next);   </div><div class="line">                visited.add(next); <span class="comment">// mark node as visited when adding to queue!    </span></div><div class="line">            &#125;   </div><div class="line">        &#125;   </div><div class="line">    &#125;<span class="comment">//while   </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="BFS-with-distance"><a href="#BFS-with-distance" class="headerlink" title="BFS with distance"></a>BFS with distance</h3><p>在BFS的同时我们可以记录从start节点到当前node的距离, 方法是把一个距离信息同时入队(封装一个<code>Pair</code>), 或者使用一个与queue<em>平行</em>的队列保存距离信息. </p><p>在上面的代码中, 加入:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//...   </span></div><div class="line">LinkedList&lt;Integer&gt; distq = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();   </div><div class="line">distq.push(<span class="number">0</span>);<span class="comment">// distance from start to start   </span></div><div class="line"><span class="comment">//...   </span></div><div class="line"><span class="comment">// in the while(!q.empty()) loop:    </span></div><div class="line">    <span class="keyword">int</span> d = distq.poll();<span class="comment">//get distance from start to current node   </span></div><div class="line">    <span class="keyword">for</span>(GraphNode next: node.children)&#123;   </div><div class="line">        distq.push(d+<span class="number">1</span>);<span class="comment">// distance from start to next node   </span></div><div class="line">        <span class="comment">//...</span></div></pre></td></tr></table></figure><p>对于Tree的情况来说, 这里的dist其实就是当前节点的深度depth.</p><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p><strong>性质1:</strong><br>每个节点node的distance都是node距离起始点start的最短距离.</p><p><strong>性质2:</strong><br>距离start近的节点(depth浅的节点)一定比距离start远的节点早被访问到.</p><p>这是对一个树BFS的时候节点的访问顺序:<br><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7jvepss7j309f06l3yq.jpg" alt=""></p><h3 id="BFS-“by-layer”"><a href="#BFS-“by-layer”" class="headerlink" title="BFS “by layer”"></a>BFS “by layer”</h3><p>参考上面的性质, 可以一次处理”一层”的节点, “一层”的意思是指所有节点距离start的距离相同. 代码在while循环里不是一次poll一个节点, 而是一次把queue的内容处理完, 然后换新的queue进入下一次while循环. 代码重新写一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(GraphNode start)</span></span>&#123;   </div><div class="line">    ArrayList&lt;GraphNode&gt; q = <span class="keyword">new</span> ArrayList&lt;Tree&gt;();   </div><div class="line">    HasheSet&lt;GraphNode&gt; visited = <span class="keyword">new</span> HasheSet&lt;GraphNode&gt;();   </div><div class="line">    q.push(start);   </div><div class="line">    visited.add(start);   </div><div class="line">    <span class="keyword">while</span>(!q.empty())&#123;   </div><div class="line">        ArrayList&lt;GraphNode&gt; newq = <span class="keyword">new</span> ArrayList&lt;Tree&gt;();<span class="comment">// create a new queue   </span></div><div class="line">        <span class="keyword">for</span>(GraphNode cur: q)&#123;<span class="comment">// deal with all nodes in the queue    </span></div><div class="line">            System.out.print(cur.val+<span class="string">", "</span>);<span class="comment">// all nodes in q are of the same distance/depth   </span></div><div class="line">            <span class="keyword">for</span>(GraphNode next: cur.children)    </div><div class="line">                <span class="keyword">if</span>(!visited.contains(next))   </div><div class="line">                    &#123; newq.push(next);visited.add(next); &#125;   </div><div class="line">        &#125;   </div><div class="line">        System.out.println();   </div><div class="line">        q = newq;<span class="comment">//replace q with newq   </span></div><div class="line">    &#125;<span class="comment">//while   </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上程序每次打印一行, 第i行包括了距start距离为i的所有节点. </p><p>由于这样的话每次不必在队首poll出元素(而是依次处理所有queue的元素), 所以可以改用ArrayList. 此时while循环里的不变量是: 所有q里面的节点距离start的距离都相同.</p><h3 id="complexity"><a href="#complexity" class="headerlink" title="complexity"></a>complexity</h3><p>假设一个图有N个节点和M条边, BFS会走遍所有节点, 时间是O(N), 然后由于每个节点会检查所有的出边, 最终所有的边都会被检查过, 时间是O(M), 所以BFS的时间复杂度是<strong>O(N+M)</strong>.</p><p>队列里面最多可能存放所有节点, 空间复杂度为<strong>O(N)</strong>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BFS-intro&quot;&gt;&lt;a href=&quot;#BFS-intro&quot; class=&quot;headerlink&quot; title=&quot;BFS intro&quot;&gt;&lt;/a&gt;BFS intro&lt;/h2&gt;&lt;p&gt;广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”
      
    
    </summary>
    
      <category term="算法" scheme="http://chen-tao.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://chen-tao.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="http://chen-tao.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>日语授受关系总结</title>
    <link href="http://chen-tao.github.io/2017/01/18/japanese-shou-shou-rela/"/>
    <id>http://chen-tao.github.io/2017/01/18/japanese-shou-shou-rela/</id>
    <published>2017-01-17T16:00:00.000Z</published>
    <updated>2017-09-14T03:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./授受关系.png" alt="授受关系"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;./授受关系.png&quot; alt=&quot;授受关系&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="日语" scheme="http://chen-tao.github.io/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>云计算那点事</title>
    <link href="http://chen-tao.github.io/2017/01/12/cloud-things/"/>
    <id>http://chen-tao.github.io/2017/01/12/cloud-things/</id>
    <published>2017-01-11T16:00:00.000Z</published>
    <updated>2017-09-14T03:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<h6 id="FROM-知乎专栏"><a href="#FROM-知乎专栏" class="headerlink" title="FROM 知乎专栏"></a>FROM <a href="https://zhuanlan.zhihu.com/p/22445510?refer=mintshow" target="_blank" rel="external">知乎专栏</a></h6><blockquote><p>来自知乎专栏的一篇文章，信息量真的很大，也有不少很风趣的逸事。</p><p>其实我也浅短的接触过一些云计算：13年金山云起步，有幸参与其中，那时候和斌神被老盘带进公司，他搞SDK(就是直接拿S3的转换)，我在另一侧搞运维和Hadoop生态相关的东西，每周一都会在上地桥东见到雷老板来开会，虎虎生风的，那时候也是小米上升期，真的是恍若隔世。</p><p>如文中所述，金山云确实当时很依赖小米，刚总可能觉得这样的状态他不喜欢，然而雷老板似乎又没给他多大的活动空间(参照下傅盛)，于是，约莫一年刚总出走，金山云又被迅雷吞吃，这一段历史，也算基本告一段落。</p></blockquote><h2 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a><strong>（一）</strong></h2><ol><li>高升科技（000971）的老大于平十年前跟我是同行，在东北做声讯电话业务。后来有人欠他钱，就抄家伙喊帮手去要钱，借钱的没办法说你把我砍了也没钱，我有个机房，要不抵给你吧。老于想想也没办法只好接管了机房，拿下来后就找关系卖IDC，卖着卖着发现，100万的欠款换来的机房，竟然卖了130万，敢情这东西有利润啊。 于是下血本进入IDC市场，9年后公司上市，市值100多亿。 有些做地产的主动找老于要给地，说这地租出去租不了几个钱，还不如给你拿去盖机房赚的更多。</li><li>Openstack是个坑，谁用谁知道，国内一些订制openstack的企业能搞出一些私有云的项目，然而其实做起来都是苦不堪言。想想也是的，rackspace和NASA能搞出什么东西呢？ 主流云计算服务商都不用openstack， 小米运维那边的几个好友也说试了openstack感觉不行。</li><li>360在openstack出来之前内部搞过一套类似的东西，有点作用，后来openstack出来之后就全面拥抱openstack，这下好了完美入坑，360云事业部后来裁掉了，不过老周倒也直爽，尽管自己的兴趣点都在智能硬件和花椒直播上，但也给云那边烧过几个亿，后来拆VIE业绩有些压力就动手砍掉了，360云当时的老大是惠普过来的，业务能力超强，以前把惠普走下坡路的服务器业务从上一年的8个亿做到20多个亿，这人脾气很好，老周说分手就同意分手了，后来跳槽去了乐视云。</li><li>黄允松在IBM就负责云，从18摸出来后，有点担心老东家找麻烦，于是自学python，换了门语言吭哧吭哧写出了青云， 这下你没法告我了吧，你吹得我涨不？ 不过Qingcloud的发展也挺坎坷，一度认为互联网公司会成为云计算的忠实客户，后来发现客户都在深圳，那些金融大土豪才是最喜欢给云计算付费的。于是黄云松搬去深圳住了大半年，把业务撑起来了。</li><li>13年的时候研究过SDN，那时候SDN太火了，饭桌上不提两下openflow都没法在圈子里混了。只有钱伯斯敢站出来说openflow是个垃圾， 于是很自然地，钱伯斯被骂成猪头，大家觉得他廉颇老矣。 后来事实证明钱伯斯是正确的，技术细节就不多说了，说一个小问题：某银行某年采购了15亿的网络设备，第二年有人提议说咱们上SDN，用openflow，然后发现老设备不兼容全部处理掉把，上SDN差不多需要再投入18亿……   后面的结果可想而知。</li><li>UCloud刚成立的时候，冲着季昕华那名头很多投资人都追上去想投资，一问融资金额就犹豫了，再细问一下发现云计算挺烧钱，烧服务器烧带宽，在IDC上的投入简直堪比炒房，那时候阿里云还备受质疑，云计算市场很不明朗， 于是各种认怂了说季总威武霸气，小的我看不懂不敢投祝你幸福之类。 后来DCM和君联杀进后越做越好， 投资人聊到云计算就提自己当年如何看过以及如何错过Ucloud，说得都是绘声绘色栩栩如生。</li><li>CDN市场以前是网宿蓝汛90%，帝联7%，剩下的包括BAT在内抢3%，可惜蓝汛在美国上市，市值惨不忍睹。蓝汛催钱也挺辛苦，经常要拉横幅鼓励员工开催款动员大会。 后来霍涛景楠等人离开蓝汛，出去搞了个白山云，蓝汛昔日的地位不复存在了。</li><li><strong>金山云靠小米渠道去圈游戏客户是真的，你用金山云小米就帮你推，为此还从其他云平台撬过几个耳熟能详的大客户。 雷军玩生态是下血本的，不像某些企业内部要资源还难如上青天。</strong></li><li><strong>阿里云每年双十一的时候全国各地都是通宵值守的，尽管这样也扛不住，各种问题层出不穷， 后来甚至把事务逻辑都拿掉了，于是就造成了超卖，超卖得赔钱啊，每年为超卖要补很多钱。</strong></li><li>再说个阿里云的，阿里云处理的一些问题确实是世界级的，前所未有的，包括被黑客攻击也1是，光DDOS的量级就屡屡破世界纪录。几年前没怎么上SSD的时候和阿里云和AWS一样存在I/O问题，后来好了很多。</li><li>七牛是做网盘起家的，网盘实在不赚钱于是做企业存储把收入做起来了，再到混合云。2014年在GiTC上碰到许式伟，旁边人问他最多的就是七牛和又拍有啥区别，他说了十几遍又拍做CDN，七牛做存储。后来七牛不仅CDN做得风生水起，还基于CDN做直播云。 不过说起直播，很多直播平台的量都是刷的，CDN厂商没怎么赚到钱。</li><li><strong>2013年QCon见到季昕华，问他怎么做安全的，怎么抗DDOS，他说他不抗D，业内黑客基本都认识他，如果要打的话会知会一声， 他会跟客户说有人要打你，建议你去阿里云……  后来UCloud真被打了，我们就在说时代变了，新人黑客都不认识老季了。</strong></li><li>青云的服务是1000倍赔付的，有次广州机房被雷劈了， 我也是受害者，那次被劈据说赔了1000多万。网宿有一次被打也连带七牛服务挂掉，损失未知，后来七牛就不把鸡蛋放在一个笼子里了。</li></ol><p><strong>今日推荐： fit2cloud</strong></p><p>我第一次见到fit2cloud这个产品的时候，就觉得一个技术负责人最需要的就是这个产品。</p><p>试想一下技术实现最头疼的不是把需求给做出来，而是你代码写好后发现你有一刀子东西要去部署，你要面对大量的工具，多种基础设施平台，你缺乏一个好的管理工具。</p><ul><li>「FIT2CLOUD 混合云管理平台」帮助企业统一管理异构和异地基础设施，包括物理机(AIX)、虚拟化平台（vSphere，FusionSphere等）、私有云 （Openstack等）和公有云（亚马逊AWS、阿里云等），以服务目录形式对外统一交付IT资源，实现自服务IT。</li><li>「FIT2CLOUD DevOps协作平台」帮助企业在混合云环境下落地亚马逊AWS DevOps解决方案，实现对应用全生命周期的自动化管理，打通从代码到服务的转化通道，实现云应用的持续部署、交付和自动化运维。</li><li>「FIT2CLOUD 云费用管理平台」帮助企业管控云成本，实现对云费用和资源使用情况的可视化分析，优化和预测。 </li></ul><p>作为一个CMP云平台管理产品，Fit2Cloud目前支持主流公有云（阿里云、AWS、腾讯、青云、UCLOUD等）使用Fit2Cloud，你就不需要再繁琐地分别维护各个基础设施，管理多个独立的系统，对成长期的企业来说大大减少了投入，对技术人员来说也解决了一个刚需——懒。</p><p>Fit2Cloud的团队成员普遍是具有多年经验的Devops，公司拥有10多位AWS认证架构师，其中有两位为专业级认证架构师。同时，公司也是AWS中国区域的“高级技术平台合作伙伴”。</p><h2 id="（二）"><a href="#（二）" class="headerlink" title="（二）"></a><strong>（二）</strong></h2><ol><li><strong>政企云跟ISV类似，区域性很强，东北就是东软，东软到了山东就不好使了，山东是浪潮，北京则是中软和软通。 再到了地级市都有更细分的运营公司，比如山东有个地方叫日照市，那里有家快上市的公司叫展望科技，垄断了日照市政企云业务，展望的董事长在我办公室里用浓重的山普说：只要一天有展望在，日照政企就只认展望。</strong></li><li>两年前我刚创业时参加itech在西湖的一个高尔夫活动，当时见识了著名的华三“铁娘子”——吴敬传女士。 这位前华三CEO在过去10年间做到了百亿的年销售额，把思科打出了中国。除此之外，她还是个高尔夫80杆上下的高手。 华三那时候也是国内率先进军SDN和NFV的企业，势不可挡。 只不过没想到2015年初一场政变， 母公司惠普的CEO（也是一位女性）在她休假的时候解除了她的职务， 当时还有大量人员出走。 后来华三和惠普中国一起成为新华三，被紫光收购，成了一家校办企业的子公司。 惠普中国也怪好玩的，一帮满嘴洋文的港台东南亚高管现在成了校企人士了，那画面不敢直视。  政变期出走的一批老兵出来跟阿里合作做了数梦工厂，专做私有云， 吴敬传卸下兵权后休息了一年半，最后出任数梦工厂的CEO，政变结束。</li><li>安全圈几家竞争公司很容易大打出手，但码头工人组织（docker圈）还是很团结的，有时会聚聚一起合个影啥的，毕竟市场还在成长阶段，谈竞争还早。 Daocloud的喻勇自称为胖子，但是论吨位还是灵雀云的左钥更胜一筹。</li><li>云计算好赚钱吗？我找些参照物吧，citrix是卖虚拟桌面的，单子都是几千万的，销售提成据说有10%…… VMware比citrix公司更有名更大，也是出了名的简单粗暴而暴利。 国外卖VPS的比卖独立服务器的更富得流油。 国内各种复杂原因很不好说， 我记得盛大云一个哥们跟我说：<strong>看ROI无非就是看我怎么虚，给得起钱我自然有更好的性能，一个核虚20个核和一个核虚5个核是不一样的。 厉哥你要追求性能的话，我大不了两个核给你虚成一个核……</strong></li><li>云计算公司加班都很辛苦， 尽管在上海，Daocloud 也要996赶产品。 Qingcloud有这么一句话，在非工作日如果你不在工作的话，你得没有愧疚感才行。所以来炜在小米996的环境下竟然可以折腾出Openfalcon这样的开源产品，让我对他不由地肃然起敬。 <strong>来炜在北京的活动半径不超过西二旗，从百度到小米级别一直不高，后来能成为滴滴五大技术台柱之一完全非人般的努力下的结果。</strong></li><li>季昕华在圈内的评价极高，但他的普通话有一种浓浓的非洲土语的感觉，需要配同声翻译，所幸圈子里的朋友们都比较有耐心，积极主动地跟他交流，在朋友们的支持和他自己的努力下，如今交流越来越顺畅了。这里希望蔡文胜也能早日战胜口音障碍。</li><li>互联网就算大公司很多时候也很苦逼，技术这边压榨硬件性能很常见， 很好，单节点并发再多一点，对，单节点吞吐再高一点。 土豪金融公司就不一样了，那个采购清单华丽啊，有的技术人员做了十几年技术，给客户实施的时候望着那些装备都会流口水。 青藤云安全最大的客户是借贷宝，有6000多个节点。</li><li>极光推送用户超10亿了，最早是做IM的，后来发现没法跟微信竞争就把技术开放出来做长连接，立马to B，单台服务器可以支持400万长连接。极光的创始人是开宾利的，找IDG融资的那一轮自己也投了融资金额的20%。 </li><li>Leancloud原来叫AVOS，创始人里有youtube的创始人陈士骏，明星团队，也得到了李开复的大力推荐。但是那个时候PaaS的概念真心不好讲，江宏博士后来完全独立出来成了Leancloud，SDK做的非常好，用起来很舒服，但叫好不叫座。他们的存储、推送等都是自己做的，这一点也被我吐槽过还因此差点结下了梁子。</li><li><strong>云计算的销售往往都是原来卖IDC的，套用一个蓝汛妹子的话：反正都是出来卖的，卖什么不是卖？ 但是市场一般都是互联网公司背景的。如果你在活动上看到美团云的展台上有美女，不要以为那是他们请来的showgirl，那是他们员工。美团云试用下来感觉还可以，价格不错， 有个做用大数据算命的朋友用了不少美团云的服务，反馈说真心不错。 京东云也有一些特色，不要小看二线云产品，外部用户数量都不少，说明这个大市场还远未成熟。</strong></li><li>秋野是运维界郭德纲，名震天下。从世纪佳缘出来的时候，看到刘惠璞去了聚美，于是就去了乐蜂，一度把乐蜂的技术全部接管了下来，可惜乐蜂这个庙越来越破留不住神仙，后来去了民生电商，也不只限于运维了，管一大片技术业务。 但凡技术大会上只要有秋野出现，必然是全场爆满，我有几次想进去瞅两眼结果都挤不进去。 类似的情况我只见过陈浩（左耳朵耗子，前阿里云的）有过。 运维界撒贝宁是匡萃彪，51到安居客到途牛再到自己创业，以往人们不太意识到运维人员的存在，现在娱乐化了之后这个圈子有活力多了，是好事。</li><li>试用了sumo logic，折腾两天未果，然后果断弃，后来sumo logic就反复给我电话，我到了国内也不被放过，一直无力吐槽。直到有一天红杉的人跟我说他们投了sumo logic，有一种如释重负的感觉，就像捂着肚子转了三圈终于找到一个厕所一样，当天吐槽到红杉的人脸色跟吃了大便一样难看。 不知道现在产品如何，但是当时的我很难想象怎么会有一家公司的产品部署体验如此反人类的，仿佛就是为增加你部署难度而生的。</li><li>戴尔曾经以call center黄埔军校著称，时代不一样了，日子也越来越不好过。上次去崇明岛戴尔大会上听一位金博士用纯正的台湾腔讲硬件，说硬件也就这样了都是上面的软件贵，一台8000美金的服务器，你们猜上面的Oracle多少钱？ 台下有人说有8000吗？ 金博士： 8000？ 一个核就要8000，怎么也得要近5万美金。  台下顿时鸦雀无声，大家垂头丧气地，感觉自己都入错行了。</li><li>云公司的CEO一般以业务能力为先，七牛是个特例，七牛已经快上市了但许式伟还在写代码。《docker源代码分析》的作者，Daocloud初创成员孙宏亮单身，有相亲节目看中了他，三顾茅庐请他上节目，人都没见到就被该厂市场老大霍太太按住了，霍太太的老公不是霍元甲的后代，是瑞典人，姓Hall。</li></ol>]]></content>
    
    <summary type="html">
    
      来自知乎专栏的一篇文章，信息量很大，也有不少很风趣的逸事。很多甚至是我见过错过的人生。
    
    </summary>
    
    
      <category term="感悟" scheme="http://chen-tao.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="云计算" scheme="http://chen-tao.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
</feed>
