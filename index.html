<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Engineer Blogger Creator Runner | ML DM JVM Web | 旅行 电影 歌手 摄影 | 读书的要义是尽量求得客观的认识，不是为了炫耀自己的‘创造力’，或‘发前人所未发’。 优秀程序员的价值，不在于其所掌握的几招屠龙之术，而是在细节中见真著。 如果我们可以一次把事情做对做好，在允许的范围内尽可能追求卓越，为什么不去做呢。 | @HNU">
<meta property="og:type" content="website">
<meta property="og:title" content="Chen-Tao">
<meta property="og:url" content="http://chen-tao.github.io/index.html">
<meta property="og:site_name" content="Chen-Tao">
<meta property="og:description" content="Engineer Blogger Creator Runner | ML DM JVM Web | 旅行 电影 歌手 摄影 | 读书的要义是尽量求得客观的认识，不是为了炫耀自己的‘创造力’，或‘发前人所未发’。 优秀程序员的价值，不在于其所掌握的几招屠龙之术，而是在细节中见真著。 如果我们可以一次把事情做对做好，在允许的范围内尽可能追求卓越，为什么不去做呢。 | @HNU">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chen-Tao">
<meta name="twitter:description" content="Engineer Blogger Creator Runner | ML DM JVM Web | 旅行 电影 歌手 摄影 | 读书的要义是尽量求得客观的认识，不是为了炫耀自己的‘创造力’，或‘发前人所未发’。 优秀程序员的价值，不在于其所掌握的几招屠龙之术，而是在细节中见真著。 如果我们可以一次把事情做对做好，在允许的范围内尽可能追求卓越，为什么不去做呢。 | @HNU">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chen-tao.github.io/"/>





  <title> Chen-Tao </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chen-Tao</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">颂其诗，读其书，不知其人，可乎？</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2017/02/08/algo-pic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/08/algo-pic/" itemprop="url">
                  Algorithm Anaysis
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-08T00:00:00+08:00">
                2017-02-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://ww1.sinaimg.cn/large/006tKfTcgy1fcivc207a8j319z0pwq8b.jpg" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2017/02/01/soa-and-micro-service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/01/soa-and-micro-service/" itemprop="url">
                  SOA面向服务架构浅析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-01T00:00:00+08:00">
                2017-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/感悟/" itemprop="url" rel="index">
                    <span itemprop="name">感悟</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          SOA面向服务架构的一点自我分析，同时对比一下SOA与微服务，互相借鉴，有的放失。
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/01/soa-and-micro-service/">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2017/01/28/quick-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/28/quick-sort/" itemprop="url">
                  quick sort快速排序算法总结 
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-28T00:00:00+08:00">
                2017-01-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天总结一下非常有用的快速排序(qsort)算法, 以及由此衍生的一些其他相关算法(Knuth shuffle, quick select, 3-way partition).</p>
<p>快速排序的算法可以用三句话描述:<br><strong>[Algo]</strong></p>
<blockquote>
<ul>
<li>选择基准项(pivot element, 一般取第一个元素为pivot)</li>
<li>把数组里所有小于pivot的移动到pivot左边, 大于pivot的移动到右边 ⇒ 此时pivot已经位于最终排序时的正确位置</li>
<li>对pivot左右两个数组分别递归进行快速排序</li>
</ul>
</blockquote>
<p>由以上描述可见, qsort是一个递归算法, 我们可以把它的函数声明写成: <code>void qsort(int[] a, int lo, int hi)</code>, 表示排序a[lo, hi]之间(闭区间)的所有元素.</p>
<h2 id="quick-partition"><a href="#quick-partition" class="headerlink" title="quick partition"></a>quick partition</h2><p>由上面描述可以见, qsort最关键的是第二步: 把数组元素以pivot分为两部分. 这个操作就是quick partition.</p>
<p>函数声明为: <code>int partition(int[] a, int lo, int hi)</code>, 该函数返回pivot(即subarray的第一个元素<code>a[lo]</code>)所在的位置.</p>
<p>如果允许新建一个临时数组的话, 那么这个就不是什么问题, 但是为了节约空间占用, 现在需要直接修改(in-place)使得a[lo] 到, 而且希望可以用尽量少的交换(<code>swap(int[]a, int i, int j)</code>)操作, 就不是很evident了.</p>
<p>这个函数的写法是用两个指针i和j分别从两端向中间走, 如果两个指针指向的元素一个小于pivot一个大于pivot那么就进行交换, 当两个指针碰面的时候结束(最后把pivot和指针元素交换). 请看下面这个萌萌的图(图片来自&lt;&lt;啊哈!算法&gt;&gt;):<br><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7ns2lgb3j30f005p3yp.jpg" alt=""></p>
<p>选取第一个元素(6)为pivot, 然后j向左走直到遇到一个小于pivot(6)的数停止, i向右走直到遇到一个大于pivot的数停止(<em>注意要让j先移动</em>), 此时二者交换:<br><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7nsfvemtj30dm0a83yz.jpg" alt=""></p>
<p>只要重复这个过程, 直到i&gt;=j为止, 此时只要最后把pivot和j(<em>注意是j而不是i</em>)指向的元素交换即可:<br><img src="https://ww2.sinaimg.cn/large/006tNbRwgy1fc7nsr0uuxj30dp0bidga.jpg" alt=""></p>
<p>所以pivot的位置就是j, 函数返回j即可.</p>
<p>java实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;  </div><div class="line">    <span class="keyword">int</span> pivot = a[lo], i=lo, j=hi;  </div><div class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </div><div class="line">        <span class="keyword">for</span>(;j&gt;=lo &amp;&amp; a[j]&gt;=pivot;j--);<span class="comment">// move j to a point where a[j]&lt;pivot  </span></div><div class="line">        <span class="keyword">for</span>(;i&lt;=hi &amp;&amp; a[i]&lt;=pivot;i++);<span class="comment">// move i to a point where a[i]&gt;pivot  </span></div><div class="line">        <span class="keyword">if</span>(i&gt;=j) <span class="keyword">break</span>;<span class="comment">// break if i and j meets  </span></div><div class="line">        swap(a, i++, j--);  </div><div class="line">    &#125;  </div><div class="line">    swap(a, lo, j);<span class="comment">// swap pivot with a[j]  </span></div><div class="line">    <span class="keyword">return</span> j;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有几点要注意的:</p>
<ul>
<li>让j先移动</li>
<li>最后pivot要和j交换而不是和i交换: 因为最后放在最左边的应该是一个小于pivot的数嘛</li>
<li>移动的时候别忘了需要加数组下标的边界检查(<code>i&lt;=hi</code>, <code>j&gt;=lo</code>)</li>
<li>partition()的复杂度是线性的<strong>O(n)</strong></li>
</ul>
<h2 id="Knuth-shuffle"><a href="#Knuth-shuffle" class="headerlink" title="Knuth shuffle"></a>Knuth shuffle</h2><p>qsort之所以快, 是因为每次都能够按照pivot分为大致同样长度的两个子数组(所以每次子问题的规模除以二), 所以复杂度为<strong>O(NlogN)</strong>. 最坏情况下, 如果每次两个子数组中可能有一个长度为0, 那么每次子问题的规模只减少了1, 所以复杂度变成了quadratic <strong>O(N2)</strong>.</p>
<p>为了防止这种最坏情况的出现, 可以在一切开始之前把数组打乱顺序, 所以这一节讨论快速shuffle的算法. 最经典的就是Knuth的shuffle算法了, 算法很简答, 描述为: for(k=1 to n): 每次把第k个元素和前k个元素中的随机一个元素交换.</p>
<p>代码只有两行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;  </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> K=<span class="number">0</span>; K&lt;a.length; K++)  </div><div class="line">        swap(K, Random.nextInt(K+<span class="number">1</span>));  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于算法的正确性, 其实只要证明”元素i在shuffle后最终位于位置i”的概率为1/N即可, 不难证明.</p>
<h2 id="quick-sort"><a href="#quick-sort" class="headerlink" title="quick sort"></a>quick sort</h2><p>好了 有了以上两个辅助函数就可以写qsort函数了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;<span class="comment">//recursive helper function  </span></div><div class="line">    <span class="keyword">if</span>(lo&gt;=hi) <span class="keyword">return</span>;  </div><div class="line">    <span class="keyword">int</span> p = partition(a, lo, hi);  </div><div class="line">    qsort(a, lo, p-<span class="number">1</span>);  </div><div class="line">    qsort(a, hi, p+<span class="number">1</span>);  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;  </div><div class="line">    shuffle(a);  </div><div class="line">    qsort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实qsort的主体就是那个partition函数, 单独把partition列出来是因为它不止可以用在排序, 还可以用来做quick select, 见quick select节.</p>
<h2 id="quick-select"><a href="#quick-select" class="headerlink" title="quick select"></a>quick select</h2><p><em>对于一个没有排序的数组, 如何快速找到它的中值(median)?</em><br>以上这个问题的答案就在<code>partition()</code>函数.</p>
<p>之前说过, <code>partition()</code>函数的返回值表示pivot在排序好的数组中的位置(rank), 这个消息非常有用: 中值只不过是rank等于长度除以2的元素而已.</p>
<p>为了寻找rank等于k的元素, 我们用partition函数可以每次把问题规模缩小: 如果partition()=pk那么右边subarray不用考虑, 如果数组事先shuffle过了的话, 问题规模每次缩小一半.</p>
<p>定义一个函数, 寻找rank等于k的元素, 代码类似于二分查找:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int findKth(int[] a, int k)&#123;  </div><div class="line">    shuffle(a);  </div><div class="line">    int lo=0, hi=a.length-1;  </div><div class="line">    while(lo&lt;hi)&#123;  </div><div class="line">    int p = partition(a, lo, hi);  </div><div class="line">    if(p==k) return a[k];  </div><div class="line">    else if(p&lt;k) lo=p+1;  </div><div class="line">    else hi=p-1;  </div><div class="line">    &#125;  </div><div class="line">    return a[k];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该算法内层循环为O(hi-lo), 每次问题规模减少一半, 所以复杂度为N+N/2+N/4+…+1 = 2N, 复杂度为线性时间!</p>
<h2 id="3-way-qsort"><a href="#3-way-qsort" class="headerlink" title="3-way qsort"></a>3-way qsort</h2><p>qsort之前有个bug: 在数组里很多重复元素的时候, 效率会下降为O(N2). 原因是qsort没有好好处理重复元素的问题.</p>
<p>于是Dijkstra提出了一个<strong>3-way partition</strong>的算法: 把数组分为三部分: 左边<code>[lo, lt)</code>严格小于pivot, 中间<code>[lt, gt]</code>等于pivot, 右边<code>(gt, hi]</code>严格大于pivot.</p>
<p>算法初始化<code>lt=lo, gt=hi, i=lo</code>, 用指针i向右扫描, [i,gt]为未处理到的部分.<br>算法很subtle, invariant是这样的:</p>
<blockquote>
<ul>
<li>a[lo,lt-1] &lt; pivot</li>
<li>a[lt, i-1] = pivot</li>
<li>a[i,gt] = unseen</li>
<li>a[gt+1, hi] &gt; pivot</li>
</ul>
</blockquote>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fc7nt1aur7j309k03gq2v.jpg" alt=""><br>这个图很有助于写代码:<br><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7nta4jkzj308704s0sr.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort3way</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;  </div><div class="line">    <span class="keyword">if</span>(hi&lt;=lo) <span class="keyword">return</span>;  </div><div class="line">    <span class="keyword">int</span> lt=lo, i=lo, gt=hi, pivot=a[lo];  </div><div class="line">    <span class="keyword">while</span> (i&lt;=gt)&#123;<span class="comment">// [i,gt] is unseen elements  </span></div><div class="line">        <span class="keyword">if</span>(a[i]==pivot) <span class="comment">//a[lt,i-1] are elements == pivot  </span></div><div class="line">            i++;  </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;pivot) <span class="comment">// a[gt+1, hi] are elements &gt; pivot  </span></div><div class="line">            swap(a, gt--, i);  </div><div class="line">        <span class="keyword">else</span> <span class="comment">// a[lo, lt-1] are elements &lt; pivot  </span></div><div class="line">            swap(a, lt++, i++);  </div><div class="line">    &#125;  </div><div class="line">    qsort3way(a, lo, lt-<span class="number">1</span>);  </div><div class="line">    qsort3way(a, gt+<span class="number">1</span>, hi);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说它很subtle, 除了因为没有那个图我写不出来以外, 还有就是, 在把i和lt交换时, i可以increment (因为我们知道<code>a[lt]==pivot</code>), 但是i和gt交换时, i<strong>不能</strong>increment: 因为a[gt]不知道多大, 所以i位置要继续检查.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2017/01/27/al-template/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/27/al-template/" itemprop="url">
                  递归，回溯，DFS，BFS的理解和模板
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-27T00:00:00+08:00">
                2017-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>LeetCode 里面很大一部分题目都是属于这个范围，例如Path Sum用的就是递归+DFS，Path Sum2用的是递归+DFS+回溯</p>
<p>这里参考了一些网上写得很不错的文章，总结一下理解与模板</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归：就是出现这种情况的代码： （或者说是用到了栈）</p>
<p>解答树角度：在dfs遍历一棵解答树      </p>
<p>优点：结构简洁</p>
<p>缺点：效率低，可能栈溢出</p>
<p>递归的一般结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span>(符合边界条件)</div><div class="line">    &#123;</div><div class="line">       <span class="comment">///////</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">     <span class="comment">//某种形式的调用</span></div><div class="line">     f();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>回溯：递归的一种，或者说是通过递归这种代码结构来实现回溯这个目的。回溯法可以被认为是一个有过剪枝的DFS过程。</p>
<p>解答树角度：带回溯的dfs遍历一棵解答树</p>
<p>回溯的一般结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> 当前状态)</span></span></div><div class="line">	&#123;</div><div class="line">	      <span class="keyword">if</span>(当前状态为边界状态)</div><div class="line">	      &#123;</div><div class="line">	        记录或输出</div><div class="line">	        <span class="keyword">return</span>;</div><div class="line">	      &#125;</div><div class="line">	      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)		<span class="comment">//横向遍历解答树所有子节点</span></div><div class="line">	     &#123;</div><div class="line">	           <span class="comment">//扩展出一个子状态。</span></div><div class="line">	           修改了全局变量</div><div class="line">	           <span class="keyword">if</span>(子状态满足约束条件)</div><div class="line">	            &#123;</div><div class="line">	              dfs(子状态)</div><div class="line">	           &#125;</div><div class="line">	            恢复全局变量<span class="comment">//回溯部分</span></div><div class="line">	        &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h2 id="BFS-amp-DFS"><a href="#BFS-amp-DFS" class="headerlink" title="BFS&amp;DFS"></a>BFS&amp;DFS</h2><p>常用的搜索方式。</p>
<ol>
<li>枚举。枚举运算量很大，需要预先确定枚举的定义域。</li>
<li>广度优先搜索（BFS ）——通常可以用于计算图的连通性、单源最短路径、计算最小操作次数等。</li>
<li>深度优先搜索（DFS）——经典题：火力中心布局。</li>
</ol>
<p>BFS的占用的是队列的空间</p>
<p>DFS 占用的是栈的空间（因为递归）</p>
<p>BFS和DFS的空间复杂度恰好相反</p>
<p>对链状图，BFS最好（队列中最多只有1个元素），DFS最差（所有节点都在根节点的递归内）</p>
<p>对起点与其他所有点相邻的图，DFS最好（递归深度为1），BFS最差（队列中放满了所有与起点相邻的图）。</p>
<h3 id="BFS模版"><a href="#BFS模版" class="headerlink" title="BFS模版"></a>BFS模版</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">queue</span>&lt;type&gt; q;</div><div class="line">q.push(初始状态);</div><div class="line"><span class="keyword">while</span> (!q.empty())</div><div class="line">&#123;</div><div class="line">  type t = q.front() ;</div><div class="line">  q.pop();</div><div class="line">  遍历 t 的各个Next状态  next</div><div class="line">  &#123; </div><div class="line">    <span class="keyword">if</span> (next is legal)</div><div class="line">      q.push(next); 计数或维护等; </div><div class="line">  &#125; </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是BFS的状态数一多，需要的空间就会较大。因此就需要状态压缩，BUPT OJ上的1180就是一个典型的例子，但是状态压缩以及解压的时候，又会涉及效率，反正1180将80M的状态压缩到40K以后就超时了……</p>
<h3 id="DFS模板"><a href="#DFS模板" class="headerlink" title="DFS模板"></a>DFS模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">DFS（顶点） </div><div class="line">&#123;</div><div class="line">　　处理当前顶点，记录为已访问</div><div class="line">　　遍历与当前顶点相邻的所有未访问顶点</div><div class="line">　　&#123;</div><div class="line">　　　　　　标记更改;</div><div class="line">　　　　　　DFS( 下一子状态);</div><div class="line">　　　　　　恢复更改;</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回溯法：DFS适用于 显式图，但是对于一些隐式关系，我们需要使用回溯法，通过定义或找到各个状态、边界条件、搜索范围、约束条件和最优解结果进行建模求解。</p>
<p>边界条件：达到某状态时，需要检查并确定是继续搜索还是回到上一状态的条件（例如当前已使用时间比当前最优解要长，此时就不需要再进行搜索）</p>
<p>搜索范围：当前从当前状态开始进行搜索的所有下一级状态。 </p>
<p>搜索范围：</p>
<p>另外一定要注意，假如参与递归的参数不是通过传参形式的方式进入递归的话，那么一定要做好数据恢复。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Trace（当前状态） </div><div class="line">&#123;</div><div class="line">    if 当前状态是结束状态</div><div class="line">    &#123;</div><div class="line">         if 是最佳解： 记录。</div><div class="line">         退出</div><div class="line">    &#125;</div><div class="line">    遍历当前状态的各个邻接状态</div><div class="line">    &#123;</div><div class="line">        if 当前状态满足约束条件 且 满足最优性要求 ： Trace（子状态） </div><div class="line">    &#125; </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2017/01/26/about-dfs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/26/about-dfs/" itemprop="url">
                  DFS深度优先搜索算法总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-26T00:00:00+08:00">
                2017-01-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- START doctoc generated TOC please keep comment here to allow auto update -->
<ul>
<li><a href="#recursive-dfs">Recursive DFS</a></li>
<li><a href="#non-recursive-dfs">Non-Recursive DFS</a><ul>
<li><a href="#for-tree-dfs-with-depth">(for Tree) DFS with depth</a></li>
<li><a href="#dfs-for-binary-tree--preorder-traversal">DFS for binary tree–PreOrder traversal</a></li>
</ul>
</li>
<li><a href="#cycle-detection">Cycle Detection</a></li>
<li><a href="#topology-sort">Topology Sort</a></li>
<li><a href="#leetcode-dfs">LeetCode DFS</a><ul>
<li><a href="#subsets">Subsets</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<p>总结复习一下DFS算法。</p>
<p>深度优先算法是N种算法的基础，是算法学习中的重中之重。</p>
<p>可以解决的问题类型也很多：递归，回溯，隐图式搜索，甚至是暴力类型算法的万金油。</p>
<h2 id="DFS-intro"><a href="#DFS-intro" class="headerlink" title="DFS intro"></a>DFS intro</h2><p>图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。</p>
<p>它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p>
<p>显然，深度优先搜索是一个递归的过程。</p>
<h2 id="Understand-DFS"><a href="#Understand-DFS" class="headerlink" title="Understand DFS"></a>Understand DFS</h2><h3 id="无向图-undirected-graph"><a href="#无向图-undirected-graph" class="headerlink" title="无向图(undirected graph)"></a>无向图(undirected graph)</h3><p><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7glkmecsj30bl08fq3b.jpg" alt=""></p>
<p>对于上图的遍历，步骤如下：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwgy1fc7gowbrw3j30c409hmxs.jpg" alt=""></p>
<p><strong>第1步</strong>：访问A。 </p>
<p><strong>第2步</strong>：访问(A的邻接点)C。 </p>
<pre><code>在第1步访问A之后，接下来应该访问的是A的邻接点，即&quot;C,D,F&quot;中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在&quot;D和F&quot;的前面，因此，先访问C。 
</code></pre><p><strong>第3步</strong>：访问(C的邻接点)B。 </p>
<pre><code>在第2步访问C之后，接下来应该访问C的邻接点，即&quot;B和D&quot;中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。 
</code></pre><p><strong>第4步</strong>：访问(C的邻接点)D。 </p>
<pre><code>在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。 
</code></pre><p><strong>第5步</strong>：访问(A的邻接点)F。 </p>
<pre><code>前面已经访问了A，并且访问完了&quot;A的邻接点B的所有邻接点(包括递归的邻接点在内)&quot;；因此，此时返回到访问A的另一个邻接点F。 
</code></pre><p><strong>第6步</strong>：访问(F的邻接点)G。 </p>
<p><strong>第7步</strong>：访问(G的邻接点)E。</p>
<p>因此访问顺序是：<strong>A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E</strong></p>
<h3 id="有向图-directed-graph"><a href="#有向图-directed-graph" class="headerlink" title="有向图(directed graph)"></a>有向图(directed graph)</h3><p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fc7gqb4esdj308f08y74n.jpg" alt=""></p>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwgy1fc7gqggvlfj308f0a0gm7.jpg" alt=""></p>
<p><strong>第1步</strong>：访问A。 </p>
<p><strong>第2步</strong>：访问B。 </p>
<pre><code>在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。 
</code></pre><p><strong>第3步</strong>：访问C。 </p>
<pre><code>在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。 
</code></pre><p><strong>第4步</strong>：访问E。 </p>
<pre><code>接下来访问C的出边的另一个顶点，即顶点E。 
</code></pre><p><strong>第5步</strong>：访问D。 </p>
<pre><code>接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。 
</code></pre><p><strong>第6步</strong>：访问F。 </p>
<pre><code>接下应该回溯&quot;访问A的出边的另一个顶点F&quot;。 
</code></pre><p><strong>第7步</strong>：访问G。</p>
<p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G</strong></p>
<h2 id="DFS-implement"><a href="#DFS-implement" class="headerlink" title="DFS implement"></a>DFS implement</h2><p>由于tree可以看做特殊的graph，这里针对graph来实现</p>
<p>​<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> calss GraphNode&#123;</div><div class="line">  <span class="keyword">int</span> val;</div><div class="line">  List&lt;GraphNode&gt; neighnors;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了防止重复，使用一个HashSet来保存已经遍历过的节点</p>
<p>​<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HashSet&lt;GraphNode&gt; visited = <span class="keyword">new</span> HashSet&lt;GraphNode&gt;();</div></pre></td></tr></table></figure></p>
<h3 id="Recursive-DFS"><a href="#Recursive-DFS" class="headerlink" title="Recursive DFS"></a>Recursive DFS</h3><p>每到一个节点，标记已经被访问过，对邻居里没有访问的节点进行DFS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(GraphNode nd)</span></span>&#123;</div><div class="line">  <span class="comment">//print nd.val</span></div><div class="line">  visited.add(nd);</div><div class="line">  <span class="keyword">for</span>(GraphNode next : nd.neighbours)&#123;</div><div class="line">    <span class="keyword">if</span>(!visited.contains(next))&#123;</div><div class="line">      DFS(next);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经典的DFS，回溯算法(backtracking)其实相当于在一个求解域做DFS(剪枝)，另外，拓扑排序也是基于递归DFS进行的一点修改</p>
<h3 id="Non-Recursive-DFS"><a href="#Non-Recursive-DFS" class="headerlink" title="Non-Recursive DFS"></a>Non-Recursive DFS</h3><p>非递归版本，相比递归版本效率高，且不会导致栈溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(GraphNode start)</span></span>&#123;</div><div class="line">  Stack&lt;GraphNode&gt; s = <span class="keyword">new</span> Stack&lt;GraphNode&gt;();</div><div class="line">  q.push(start);</div><div class="line">  visited.add(start);</div><div class="line">  <span class="keyword">while</span>(!s.empty())&#123;</div><div class="line">    GraphNode cur = s.pop();</div><div class="line">    <span class="comment">//print cur.val</span></div><div class="line">    <span class="keyword">for</span>(GraphNode next : cur.children)&#123;</div><div class="line">      <span class="keyword">if</span>(!visited.contains(next))&#123;</div><div class="line">        s.push(next);</div><div class="line">        visited.add(next);<span class="comment">//mark node as visited when adding to stack.</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="comment">//while end</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="for-Tree-DFS-with-depth"><a href="#for-Tree-DFS-with-depth" class="headerlink" title="(for Tree) DFS with depth"></a>(for Tree) DFS with depth</h3><p>深度在搜索中记录，递归版本加一个depth参数++就可以了，非递归版本用一个和s平行的栈记录深度</p>
<h3 id="DFS-for-binary-tree–PreOrder-traversal"><a href="#DFS-for-binary-tree–PreOrder-traversal" class="headerlink" title="DFS for binary tree–PreOrder traversal"></a>DFS for binary tree–PreOrder traversal</h3><p>DFS对于二叉树而言，其遍历序列就是其前序遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[preorder(node)] = node.val + [preorder(node.left)] + [preorder(node.right)]</div></pre></td></tr></table></figure>
<h2 id="Cycle-Detection"><a href="#Cycle-Detection" class="headerlink" title="Cycle Detection"></a>Cycle Detection</h2><p>对DFS稍作修改，可以判断一个有向图是否有回路</p>
<p>在递归版本里，我们队每一个点改为三种标记：</p>
<ul>
<li>未访问过(0)</li>
<li>正在访问其邻居节点(1)</li>
<li>已经访问完毕该节点以及所有该节点可以到达的节点(2)</li>
</ul>
<p>什么时候会出现回路？<strong>就是当前节点v的一个邻居u的状态为1的时候。</strong></p>
<p>因为该节点状态为1，即还没有把它以后的节点全部遍历，所以当前节点v肯定可以从u到达，而现在又可以从v到达u，所以回路构成。</p>
<p>为了表示一个节点的三种状态, 我们把visited的定义改一下, 定义为一个hashmap:<br><code>HasheMap visited = new HasheMap();</code></p>
<p>节点不在visited表示还未访问过, 节点对应为false表示正在访问, 节点对应为true表示已经访问该节点以及所有可以从它到达的节点.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(GraphNode nd)</span></span>&#123;      </div><div class="line">    visited.put(nd, <span class="keyword">false</span>); <span class="comment">// mark as status-1   </span></div><div class="line">    <span class="keyword">for</span>(GraphNode next: nd.neighbors)&#123;   </div><div class="line">        <span class="keyword">if</span>( !visited.contains(next) )   </div><div class="line">            DFS(next);   </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(visited.get(next)==<span class="keyword">false</span>) <span class="comment">// found cycle   </span></div><div class="line">            System.out.println(<span class="string">"Cycle detected!!!"</span>);   </div><div class="line">    &#125;<span class="comment">// now all touchable nodes from nd are visited   </span></div><div class="line">    visited.put(nd, <span class="keyword">true</span>); <span class="comment">// mark as status-2   </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Topology-Sort"><a href="#Topology-Sort" class="headerlink" title="Topology Sort"></a>Topology Sort</h2><p>这一节(以及上一节)参考这个非常棒的视频: <a href="https://class.coursera.org/algo-003/lecture/52" target="_blank" rel="external">https://class.coursera.org/algo-003/lecture/52</a></p>
<p>拓扑排序是一个dfs的应用, 所谓拓扑排序是指在一个DAG(有向无回路图)里给每个节点定义一个顺序(v1…vn), 使得按照这个顺序遍历的节点, 每一个节点vi都是之前遍历过的的节点(v1 ~ vi-1)所指向的(或没有任何其他节点指向的).</p>
<p>好像还没说清楚… 拓扑排序的一个应用就是对于各种依赖性(比如学习课程A需要先学习过课程B)组成的图寻找一个节点遍历的顺序使其可行.</p>
<p><strong>propositions</strong>:</p>
<blockquote>
<ul>
<li>拓扑排序的结果不唯一.</li>
<li>有回路的图不存在拓扑顺序.</li>
<li>如果一个节点没有出边, 那么它可以放在拓扑排序的最后面(没有节点以来它).</li>
<li>如果一个节点没有入边, 那么它可以放在拓扑排序的最后面.</li>
</ul>
</blockquote>
<p>简单修改一下递归的dfs就可以处理拓扑排序: 维护一个计数器<code>K</code>(初始化为n=所有节点数), 每当一个点已经遍历完毕(所有通过这个点可以到达的点都已经被走过)以后, 就把这个点的顺序设为K, 同时减少K.</p>
<p>就用一个HashMap来为每个节点关联一个序号好了:<br><code>HasheMap order = new HasheMap();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(GraphNode nd)</span></span>&#123;      </div><div class="line">    <span class="keyword">for</span>(GraphNode next: nd.neighbors)&#123;   </div><div class="line">        <span class="keyword">if</span>( !visited.contains(next) )   </div><div class="line">            DFS(next);   </div><div class="line">    &#125;<span class="comment">// all touchable nodes from nd are visited   </span></div><div class="line">    order.put(nd, K--);   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面只是对于一个点进行的, 为了给所有点拓扑排序, 只要从一个没有出边的节点出发进行遍历, 一直运行到所有的节点都已经访问过为止。</p>
<h2 id="LeetCode-DFS"><a href="#LeetCode-DFS" class="headerlink" title="LeetCode DFS"></a>LeetCode DFS</h2><p>LeetCode上很多题目都是使用DFS或其思想进行处理的</p>
<p>DFS的框架可以理解为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//结果集</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> T ans = <span class="keyword">new</span> T();</div><div class="line"><span class="comment">//中间结果集</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> T path = <span class="keyword">new</span> T();</div><div class="line"><span class="comment">//问题</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">problem</span><span class="params">()</span></span>&#123;</div><div class="line">  ans.clear();<span class="comment">//leetcode的一个特殊点，每次要清空结果集，避免重复</span></div><div class="line">  robot(idx ,...);<span class="comment">//DFS部分，常用idx作为结果递归的标志</span></div><div class="line">  <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"><span class="comment">//DFS</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">robot</span><span class="params">(<span class="keyword">int</span> idx, ...)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(xxx)&#123;<span class="comment">//边界条件，递归出口条件</span></div><div class="line">    <span class="comment">//用当前path内容生成一部分结果集</span></div><div class="line">    <span class="comment">//handle path </span></div><div class="line">    ans.add(tmp);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//递归处理</span></div><div class="line">  path[idx] = <span class="keyword">true</span>;<span class="comment">//递归前假设</span></div><div class="line">  robot(++idx, ...);<span class="comment">//根据不同情况进行处理</span></div><div class="line">  path[idx] = <span class="keyword">false</span>;<span class="comment">//递归后还原</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里举例进行分析：</p>
<h3 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h3><p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets.</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
<p>For example,<br>If <strong>nums</strong> = <code>[1,2,3]</code>, a solution is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [3],</div><div class="line">  [1],</div><div class="line">  [2],</div><div class="line">  [1,2,3],</div><div class="line">  [1,3],</div><div class="line">  [2,3],</div><div class="line">  [1,2],</div><div class="line">  []</div><div class="line">]</div></pre></td></tr></table></figure>
<script src="https://gist.github.com/Chen-tao/f97f5628bdf96b2ce8ea3b11822d40c5.js"></script>

<p>原集合每一个数字只有两种状态，要么存在，要么不存在，那么在构造子集时就有选择和不选择两种情况，所以可以构造一棵二叉树，左子树表示选择该层处理的节点，右子树表示不选择，最终的叶节点就是所有子集合，树的结构如下：</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fc7i519tsrj30d6083jru.jpg" alt=""></p>
<p>DFS几乎可以算是图与树种最重要的算法，这里总结不算全面，但基本涵盖，这里最主要是搜索递归的思想。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2017/01/25/about-bfs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/25/about-bfs/" itemprop="url">
                  BFS广度优先搜索算法总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-25T00:00:00+08:00">
                2017-01-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="BFS-intro"><a href="#BFS-intro" class="headerlink" title="BFS intro"></a>BFS intro</h2><p>广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。</p>
<p>它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p>
<p>换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。</p>
<h2 id="Understand-BFS"><a href="#Understand-BFS" class="headerlink" title="Understand BFS"></a>Understand BFS</h2><h3 id="无向图-undirected-graph"><a href="#无向图-undirected-graph" class="headerlink" title="无向图(undirected graph)"></a>无向图(undirected graph)</h3><p><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7jidbnayj30eq0e73zi.jpg" alt=""></p>
<p><strong>第1步</strong>：访问A。 </p>
<p><strong>第2步</strong>：依次访问C,D,F。 </p>
<pre><code>在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在&quot;D和F&quot;的前面，因此，先访问C。再访问完C之后，再依次访问D,F。 
</code></pre><p><strong>第3步</strong>：依次访问B,G。 </p>
<pre><code>在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。 
</code></pre><p><strong>第4步</strong>：访问E。 </p>
<pre><code>在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。
</code></pre><p>因此访问顺序是：<strong>A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E</strong></p>
<h3 id="有向图-directed-graph"><a href="#有向图-directed-graph" class="headerlink" title="有向图(directed graph)"></a>有向图(directed graph)</h3><p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fc7jjkk7w8j30fs0cn75e.jpg" alt=""></p>
<p><strong>第1步</strong>：访问A。 </p>
<p><strong>第2步</strong>：访问B。 </p>
<p><strong>第3步</strong>：依次访问C,E,F。 </p>
<pre><code>在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。 
</code></pre><p><strong>第4步</strong>：依次访问D,G。 </p>
<pre><code>在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。
</code></pre><p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G</strong></p>
<h2 id="BFS-implement"><a href="#BFS-implement" class="headerlink" title="BFS implement"></a>BFS implement</h2><p>对于没有边权重的图来说可以计算最短路径. </p>
<p>由于树的BFS只是图的BFS的一种特殊情况, 而且比较简单不需要visited标记, 这里只写一下图的BFS好了. </p>
<p>先定义一个Graph类, 这里在每一个节点保存邻居信息:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphNode</span></span>&#123;   </div><div class="line">    <span class="keyword">int</span> val;   </div><div class="line">    List&lt;GraphNode&gt; neighbors;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="BFS-for-trees-graphs"><a href="#BFS-for-trees-graphs" class="headerlink" title="BFS for trees/graphs"></a>BFS for trees/graphs</h3><p>图的遍历需要注意不走重复节点, 所以需要一个HashSet(名字叫visited)来保存哪些节点已经访问过了. </p>
<p>需要注意的是, <em>在把一个节点放进队列queue的时刻就要把它放进visited</em>, 而不是在队列里取出来的时刻再放.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(GraphNode start)</span></span>&#123;   </div><div class="line">    LinkedList&lt;GraphNode&gt; q = <span class="keyword">new</span> LinkedList&lt;GraphNode&gt;();   </div><div class="line">    HasheSet&lt;GraphNode&gt; visited = <span class="keyword">new</span> HasheSet&lt;GraphNode&gt;();   </div><div class="line">    q.push(start);   </div><div class="line">    visited.add(start);   </div><div class="line">    <span class="keyword">while</span>(!q.empty())&#123;   </div><div class="line">        GraphNode cur = q.poll();   </div><div class="line">        System.out.println(cur.val);   </div><div class="line">        <span class="keyword">for</span>(GraphNode next: cur.children)&#123;    </div><div class="line">            <span class="keyword">if</span>(!visited.contains(next))&#123;   </div><div class="line">                q.push(next);   </div><div class="line">                visited.add(next); <span class="comment">// mark node as visited when adding to queue!    </span></div><div class="line">            &#125;   </div><div class="line">        &#125;   </div><div class="line">    &#125;<span class="comment">//while   </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="BFS-with-distance"><a href="#BFS-with-distance" class="headerlink" title="BFS with distance"></a>BFS with distance</h3><p>在BFS的同时我们可以记录从start节点到当前node的距离, 方法是把一个距离信息同时入队(封装一个<code>Pair</code>), 或者使用一个与queue<em>平行</em>的队列保存距离信息. </p>
<p>在上面的代码中, 加入:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//...   </span></div><div class="line">LinkedList&lt;Integer&gt; distq = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();   </div><div class="line">distq.push(<span class="number">0</span>);<span class="comment">// distance from start to start   </span></div><div class="line"><span class="comment">//...   </span></div><div class="line"><span class="comment">// in the while(!q.empty()) loop:    </span></div><div class="line">    <span class="keyword">int</span> d = distq.poll();<span class="comment">//get distance from start to current node   </span></div><div class="line">    <span class="keyword">for</span>(GraphNode next: node.children)&#123;   </div><div class="line">        distq.push(d+<span class="number">1</span>);<span class="comment">// distance from start to next node   </span></div><div class="line">        <span class="comment">//...</span></div></pre></td></tr></table></figure>
<p>对于Tree的情况来说, 这里的dist其实就是当前节点的深度depth.</p>
<h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p><strong>性质1:</strong><br>每个节点node的distance都是node距离起始点start的最短距离.</p>
<p><strong>性质2:</strong><br>距离start近的节点(depth浅的节点)一定比距离start远的节点早被访问到.</p>
<p>这是对一个树BFS的时候节点的访问顺序:<br><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fc7jvepss7j309f06l3yq.jpg" alt=""></p>
<h3 id="BFS-“by-layer”"><a href="#BFS-“by-layer”" class="headerlink" title="BFS “by layer”"></a>BFS “by layer”</h3><p>参考上面的性质, 可以一次处理”一层”的节点, “一层”的意思是指所有节点距离start的距离相同. 代码在while循环里不是一次poll一个节点, 而是一次把queue的内容处理完, 然后换新的queue进入下一次while循环. 代码重新写一下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(GraphNode start)</span></span>&#123;   </div><div class="line">    ArrayList&lt;GraphNode&gt; q = <span class="keyword">new</span> ArrayList&lt;Tree&gt;();   </div><div class="line">    HasheSet&lt;GraphNode&gt; visited = <span class="keyword">new</span> HasheSet&lt;GraphNode&gt;();   </div><div class="line">    q.push(start);   </div><div class="line">    visited.add(start);   </div><div class="line">    <span class="keyword">while</span>(!q.empty())&#123;   </div><div class="line">        ArrayList&lt;GraphNode&gt; newq = <span class="keyword">new</span> ArrayList&lt;Tree&gt;();<span class="comment">// create a new queue   </span></div><div class="line">        <span class="keyword">for</span>(GraphNode cur: q)&#123;<span class="comment">// deal with all nodes in the queue    </span></div><div class="line">            System.out.print(cur.val+<span class="string">", "</span>);<span class="comment">// all nodes in q are of the same distance/depth   </span></div><div class="line">            <span class="keyword">for</span>(GraphNode next: cur.children)    </div><div class="line">                <span class="keyword">if</span>(!visited.contains(next))   </div><div class="line">                    &#123; newq.push(next);visited.add(next); &#125;   </div><div class="line">        &#125;   </div><div class="line">        System.out.println();   </div><div class="line">        q = newq;<span class="comment">//replace q with newq   </span></div><div class="line">    &#125;<span class="comment">//while   </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上程序每次打印一行, 第i行包括了距start距离为i的所有节点. </p>
<p>由于这样的话每次不必在队首poll出元素(而是依次处理所有queue的元素), 所以可以改用ArrayList. 此时while循环里的不变量是: 所有q里面的节点距离start的距离都相同.</p>
<h3 id="complexity"><a href="#complexity" class="headerlink" title="complexity"></a>complexity</h3><p>假设一个图有N个节点和M条边, BFS会走遍所有节点, 时间是O(N), 然后由于每个节点会检查所有的出边, 最终所有的边都会被检查过, 时间是O(M), 所以BFS的时间复杂度是<strong>O(N+M)</strong>.</p>
<p>队列里面最多可能存放所有节点, 空间复杂度为<strong>O(N)</strong>.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2017/01/18/japanese-shou-shou-rela/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/18/japanese-shou-shou-rela/" itemprop="url">
                  日语授受关系总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-18T00:00:00+08:00">
                2017-01-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="./授受关系.png" alt="授受关系"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2017/01/12/cloud-things/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/12/cloud-things/" itemprop="url">
                  云计算那点事
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-12T00:00:00+08:00">
                2017-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          来自知乎专栏的一篇文章，信息量很大，也有不少很风趣的逸事。很多甚至是我见过错过的人生。
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/12/cloud-things/">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2017/01/10/jvm-param-rcmd-2016/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/10/jvm-param-rcmd-2016/" itemprop="url">
                  关键业务系统jvm参数推荐
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-10T00:00:00+08:00">
                2017-01-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jvm/" itemprop="url" rel="index">
                    <span itemprop="name">jvm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言1，资料"><a href="#前言1，资料" class="headerlink" title="前言1，资料"></a>前言1，资料</h3><p>学习开源项目的启动脚本是个不错的主意，比如<a href="http://github.com/apache/cassandra/blob/trunk/conf/jvm.options" target="_blank" rel="external">Cassandra家的</a>， 附送一篇<a href="http://tobert.github.io/pages/als-cassandra-21-tuning-guide.html" target="_blank" rel="external">解释它的文章</a>。</p>
<p><a href="http://hllvm.group.iteye.com/group/topic/27945" target="_blank" rel="external">JVM调优的”标准参数”的各种陷阱</a> R大的文章，在JDK6时写的，期待更新。</p>
<p>偶然翻到Linkedin工程师的<a href="http://www.importnew.com/11336.html" target="_blank" rel="external">一篇文章</a>。</p>
<p>更偶然翻到的<a href="http://www.techpaste.com/2012/02/java-command-line-options-jvm-performance-improvement/" target="_blank" rel="external">一份不错的参数列表</a>。</p>
<p>并发编程网上的<a href="http://ifeve.com/useful-jvm-flags/" target="_blank" rel="external">JVM实用参数系列</a></p>
<h3 id="前言2，-XX-PrintFlagsFinal打印参数值"><a href="#前言2，-XX-PrintFlagsFinal打印参数值" class="headerlink" title="前言2， -XX:+PrintFlagsFinal打印参数值"></a>前言2， -XX:+PrintFlagsFinal打印参数值</h3><p>当你在网上兴冲冲找到一个可优化的参数时，先用-XX: +PrintFlagsFinal看看，它可能已经默认打开了，再找到一个，还是默认打开了…</p>
<p>JDK7与JDK8，甚至JDK7中的不同版本，有些参数值都不一样，所以不要轻信网上任何文章，一切以生产环境同版本的JDK打出来的为准。</p>
<p>经常以类似下面的语句去查看参数，偷懒不起应用，用-version代替。有些参数设置后会影响其他参数，所以查看时也把它带上。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;  java -server -Xmx1024m -Xms1024m -XX:+UseConcMarkSweepGC -XX:+PrintFlagsFinal -version| grep ParallelGCThread</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p> <img src="https://ww4.sinaimg.cn/large/006tNc79gw1fblkzb6tzoj30z2080tao.jpg" alt=""></p>
<h3 id="前言3，关于默认值"><a href="#前言3，关于默认值" class="headerlink" title="前言3，关于默认值"></a>前言3，关于默认值</h3><p>JDK8会默认打开-XX:+TieredCompilation多层编译，而JDK7则不会。JDK7u40以后的版本会默认打开-XX:+OptimizeStringConcat优化字符串拼接，而之前的则不打开。</p>
<p>对于这些参数，我的建议是<strong>顺势而为，JDK在那个版本默认打开不打开总有它的理由。安全第一，没有很好的因由，不要随便因为网上某篇文章的推荐(包括你现在在读的这篇)就去设置。</strong></p>
<h3 id="1-性能篇"><a href="#1-性能篇" class="headerlink" title="1. 性能篇"></a>1. 性能篇</h3><p>先写一些不那么常见的，后面再来老生常谈。</p>
<h4 id="1-1-取消偏向锁-XX-UseBiasedLocking"><a href="#1-1-取消偏向锁-XX-UseBiasedLocking" class="headerlink" title="1.1 取消偏向锁 -XX:-UseBiasedLocking"></a>1.1 取消偏向锁 -XX:-UseBiasedLocking</h4><p>JDK1.6开始默认打开的偏向锁，会尝试把锁赋给第一个访问它的线程，取消同步块上的synchronized原语。如果始终只有一条线程在访问它，就成功略过同步操作以获得性能提升。</p>
<p>但一旦有第二条线程访问这把锁，JVM就要撤销偏向锁恢复到未锁定线程的状态，详见 <a href="http://calvin1978.blogcn.com/articles/safepoint.html" target="_blank" rel="external">JVM的Stop The World，安全点，黑暗的地底世界</a>， 可以看到不少RevokeBiasd的纪录，像GC一样，会Stop The World的干活，虽然只是很短很短的停顿，但对于多线程并发的应用，取消掉它反而有性能的提升和延时的极微的缩短，所以Cassandra就取消了它。</p>
<h4 id="1-2-提高数字缓存-XX-AutoBoxCacheMax-20000"><a href="#1-2-提高数字缓存-XX-AutoBoxCacheMax-20000" class="headerlink" title="1.2 提高数字缓存 -XX:AutoBoxCacheMax=20000"></a>1.2 提高数字缓存 -XX:AutoBoxCacheMax=20000</h4><p><code>Integer i = 3;</code>这语句有着 int自动装箱成Integer的过程，JDK默认只缓存 -128 ~ +127的int 和 long，超出范围的数字就要即时构建新的Integer对象。设为20000后，我们应用的QPS从48,000提升到50,000，足足4%的影响。详见<a href="http://blog.csdn.net/chengzhezhijian/article/details/9628251" target="_blank" rel="external">Java Integer(-128~127)值的==和equals比较产生的思考</a></p>
<h4 id="1-3-启动时访问并置零内存页面-XX-AlwaysPreTouch"><a href="#1-3-启动时访问并置零内存页面-XX-AlwaysPreTouch" class="headerlink" title="1.3 启动时访问并置零内存页面-XX:+AlwaysPreTouch"></a>1.3 启动时访问并置零内存页面-XX:+AlwaysPreTouch</h4><p>启动时就把参数里说好了的内存全部touch一遍，可能启动时慢上一点，但后面访问时会更流畅，比如页面会连续分配，比如不会在晋升新生代到老生代时才去访问页面使得GC停顿时间加长。不过这选项对大堆才会更有感觉一点。</p>
<h4 id="1-4-禁止JVM写statistics数据-XX-PerfDisableSharedMem"><a href="#1-4-禁止JVM写statistics数据-XX-PerfDisableSharedMem" class="headerlink" title="1.4 禁止JVM写statistics数据 -XX:+PerfDisableSharedMem"></a>1.4 禁止JVM写statistics数据 -XX:+PerfDisableSharedMem</h4><p>Cassandra家的一个参数，一直没留意，直到发生高IO时的JVM停顿。原来JVM经常会默默的在/tmp/hperf 目录写上一点statistics数据，如果刚好遇到PageCache刷盘，把文件阻塞了，就不能结束这个Stop the World的安全点了。用此参数可以禁止JVM写statistics数据，代价是jps, jstat 用不了，只能用JMX取数据。有时用JMX取新生代老生代使用百分比还真没jstat方便。详见<a href="http://www.evanjones.ca/jvm-mmap-pause.html" target="_blank" rel="external">The Four Month Bug: JVM statistics cause garbage collection pauses</a></p>
<h4 id="1-5-Djava-security-egd-file-dev-urandom"><a href="#1-5-Djava-security-egd-file-dev-urandom" class="headerlink" title="1.5 -Djava.security.egd=file:/dev/./urandom"></a>1.5 -Djava.security.egd=file:/dev/./urandom</h4><p>此江湖偏方原用于Tomcat显式使用SHA1PRNG算法时，初始因子从/dev/random读取导致堵塞。而使用此设置后，额外效果是默认的SecureRandom算法也变成SHA1了。 SHA1PRNG 比 NativePRNG消耗小一半，synchronized的代码少一半，所以没特殊安全要求的话建议用SHA1。详见 <a href="http://calvin1978.blogcn.com/articles/securerandom.html" target="_blank" rel="external">SecureRandom的江湖偏方与真实效果</a></p>
<h4 id="1-6-不建议的参数"><a href="#1-6-不建议的参数" class="headerlink" title="1.6 不建议的参数"></a>1.6 不建议的参数</h4><ol>
<li><strong>-XX:+AggressiveOpts</strong>是一些还没默认打开的优化参数集合, -XX:AutoBoxCacheMax是其中的一项。但如前所述，关键系统里不建议打开。虽然通过-XX:+AggressiveOpts 与 -XX:-AggressiveOpts 的对比，目前才改变了三个参数，但为免以后某个版本的JDK里默默改变更多激进的配置，还是不要了。</li>
</ol>
<ol>
<li>Linkined那种黑科技，先要解锁VMOptions才能配置的就更不用说了，比如</li>
</ol>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; -XX:+UnlockDiagnosticVMOptions -XX: ParGCCardsPerStrideChunk=32768</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<ol>
<li>JIT Compile相关的参数，函数调用多少次之后开始编译的阀值，内联函数大小的阀值等等，没有经过严格的性能测试，尽量不去改动这里，JIT和javac的编译环节是官方经过长期实验才确定下来的。</li>
<li><strong>-XX:+UseFastAccessorMethods</strong>，JDK6的优化，据说在多层编译下还慢了，所以是默认关闭的。</li>
<li><strong>-server</strong>，在64位linux中，你想设成-client都不行的，所以写了也是白写。</li>
</ol>
<h4 id="1-7-可选参数"><a href="#1-7-可选参数" class="headerlink" title="1.7 可选参数"></a>1.7 可选参数</h4><ol>
<li><strong>-Djava.awt.headless=true</strong>，如果服务器上没有屏幕，键盘，鼠标，又需要用到它们的时候，详见<a href="http://www.oschina.net/translate/using-headless-mode-in-java-se" target="_blank" rel="external">在 Java SE 平台上使用 Headless 模式</a></li>
<li><strong>-XX:-UseCounterDecay</strong>，禁止JIT调用计数器衰减。默认情况下，每次GC时会对调用计数器进行砍半的操作，导致有些方法一直是个温热，可能永远都达不到C2编译的1万次的阀值。</li>
<li><strong>-XX:-TieredCompilation</strong>，禁止JDK8默认的多层编译，在某些情况下因为有些方法C1编译后C2不再编译，多层编译反而比C2编译慢，如果发现此情况可进行禁止。</li>
</ol>
<h3 id="2-GC篇"><a href="#2-GC篇" class="headerlink" title="2. GC篇"></a>2. GC篇</h3><h4 id="2-1-GC策略"><a href="#2-1-GC策略" class="headerlink" title="2.1 GC策略"></a>2.1 GC策略</h4><p>为了稳健，还是8G以下的堆还是CMS好了，G1的细节实现起来难度太大，从理论提出到现在都做了六七年了。</p>
<p>CMS真正可设的东西也不多，详见<a href="http://ifeve.com/useful-jvm-flags-part-7-cms-collector/" target="_blank" rel="external">JVM实用参数（七）CMS收集器</a></p>
<p> 1.基本配置</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;  -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>因为我们的监控系统会通过JMX监控内存达到90%的状况（留点处理的时间），所以设置让它75%就开始跑了，早点开始也能避免Full GC等意外情况(概念重申，这种主动的CMS GC，和JVM的老生代、永久代、堆外内存完全不能分配内存了而强制Full GC是不同的概念)。为了让这个设置生效，还要设置-XX:+UseCMSInitiatingOccupancyOnly，否则75只被用来做开始的参考值，后面还是JVM自己算。</p>
<ol>
<li><strong>-XX:MaxTenuringThreshold=2</strong>，这是GC里改动效果最明显的一个参数了。对象在Survivor区熬过多少次Young GC后晋升到年老代，JDK7里看起来默认是6，跑起来好像变成了15。</li>
</ol>
<p>Young GC是最大的应用停顿来源，而新生代里GC后存活对象的多少又直接影响停顿的时间，所以如果清楚Young GC的执行频率和应用里大部分临时对象的最长生命周期，可以把它设的更短一点，让其实不是临时对象的新生代长期对象赶紧晋升到年老代，别呆着。</p>
<p>用-XX:+PrintTenuringDistribution观察下，如果后面几代都差不多，就可以设小，比如JMeter里是2。</p>
<ol>
<li><strong>-XX:+ExplicitGCInvokesConcurrent</strong>， 但不要<strong>-XX:+DisableExplicitGC</strong>， 比如<a href="http://calvin1978.blogcn.com/articles/directbytebuffer.html" target="_blank" rel="external">Netty之堆外内存扫盲篇</a>，可见禁了system.gc() 未必是好事，只要自己的代码里没有调它，也没用什么特别烂的类库，真有人调了总有调的原因。-XX+ExplicitGCInvokesConcurrent 则在full gc时，并不全程停顿，依然只在ygc和两个remark阶段停顿，详见<a href="http://lovestblog.cn/blog/2015/05/07/system-gc/" target="_blank" rel="external">JVM源码分析之SystemGC完全解读</a></li>
<li><strong>-XX: ParallelRefProcEnabled</strong> , 默认为false，并行的处理Reference对象，如WeakReference，除非在GC log里出现Reference处理时间较长的日志，否则效果不会很明显，但我们总是要JVM尽量的并行，所以设了也就设了。</li>
</ol>
<h4 id="2-2-GC里不建议修改的参数"><a href="#2-2-GC里不建议修改的参数" class="headerlink" title="2.2 GC里不建议修改的参数"></a>2.2 GC里不建议修改的参数</h4><ol>
<li><strong>-XX:+CMSClassUnloadingEnabled</strong>，在CMS中清理永久代中的过期的Class而不等到Full GC，JDK7默认关闭而JDK8打开。看自己情况，比如有没有运行动态语言脚本如Groovy产生大量的临时类。它会增加CMS remark的暂停时间，所以如果新类加载并不频繁，这个参数还是不开的好。</li>
<li>用了CMS，新生代收集默认就是<strong>-XX:+UseParNewGC</strong>，不用自己设。</li>
<li>并发收集线程数</li>
</ol>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; ParallelGCThreads＝8+( Processor - 8 ) ( 5/8 )，</div><div class="line">&gt;</div><div class="line">&gt; ConcGCThreads = (ParallelGCThreads + 3)/4</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>比如双CPU，六核，超线程就是24个处理器，小于8个处理器时ParallelGCThreads按处理器数量，大于时按上述公式ParallelGCThreads＝18， ConcGCThreads＝5。除了一些不在乎停顿时间的后台辅助程序会特意把它减少，平时不建议动。</p>
<ol>
<li><p><strong>-XX:+CMSScavengeBeforeRemark</strong>，默认为关闭，在CMS remark前，先执行一次minor GC将新生代清掉，这样从老生代的对象引用到的新生代对象的个数就少了，停止全世界的CMS remark阶段就短一些。如果看到GC日志里remark阶段的时间超长，可以打开此项看看有没有效果，否则还是不要打开了，白白多了次YGC。</p>
</li>
<li><p><strong>-XX:CMSFullGCsBeforeCompaction</strong>，默认为0，即每次full gc都对老生代进行碎片整理压缩。<strong>Full GC 不同于前面设置的75%老生代时触发的CMS GC，只在System.gc()，老生代达到100%，老生代碎片过大无法分配空间给新晋升的大对象这些特殊情况里发生，所以设为每次都进行碎片整理是合适的</strong>。</p>
<p>CMS并发GC不是“full GC”。HotSpot VM里对concurrent collection和full collection有明确的区分。所有带有“FullCollection”字样的VM参数都是跟真正的full GC相关，而跟CMS并发GC无关的。 </p>
<p>CMSFullGCsBeforeCompaction这个参数在HotSpot VM里是这样声明的： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">product(<span class="keyword">bool</span>, UseCMSCompactAtFullCollection, <span class="literal">true</span>,                     </div><div class="line"></div><div class="line">	<span class="string">"Use mark sweep compact at full collections"</span>)                  </div><div class="line"></div><div class="line">product(uintx, CMSFullGCsBeforeCompaction, <span class="number">0</span>,                          </div><div class="line"></div><div class="line">        <span class="string">"Number of CMS full collection done before compaction if &gt; 0"</span>)</div></pre></td></tr></table></figure>
<p>然后这样使用的： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">*should_compact =  </div><div class="line">   UseCMSCompactAtFullCollection &amp;&amp;  </div><div class="line">   ((_full_gcs_since_conc_gc &gt;= CMSFullGCsBeforeCompaction) ||  </div><div class="line">    GCCause::is_user_requested_gc(gch-&gt;gc_cause()) ||  </div><div class="line">    gch-&gt;incremental_collection_will_fail(<span class="literal">true</span> <span class="comment">/* consult_young */</span>));</div></pre></td></tr></table></figure>
<p>CMS GC要决定是否在full GC时做压缩，会依赖几个条件。其中， </p>
<p>第一种条件，UseCMSCompactAtFullCollection 与 CMSFullGCsBeforeCompaction 是搭配使用的；前者目前默认就是true了，也就是关键在后者上。 </p>
<p>第二种条件是用户调用了System.gc()，而且DisableExplicitGC没有开启。 </p>
<p>第三种条件是young gen报告接下来如果做增量收集会失败；简单来说也就是young gen预计old gen没有足够空间来容纳下次young GC晋升的对象。 </p>
<p>上述三种条件的任意一种成立都会让CMS决定这次做full GC时要做压缩。 </p>
<p>（还有另一个参数，CMSCompactWhenClearAllSoftRefs，这个就先不说了，反正你没有配置它，而且默认也是true） </p>
<p>CMSFullGCsBeforeCompaction 说的是，在上一次CMS并发GC执行过后，到底还要再执行多少次full GC才会做压缩。默认是0，也就是在默认配置下每次CMS GC顶不住了而要转入full GC的时候都会做压缩。 </p>
<p><strong>把CMSFullGCsBeforeCompaction配置为10，就会让上面说的第一个条件变成每隔10次真正的full GC才做一次压缩（而不是每10次CMS并发GC就做一次压缩，目前VM里没有这样的参数）。这会使full GC更少做压缩，也就更容易使CMS的old gen受碎片化问题的困扰。</strong> </p>
<p><strong>本来这个参数就是用来配置降低full GC压缩的频率，以期减少某些full GC的暂停时间。CMS回退到full GC时用的算法是mark-sweep-compact，但compaction是可选的，不做的话碎片化会严重些但这次full GC的暂停时间会短些；这是个取舍。</strong></p>
<p>​</p>
</li>
</ol>
<h4 id="2-3-内存大小的设置"><a href="#2-3-内存大小的设置" class="headerlink" title="2.3 内存大小的设置"></a>2.3 内存大小的设置</h4><p>这些关于大小的参数，给人感觉是最踏实可控的。</p>
<p>其实JVM除了显式设置的-Xmx堆内存，还有一堆其他占内存的地方(堆外内存，线程栈，永久代，二进制代码cache)，在容量规划的时候要留意。</p>
<p>关键业务系统的服务器上内存一般都是够的，所以尽管设得宽松点。</p>
<ol>
<li><strong>-Xmx, -Xms</strong>, 堆内存大小，2～4G均可，再大了注意GC时间。</li>
<li><strong>-Xmn or -XX:NewSize and -XX:MaxNewSize or -XX:NewRatio</strong>， JDK默认新生代占堆大小的1/3， 个人喜欢把对半分， 增大新生代的大小，能减少GC的频率（但也会加大每次GC的停顿时间），主要是看老生代里没多少长期对象的话，占2/3太多了。可以用-Xmn 直接赋值(等于-XX:NewSize and -XX:MaxNewSize同值的缩写)，或把NewRatio设为1来对半分(但如果想设置新生代比老生代大就只能用-Xmn)。</li>
<li><strong>-XX: PermSize=128m -XX:MaxPermSize=512m （JDK7）</strong>现在的应用有Hibernate/Spring这些闹腾的家伙AOP之后类都比较多，可以一开始就把初始值从64M设到128M，并设一个更大的Max值以求保险，之前就遇到反射的类过多把永久代撑爆的案例，不过这时候业务也应该考虑拆分了，过多的代码集中在同个项目中，长期看来不易于维护。</li>
<li><strong>-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m（JDK8）</strong>，JDK8的永生代几乎可用完机器的所有内存(可怕😱)，同样设一个128M的初始值，512M的最大值保护一下。</li>
</ol>
<h4 id="2-4-其他内存大小等可选设置"><a href="#2-4-其他内存大小等可选设置" class="headerlink" title="2.4 其他内存大小等可选设置"></a>2.4 其他内存大小等可选设置</h4><ol>
<li><strong>-XX:SurvivorRatio</strong> 新生代中每个存活区的大小，默认为8，即1/10的新生代 1/(SurvivorRatio+2)，有人喜欢设小点省点给新生代，但要避免太小使得存活区放不下临时对象而要晋升到老生代，还是从GC Log里看实际情况了。</li>
</ol>
<ol>
<li><strong>-Xss</strong> 在堆之外，线程占用栈内存，默认每条线程为1M（以前是256K）。存放方法调用出参入参的栈，局部变量，标量替换后掉局部变量等，有人喜欢设小点节约内存开更多线程。但反正内存够也就不必要设小，有人喜欢再设大点，特别是有JSON解析之类的递归调用时不能设太小。</li>
<li><strong>-XX:MaxDirectMemorySize</strong>，堆外内存/直接内存的大小，默认为Heap区总内存减去一个Survivor区的大小，详见<a href="http://calvin1978.blogcn.com/articles/directbytebuffer.html" target="_blank" rel="external">Netty之堆外内存扫盲篇</a>。</li>
<li><strong>-XX:ReservedCodeCacheSize</strong>， JIT编译后二进制代码的存放区，满了之后就不再编译。JDK7默认不开多层编译48M，开了96M，而JDK8默认开多层编译240M。可以在JMX里看看CodeCache的大小，JDK7下的48M一般够了，也可以把它设大点，反正内存多。</li>
</ol>
<h4 id="2-5-GC日志"><a href="#2-5-GC日志" class="headerlink" title="2.5 GC日志"></a>2.5 GC日志</h4><p> 1.基本配置</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;  -Xloggc:/dev/shm/gc.log -XX:+PrintGCDateStamps -XX:+PrintGCDetails</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>一般的，上面的就足够了，我们生产环境一个离线服务的配置是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationConcurrentTime -XX:+PrintHeapAtGC -Xloggc:/dev/shm/xx_gclog.txt</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>详见<a href="http://ifeve.com/useful-jvm-flags-part-8-gc-logging/" target="_blank" rel="external">JVM实用参数（八）GC日志</a>，有人担心写GC日志会影响性能，但测试下来实在没什么影响，还是留一份用来排查好。</p>
<p>到后来，又发现如果遇上高IO的情况，如果GC的时候，操作系统正在flush pageCache 到磁盘，也可能导致GC log文件被锁住，从而让GC结束不了。所以把它指向了/dev/shm 这种内存中文件系统，避免这种停顿，详见<a href="http://calvin1978.blogcn.com/articles/%E2%80%9Chttp://engineering.linkedin.com/blog/2016/02/eliminating-large-jvm-gc-pauses-caused-by-background-io-traffic%E2%80%9D" target="_blank" rel="external">Eliminating Large JVM GC Pauses Caused by Background IO Traffic</a></p>
<p>用+PrintGCDateStamps而不是PrintGCTimeStamps，打印可读的日期而不是时间戳。</p>
<ol>
<li><strong>-XX:+PrintGCApplicationStoppedTime</strong>，它的名字没起好，它除了打印清晰的GC停顿时间外，还可以打印其他的停顿时间，比如取消偏向锁，class 被agent redefine，code deoptimization等等，有助于发现一些原来没想到的问题，建议也加上。如果真的发现了一些不知什么的停顿，再临时加上<code>&quot;-XX:+PrintSafepointStatistics -XX: PrintSafepointStatisticsCount=1&quot;</code> 找原因。</li>
<li>GC日志默认会在重启后清空，但有人担心长期运行不重启的应用会把文件弄得很大，有<figure class="highlight plain"><figcaption><span>-XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=1M```的参数可以让日志滚动起来。但重启后的文件名太混乱太让人头痛，所以还是不加。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">### 3. 监控篇</div><div class="line"></div><div class="line">JVM输出的各种日志，如果未指定路径，通常会生成到运行应用的相同目录，为了避免有时候在不同的地方执行启动脚本，一般将日志路径集中设到一个固定的地方。</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">#### 3.1 -XX:+PrintCommandLineFlags</div><div class="line"></div><div class="line">运维有时会对启动参数做一些临时的更改，将每次启动的参数输出到stdout，将来有据可查。</div><div class="line">打印出来的是命令行里设置了的参数以及因为这些参数隐式影响的参数，比如开了CMS后，-XX:+UseParNewGC也被自动打开。</div><div class="line"></div><div class="line">#### 3.2 -XX:-OmitStackTraceInFastThrow</div><div class="line"></div><div class="line">为异常设置StackTrace是个昂贵的操作，所以当应用在相同地方抛出相同的异常N次(两万?)之后，JVM会对某些特定异常如NPE，数组越界等进行优化，不再带上异常栈。此时，你可能会看到日志里一条条Nul Point Exception，而真正输出完整栈的日志早被滚动到不知哪里去了，也就完全不知道这NPE发生在什么地方，欲哭无泪。 所以，将它禁止吧。</div><div class="line"></div><div class="line">#### 3.3 coredump与 -XX:ErrorFile</div><div class="line"></div><div class="line">JVM crash时，hotspot 会生成一个error文件，提供JVM状态信息的细节。如前所述，将其输出到固定目录，避免到时会到处找这文件。文件名中的%p会被自动替换为应用的PID</div><div class="line"></div><div class="line">&gt; ```shell</div><div class="line">&gt;  -XX:ErrorFile=$&#123;MYLOGDIR&#125;/hs_err_%p.log</div><div class="line">&gt;</div></pre></td></tr></table></figure></li>
</ol>
<p>&gt;</p>
<blockquote>
</blockquote>
<p>当然，更好的做法是生成coredump，从CoreDump能够转出Heap Dump 和 Thread Dump 还有crash的地方，非常实用。</p>
<p>在启动脚本里加上 ulimit -c unlimited或其他的设置方式，如果有root权限，设一下输出目录更好</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;  echo &quot;/&#123;MYLOGDIR&#125;/coredump.%p&quot; &gt; /proc/sys/kernel/core_pattern</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>什么？你不知道这coredump有什么用？看来你是没遇过JVM Segment Fault的幸福人。</p>
<h4 id="3-4-XX-HeapDumpOnOutOfMemoryError"><a href="#3-4-XX-HeapDumpOnOutOfMemoryError" class="headerlink" title="3.4 -XX:+HeapDumpOnOutOfMemoryError"></a>3.4 -XX:+HeapDumpOnOutOfMemoryError</h4><p>在Out Of Memory，JVM快死快死掉的时候，输出Heap Dump到指定文件。不然开发很多时候还真不知道怎么重现错误。</p>
<p>路径只指向目录，JVM会保持文件名的唯一性，叫java_pid${pid}.hprof。如果指向文件，而文件已存在，反而不能写入。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; -XX:+HeapDumpOnOutOfMemoryError </div><div class="line">&gt; -XX:HeapDumpPath=$&#123;LOGDIR&#125;/</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="3-5-JMX"><a href="#3-5-JMX" class="headerlink" title="3.5 JMX"></a>3.5 JMX</h4><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;  -Dcom.sun.management.jmxremote.port=$&#123;MY_JMX_PORT&#125; -Dcom.sun.management.jmxremote </div><div class="line">&gt;</div><div class="line">&gt; -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false </div><div class="line">&gt;</div><div class="line">&gt; -Djava.rmi.server.hostname=127.0.0.1</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>以上设置，只让本地的Zabbix之类监控软件通过JMX监控JVM，不允许远程访问。</p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><h4 id="4-1-性能相关"><a href="#4-1-性能相关" class="headerlink" title="4.1 性能相关"></a>4.1 性能相关</h4><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;  -XX:-UseBiasedLocking </div><div class="line">&gt;  -XX:-UseCounterDecay </div><div class="line">&gt;  -XX:AutoBoxCacheMax=20000 </div><div class="line">&gt;  -XX:+PerfDisableSharedMem </div><div class="line">&gt;  -XX:+AlwaysPreTouch </div><div class="line">&gt;  -Djava.security.egd=file:/dev/./urandom</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="4-2-内存大小相关-JDK7"><a href="#4-2-内存大小相关-JDK7" class="headerlink" title="4.2 内存大小相关(JDK7)"></a>4.2 内存大小相关(JDK7)</h4><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;  -Xms4096m </div><div class="line">&gt;  -Xmx4096m </div><div class="line">&gt;  -Xmn2048m </div><div class="line">&gt;  -XX:MaxDirectMemorySize=4096m </div><div class="line">&gt;  -XX: PermSize=256m </div><div class="line">&gt;  -XX:MaxPermSize=512m </div><div class="line">&gt;  -XX:ReservedCodeCacheSize=240M</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="4-3-CMS-GC-相关"><a href="#4-3-CMS-GC-相关" class="headerlink" title="4.3 CMS GC 相关"></a>4.3 CMS GC 相关</h4><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;  -XX:+UseConcMarkSweepGC </div><div class="line">&gt;  -XX:CMSInitiatingOccupancyFraction=75 </div><div class="line">&gt;  -XX:+UseCMSInitiatingOccupancyOnly </div><div class="line">&gt;  -XX:MaxTenuringThreshold=6 </div><div class="line">&gt;  -XX:+ExplicitGCInvokesConcurrent </div><div class="line">&gt;  -XX:+ParallelRefProcEnabled</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="4-4-GC-日志-相关"><a href="#4-4-GC-日志-相关" class="headerlink" title="4.4 GC 日志 相关"></a>4.4 GC 日志 相关</h4><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;  -Xloggc:/dev/shm/app-gc.log </div><div class="line">&gt;  -XX:+PrintGCApplicationStoppedTime </div><div class="line">&gt;  -XX:+PrintGCDateStamps </div><div class="line">&gt;  -XX:+PrintGCDetails</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="4-5-异常-日志-相关"><a href="#4-5-异常-日志-相关" class="headerlink" title="4.5 异常 日志 相关"></a>4.5 异常 日志 相关</h4><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;  -XX:-OmitStackTraceInFastThrow </div><div class="line">&gt;  -XX:ErrorFile=$&#123;LOGDIR&#125;/hs_err_%p.log </div><div class="line">&gt;  -XX:+HeapDumpOnOutOfMemoryError</div><div class="line">&gt;  -XX:HeapDumpPath=$&#123;LOGDIR&#125;/</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="4-6-JMX相关"><a href="#4-6-JMX相关" class="headerlink" title="4.6 JMX相关"></a>4.6 JMX相关</h4><p>见3.5</p>
<h3 id="最后，上图总结一把："><a href="#最后，上图总结一把：" class="headerlink" title="最后，上图总结一把："></a>最后，上图总结一把：</h3><p><img src="https://ww3.sinaimg.cn/large/006tNc79gw1fblo4zsqbdj317k1he1kx.jpg" alt=""></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p> <a href="http://calvin1978.blogcn.com/articles/jvmoption-2.html" target="_blank" rel="external">JVM参数推荐</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://chen-tao.github.io/2017/01/09/jit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen-Tao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/09/jit/" itemprop="url">
                  JIT编译器解读
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-09T00:00:00+08:00">
                2017-01-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jvm/" itemprop="url" rel="index">
                    <span itemprop="name">jvm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为什么JIT"><a href="#为什么JIT" class="headerlink" title="为什么JIT"></a>为什么JIT</h2><p><strong>JIT 是 just in time 的缩写, 也就是即时编译编译器。</strong>使用即时编译器技术，能够加速程序的执行速度。</p>
<p>以Java/C#,NET为代表的Coffee Based 语言，是建立在虚拟机之上的。</p>
<p>这种虚拟机和一般其他语言的运行库有一个很大不同，就是它好像一个有独立体系结构的计算机。 </p>
<p>Java/C#,NET的程序要运行在这些虚拟机之上，就必须要编译成虚拟机独有的中间语言。Java叫字节码，C#,NET有很多种叫法，姑且简称CIL。这些中间语言身上有很深很深的汇编指令集样式语法痕迹，这也从 另一个侧面说明虚拟机的体系结构多么像一个冯诺依曼计算机。</p>
<p>虚拟机传统的解释器，就是要在中间语言，和真正的平台体系结构之间的指令做映射。比如把Java的load指令换成native code 的load指令。</p>
<p> <strong>JIT的出现，是为了补强虚拟机边运行边解释的低性能。它会智能地对热点代码进行优化且重复利用。从策略的角度来讲，就是通过查表或者缓存而不是重复解决子问题而大大缩短解决问题的时间。</strong></p>
<p><u><em>它的优点是，智能缩短映射的过程。</em></u></p>
<p><u><em>它的缺点是，过于复杂。</em></u></p>
<p>首先代码优化的种种策略都是基于各种各样的假定，假定不一定会成真，即使费尽心机做的代码优化，也有可能在现实中无法提高性能。其次，不同平台和体系结构的技术特点千差万别，这个映射过程只能单独定制。比如至今Java平台还不能在IOS上做基本映射（即解释器都不行）。</p>
<p>以前JIT刚出现的时候，只是一个挂载的外挂一样的东西。现在开始喧宾夺主取代了解释器。这种转变其实是对中间语言解释器作为一个“薄的胶合层”的一个设计上的自我否定，极大地增加了设计的复杂性。目前对于这种强行加速做得比较好的，就是Java系为代表的各种虚拟机，微软的虚拟机，或者谷歌搞出来的V8引擎（这不知道是不是目前为止设计进生产实践中惟一被广泛应用的动态强行加速）。这几件东西其实无一不是大型商业公司的强大支持的产物。现在主流的动态语言大多都是社区在推进，没那么多资源来投入JIT，这是他们没有好的JIT的一个关键因素。</p>
<p>本身动态语言的应用场景就不是为了追求高性能，更何况现在各种应用场景下的瓶颈大部分都在语言之外，语言的性能考量又是一个比较次要的需求了。但是JIT对于编译层的优化还是显而易见的，甚至可以说汇聚了很多生产环境中的经验，通过JIT的优化，服务的请求质量可以提升一个档次，对于业务帮助也很大，下面我们着重介绍一下java中的JIT与其实现。</p>
<h2 id="Java中的JIT"><a href="#Java中的JIT" class="headerlink" title="Java中的JIT"></a>Java中的JIT</h2><p><img src="https://ww3.sinaimg.cn/large/006y8lVagw1fbldh80l07j30fh0h576f.jpg" alt=""> </p>
<pre><code>Java程序最初是仅仅通过解释器解释执行的，即对字节码逐条解释执行，这种方式的执行速度相对会比较慢，尤其当某个方法或代码块运行的特别频繁时，这种方式的执行效率就显得很低。于是后来在虚拟机中引入了JIT编译器（即时编译器），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是JIT编译器。

现在主流的商用虚拟机（如Sun HotSpot、IBM J9）中几乎都同时包含解释器和编译器（三大商用虚拟机之一的JRockit是个例外，它内部没有解释器，因此会有启动相应时间长之类的缺点，但它主要是面向服务端的应用，这类应用一般不会重点关注启动时间）。二者各有优势：当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行；当程序运行后，随着时间的推移，编译器逐渐会返回作用，把越来越多的代码编译成本地代码后，可以获取更高的执行效率。解释执行可以节约内存，而编译执行可以提升效率。

HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，分别对应JVM的Client与Server模式，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。
</code></pre><p>运行过程中会被即时编译器编译的“热点代码”有两类：</p>
<ul>
<li>被多次调用的方法。</li>
<li><p>被多次调用的循环体。</p>
<p>  两种情况，编译器都是以整个方法作为编译对象，这种编译也是虚拟机中标准的编译方式。要知道一段代码或方法是不是热点代码，是不是需要触发即时编译，需要进行Hot Spot Detection（热点探测）。目前主要的热点 判定方式有以下两种：</p>
</li>
<li><p>基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</p>
</li>
<li><p>基于计数器的热点探测：采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。</p>
<p>  在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。</p>
<p>  方法调用计数器用来统计方法调用的次数，在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数。</p>
<p>  回边计数器用于统计一个方法中循环体代码执行的次数（准确地说，应该是回边的次数，因为并非所有的循环都是回边），在字节码中遇到控制流向后跳转的指令就称为“回边”。</p>
<p>  在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阀值，当计数器的值超过了阀值，就会触发JIT编译。触发了JIT编译后，在默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成为止（编译工作在后台线程中进行）。当编译工作完成后，下一次调用该方法或代码时，就会使用已编译的版本。</p>
<p>  由于方法计数器触发即时编译的过程与回边计数器触发即时编译的过程类似，因此这里仅给出方法调用计数器触发即时编译的流程：</p>
</li>
</ul>
<p><img src="https://ww2.sinaimg.cn/large/006y8lVagw1fbldpe8c6vj30f50gut9l.jpg" alt=""></p>
<h2 id="jvm使用JIT"><a href="#jvm使用JIT" class="headerlink" title="jvm使用JIT"></a>jvm使用JIT</h2><p><strong>JIT是java性能在同等条件下课超越C系列语言的关键！</strong></p>
<p><img src="https://ww3.sinaimg.cn/large/006y8lVagw1fbldzegb7sj31380lmae5.jpg" alt=""></p>
<p><a href="https://wiki.openjdk.java.net/display/HotSpot/PerformanceTacticIndex" target="_blank" rel="external">JIT优化项一览(2009)</a></p>
<p><img src="https://ww1.sinaimg.cn/large/006y8lVagw1fbldzuain2j31360m40vp.jpg" alt=""></p>
<p><img src="https://ww3.sinaimg.cn/large/006y8lVagw1fble0dpvrwj31320m0q76.jpg" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html" target="_blank" rel="external">hello_JIT</a></p>
<p><a href="http://blog.csdn.net/ns_code/article/details/18009455" target="_blank" rel="external">javac与JIT编译</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/" target="_blank" rel="external">深入浅出JIT</a></p>
<p><a href="http://calvin1978.blogcn.com/articles/javatuning.html" target="_blank" rel="external">java性能优化指南</a></p>
<p><a href="https://github.com/adoptopenjdk/jitwatch" target="_blank" rel="external">jitwatch github</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/1845119?v=3&u=4af70cb5a5853732074c58284505ee6864e51b8c&s=400"
               alt="Chen Tao" />
          <p class="site-author-name" itemprop="name">Chen Tao</p>
           
              <p class="site-description motion-element" itemprop="description">Engineer Blogger Creator Runner | ML DM JVM Web | 旅行 电影 歌手 摄影 | 读书的要义是尽量求得客观的认识，不是为了炫耀自己的‘创造力’，或‘发前人所未发’。 优秀程序员的价值，不在于其所掌握的几招屠龙之术，而是在细节中见真著。 如果我们可以一次把事情做对做好，在允许的范围内尽可能追求卓越，为什么不去做呢。 | @HNU</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">178</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">92</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Chen-tao" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/Chentao11" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/546410275" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/chen-tao-68-95" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-book"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Tao</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
